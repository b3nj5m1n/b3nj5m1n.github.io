{"mappings":"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","sources":["node_modules/cubing/src/cubing/puzzle-geometry/FaceNameSwizzler.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/NullMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/FTONotationMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/FaceRenamingMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/MegaminxScramblingNotationMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/NxNxNCubeMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/PyraminxNotationMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/notation-mapping/SkewbNotationMapper.ts","node_modules/cubing/src/cubing/puzzle-geometry/Options.ts","node_modules/cubing/src/cubing/puzzle-geometry/Perm.ts","node_modules/cubing/src/cubing/puzzle-geometry/PermOriSet.ts","node_modules/cubing/src/cubing/puzzle-geometry/PGPuzzles.ts","node_modules/cubing/src/cubing/puzzle-geometry/Quat.ts","node_modules/cubing/src/cubing/puzzle-geometry/PlatonicGenerator.ts","node_modules/cubing/src/cubing/puzzle-geometry/SchreierSims.ts","node_modules/cubing/src/cubing/puzzle-geometry/PuzzleGeometry.ts","node_modules/cubing/src/cubing/alg/iteration.ts","node_modules/cubing/src/cubing/alg/common.ts","node_modules/cubing/src/cubing/alg/limits.ts","node_modules/cubing/src/cubing/alg/AlgBuilder.ts","node_modules/cubing/src/cubing/alg/units/containers/Commutator.ts","node_modules/cubing/src/cubing/alg/units/containers/Conjugate.ts","node_modules/cubing/src/cubing/alg/units/leaves/LineComment.ts","node_modules/cubing/src/cubing/alg/units/leaves/Newline.ts","node_modules/cubing/src/cubing/alg/units/leaves/Pause.ts","node_modules/cubing/src/cubing/alg/parse.ts","node_modules/cubing/src/cubing/alg/warnOnce.ts","node_modules/cubing/src/cubing/alg/units/QuantumWithAmount.ts","node_modules/cubing/src/cubing/alg/units/leaves/Move.ts","node_modules/cubing/src/cubing/alg/units/containers/Grouping.ts","node_modules/cubing/src/cubing/alg/is.ts","node_modules/cubing/src/cubing/alg/traversal.ts","node_modules/cubing/src/cubing/alg/Alg.ts","node_modules/cubing/src/cubing/alg/example.ts","node_modules/cubing/src/cubing/alg/keyboard.ts","node_modules/cubing/src/cubing/alg/operation.ts"],"sourcesContent":["// Manages a set of face names.  Detects whether they are prefix-free.\n// Implements greedy splitting into face names and comparisons between\n// concatenated face names and grip names.\n\nexport class FaceNameSwizzler {\n  public prefixFree: boolean = true;\n  public gripnames: string[] = [];\n  constructor(public facenames: string[], gripnames_arg?: string[]) {\n    if (gripnames_arg) {\n      this.gripnames = gripnames_arg;\n    }\n    for (let i = 0; this.prefixFree && i < facenames.length; i++) {\n      for (let j = 0; this.prefixFree && j < facenames.length; j++) {\n        if (i !== j && facenames[i].startsWith(facenames[j])) {\n          this.prefixFree = false;\n        }\n      }\n    }\n  }\n\n  public setGripNames(names: string[]): void {\n    this.gripnames = names;\n  }\n\n  // split a string into face names and return a list of\n  // indices.\n  public splitByFaceNames(s: string): number[] {\n    const r = [];\n    let at = 0;\n    while (at < s.length) {\n      if (at > 0 && at < s.length && s[at] === \"_\") {\n        at++;\n      }\n      let currentMatch = -1;\n      for (let i = 0; i < this.facenames.length; i++) {\n        if (\n          s.substr(at).startsWith(this.facenames[i]) &&\n          (currentMatch < 0 ||\n            this.facenames[i].length > this.facenames[currentMatch].length)\n        ) {\n          currentMatch = i;\n        }\n      }\n      if (currentMatch >= 0) {\n        r.push(currentMatch);\n        at += this.facenames[currentMatch].length;\n      } else {\n        throw new Error(\"Could not split \" + s + \" into face names.\");\n      }\n    }\n    return r;\n  }\n\n  // cons a grip from an array of numbers.\n  public joinByFaceIndices(list: number[]): string {\n    let sep = \"\";\n    const r = [];\n    for (let i = 0; i < list.length; i++) {\n      r.push(sep);\n      r.push(this.facenames[list[i]]);\n      if (!this.prefixFree) {\n        sep = \"_\";\n      }\n    }\n    return r.join(\"\");\n  }\n\n  /*\n   *   Try to match something the user gave us with some geometric\n   *   feature.  We used to have strict requirements:\n   *\n   *      a)  The set of face names are prefix free\n   *      b)  When specifying a corner, all coincident planes were\n   *          specified\n   *\n   *   But, to allow megaminx to have more reasonable and\n   *   conventional names, and to permit shorter canonical\n   *   names, we are relaxing these requirements and adding\n   *   new syntax.  Now:\n   *\n   *      a)  Face names need not be syntax free.\n   *      b)  When parsing a geometric name, we use greedy\n   *          matching, so the longest name that matches the\n   *          user string at the current position is the one\n   *          assumed to match.\n   *      c)  Underscores are permitted to separate face names\n   *          (both in user input and in geometric\n   *          descriptions).\n   *      d)  Default names of corner moves where corners have\n   *          more than three corners, need only include three\n   *          of the corners.\n   *\n   *   This code is not performance-sensitive so we can do it a\n   *   slow and simple way.\n   */\n  public spinmatch(userinput: string, longname: string): boolean {\n    // are these the same rotationally?\n    if (userinput === longname) {\n      return true;\n    }\n    try {\n      const e1 = this.splitByFaceNames(userinput);\n      const e2 = this.splitByFaceNames(longname);\n      // All elements of userinput need to be in the longname.\n      // There should be no duplicate elements in the userinput.\n      // if both have length 1 or length 2, the sets must be equal.\n      // if both have length 3 or more, then the first set must be\n      // a subset of the second.  Order doesn't matter.\n      if (e1.length !== e2.length && e1.length < 3) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        for (let j = 0; j < i; j++) {\n          if (e1[i] === e1[j]) {\n            return false;\n          }\n        }\n        let found = false;\n        for (let j = 0; j < e2.length; j++) {\n          if (e1[i] === e2[j]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /* same as above, but permit both to have v's on the end. */\n  public spinmatchv(userinput: string, longname: string): boolean {\n    if (userinput.endsWith(\"v\") && longname.endsWith(\"v\")) {\n      return this.spinmatch(\n        userinput.slice(0, userinput.length - 1),\n        longname.slice(0, longname.length - 1),\n      );\n    } else {\n      return this.spinmatch(userinput, longname);\n    }\n  }\n\n  public unswizzle(s: string): string {\n    if ((s.endsWith(\"v\") || s.endsWith(\"w\")) && s[0] <= \"Z\") {\n      s = s.slice(0, s.length - 1);\n    }\n    const upperCaseGrip = s.toUpperCase();\n    for (let i = 0; i < this.gripnames.length; i++) {\n      const g = this.gripnames[i];\n      if (this.spinmatch(upperCaseGrip, g)) {\n        return g;\n      }\n    }\n    return s;\n  }\n}\n","import type { Move } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NullMapper implements NotationMapper {\n  public notationToInternal(move: Move): Move | null {\n    return move;\n  }\n\n  public notationToExternal(move: Move): Move | null {\n    return move;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FTONotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper, private sw: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (\n      move.family === \"T\" &&\n      move.innerLayer === undefined &&\n      move.outerLayer === undefined\n    ) {\n      return new Move(\n        new QuantumMove(\"FLRv\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else {\n      const r = this.child.notationToInternal(move);\n      return r;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    let fam = move.family;\n    if (fam.length > 0 && fam[fam.length - 1] === \"v\") {\n      fam = fam.substring(0, fam.length - 1);\n    }\n    if (this.sw.spinmatch(fam, \"FLUR\")) {\n      return new Move(\n        new QuantumMove(\"T\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n","// face renaming mapper.  Accepts two face name remappers.  We\n// work between the two.\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class FaceRenamingMapper implements NotationMapper {\n  constructor(\n    public internalNames: FaceNameSwizzler,\n    public externalNames: FaceNameSwizzler,\n  ) {}\n\n  // TODO:  consider putting a cache in front of this\n  public convertString(\n    grip: string,\n    a: FaceNameSwizzler,\n    b: FaceNameSwizzler,\n  ): string {\n    let suffix = \"\";\n    if ((grip.endsWith(\"v\") || grip.endsWith(\"v\")) && grip <= \"_\") {\n      suffix = grip.slice(grip.length - 1);\n      grip = grip.slice(0, grip.length - 1);\n    }\n    const upper = grip.toUpperCase();\n    let isLowerCase = false;\n    if (grip !== upper) {\n      isLowerCase = true;\n      grip = upper;\n    }\n    grip = b.joinByFaceIndices(a.splitByFaceNames(grip));\n    if (isLowerCase) {\n      grip = grip.toLowerCase();\n    }\n    return grip + suffix;\n  }\n\n  public convert(move: Move, a: FaceNameSwizzler, b: FaceNameSwizzler): Move {\n    const grip = move.family;\n    const ngrip = this.convertString(grip, a, b);\n    if (grip === ngrip) {\n      return move;\n    } else {\n      return new Move(\n        new QuantumMove(ngrip, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n  }\n\n  public notationToInternal(move: Move): Move {\n    const r = this.convert(move, this.externalNames, this.internalNames);\n    return r;\n  }\n\n  public notationToExternal(move: Move): Move {\n    return this.convert(move, this.internalNames, this.externalNames);\n  }\n}\n","// Sits on top of a (possibly null) notation mapper, and\n\nimport { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\n// adds R++/R--/D++/D-- notation mapping.\nexport class MegaminxScramblingNotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer === undefined && move.outerLayer === undefined) {\n      if (Math.abs(move.amount) === 1) {\n        if (move.family === \"R++\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"R--\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), 2 * move.amount);\n        } else if (move.family === \"D++\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D--\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), 2 * move.amount);\n        }\n\n        // TODO: Figure out if `cubing/alg` should parse `R++` to a family of `R++`.\n        if (move.family === \"R_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), -2 * move.amount);\n        } else if (move.family === \"D_PLUSPLUS_\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), -2 * move.amount);\n        }\n      }\n      if (move.family === \"y\") {\n        return new Move(\"Uv\", move.amount);\n      }\n    }\n    return this.child.notationToInternal(move);\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (move.family === \"Uv\") {\n      return new Move(\n        new QuantumMove(\"y\", move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    }\n    if (move.family === \"Dv\") {\n      return new Move(\"y\", -move.amount);\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nexport class NxNxNCubeMapper implements NotationMapper {\n  constructor(public slices: number) {}\n\n  public notationToInternal(move: Move): Move {\n    const grip = move.family;\n    if (!move.innerLayer && !move.outerLayer) {\n      if (grip === \"x\") {\n        move = new Move(\"Rv\", move.amount);\n      } else if (grip === \"y\") {\n        move = new Move(\"Uv\", move.amount);\n      } else if (grip === \"z\") {\n        move = new Move(\"Fv\", move.amount);\n      }\n      if ((this.slices & 1) === 1) {\n        if (grip === \"E\") {\n          move = new Move(\n            new QuantumMove(\"D\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"M\") {\n          move = new Move(\n            new QuantumMove(\"L\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        } else if (grip === \"S\") {\n          move = new Move(\n            new QuantumMove(\"F\", (this.slices + 1) / 2),\n            move.amount,\n          );\n        }\n      }\n      if (this.slices > 2) {\n        if (grip === \"e\") {\n          move = new Move(\n            new QuantumMove(\"D\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"m\") {\n          move = new Move(\n            new QuantumMove(\"L\", this.slices - 1, 2),\n            move.amount,\n          );\n        } else if (grip === \"s\") {\n          move = new Move(\n            new QuantumMove(\"F\", this.slices - 1, 2),\n            move.amount,\n          );\n        }\n      }\n    }\n    return move;\n  }\n\n  // do we want to map slice moves to E/M/S instead of 2U/etc.?\n  public notationToExternal(move: Move): Move {\n    const grip = move.family;\n    if (!move.innerLayer && !move.outerLayer) {\n      if (grip === \"Rv\") {\n        return new Move(\"x\", move.amount);\n      } else if (grip === \"Uv\") {\n        return new Move(\"y\", move.amount);\n      } else if (grip === \"Fv\") {\n        return new Move(\"z\", move.amount);\n      } else if (grip === \"Lv\") {\n        return new Move(\"x\", -move.amount);\n      } else if (grip === \"Dv\") {\n        return new Move(\"y\", -move.amount);\n      } else if (grip === \"Bv\") {\n        return new Move(\"z\", -move.amount);\n      }\n    }\n    return move;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst pyraminxFamilyMap: Record<string, string> = {\n  U: \"frl\",\n  L: \"fld\",\n  R: \"fdr\",\n  B: \"dlr\",\n  u: \"FRL\",\n  l: \"FLD\",\n  r: \"FDR\",\n  b: \"DLR\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n};\nconst tetraminxFamilyMap: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n  u: \"frl\",\n  l: \"fld\",\n  r: \"fdr\",\n  b: \"dlr\",\n  Uv: \"FRLv\",\n  Lv: \"FLDv\",\n  Rv: \"FDRv\",\n  Bv: \"DLRv\",\n  D: \"D\",\n  F: \"F\",\n  BL: \"L\",\n  BR: \"R\",\n  d: \"d\",\n  f: \"f\",\n  bl: \"l\",\n  br: \"r\",\n};\n\nconst pyraminxFamilyMapWCA: Record<string, string> = {\n  U: \"FRL\",\n  L: \"FLD\",\n  R: \"FDR\",\n  B: \"DLR\",\n};\n\nconst pyraminxExternalQuantumY = new QuantumMove(\"y\");\nconst pyraminxInternalQuantumY = new QuantumMove(\"Dv\");\n\nexport class PyraminxNotationMapper implements NotationMapper {\n  protected wcaHack: boolean = false;\n  map: Record<string, string> = pyraminxFamilyMap;\n\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      const newFamilyWCA = pyraminxFamilyMapWCA[move.family];\n      if (newFamilyWCA) {\n        return new Move(\n          new QuantumMove(newFamilyWCA, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    const newFamily = this.map[move.family];\n\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.innerLayer, move.outerLayer),\n        move.amount,\n      );\n    } else if (pyraminxExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxInternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {\n      for (const [external, internal] of Object.entries(pyraminxFamilyMapWCA)) {\n        if (this.child.spinmatch(move.family, internal)) {\n          return new Move(\n            new QuantumMove(external, move.innerLayer, move.outerLayer),\n            move.amount,\n          );\n        }\n      }\n    }\n    for (const [external, internal] of Object.entries(this.map)) {\n      if (this.child.spinmatch(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (pyraminxInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(pyraminxExternalQuantumY, -move.amount);\n    } else {\n      return null;\n    }\n  }\n}\n\nexport class TetraminxNotationMapper extends PyraminxNotationMapper {\n  protected wcaHack: true;\n\n  constructor(child: FaceNameSwizzler) {\n    super(child);\n    this.map = tetraminxFamilyMap;\n  }\n}\n","import { Move, QuantumMove } from \"../../alg\";\nimport type { FaceNameSwizzler } from \"../FaceNameSwizzler\";\nimport type { NotationMapper } from \"./NotationMapper\";\n\nconst skewbFamilyMap: Record<string, string> = {\n  U: \"UBL\",\n  UL: \"ULF\",\n  F: \"UFR\",\n  UR: \"URB\",\n  B: \"DBL\",\n  D: \"DFR\",\n  L: \"DLF\",\n  R: \"DRB\",\n  Uv: \"UBLv\",\n  ULv: \"ULFv\",\n  Fv: \"UFRv\",\n  URv: \"URBv\",\n  Bv: \"DBLv\",\n  Dv: \"DFRv\",\n  Lv: \"DLFv\",\n  Rv: \"DRBv\",\n};\n\n// TODO: combine using a similar table.\nconst skewbExternalQuantumX = new QuantumMove(\"x\");\nconst skewbInternalQuantumX = new QuantumMove(\"Rv\");\nconst skewbInternalQuantumXPrime = new QuantumMove(\"Lv\");\nconst skewbExternalQuantumY = new QuantumMove(\"y\");\nconst skewbInternalQuantumY = new QuantumMove(\"Uv\");\nconst skewbInternalQuantumYPrime = new QuantumMove(\"Dv\");\nconst skewbExternalQuantumZ = new QuantumMove(\"z\");\nconst skewbInternalQuantumZ = new QuantumMove(\"Fv\");\nconst skewbInternalQuantumZPrime = new QuantumMove(\"Bv\");\n\nexport class SkewbNotationMapper implements NotationMapper {\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer || move.outerLayer) {\n      return null;\n    }\n    const newFamily = skewbFamilyMap[move.family];\n    if (newFamily) {\n      return new Move(\n        new QuantumMove(newFamily, move.outerLayer, move.innerLayer),\n        move.amount,\n      );\n    }\n    if (skewbExternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumX, move.amount);\n    }\n    if (skewbExternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumY, move.amount);\n    }\n    if (skewbExternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbInternalQuantumZ, move.amount);\n    }\n    return null;\n    /*\n       *   (1) We are not including x/y/z in Skewb; they aren't WCA notation and\n       *   it's unclear anyone needs them for reconstructions.\n       *\n    } else if (move.family === \"x\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Rv\", move.amount);\n    } else if (move.family === \"y\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Uv\", move.amount);\n    } else if (move.family === \"z\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Fv\", move.amount);\n       */\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    for (const [external, internal] of Object.entries(skewbFamilyMap)) {\n      if (this.child.spinmatchv(move.family, internal)) {\n        return new Move(\n          new QuantumMove(external, move.innerLayer, move.outerLayer),\n          move.amount,\n        );\n      }\n    }\n    if (skewbInternalQuantumX.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, move.amount);\n    }\n    if (skewbInternalQuantumXPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumX, -move.amount);\n    }\n    if (skewbInternalQuantumY.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, move.amount);\n    }\n    if (skewbInternalQuantumYPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumY, -move.amount);\n    }\n    if (skewbInternalQuantumZ.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, move.amount);\n    }\n    if (skewbInternalQuantumZPrime.isIdentical(move.quantum)) {\n      return new Move(skewbExternalQuantumZ, -move.amount);\n    }\n    return null;\n    /*\n       *   See (1) above.\n       *\n    if (move.family === \"Rv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"x\", move.amount);\n    } else if (move.family === \"Uv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"y\", move.amount);\n    } else if (move.family === \"Fv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"z\", move.amount);\n       */\n    // } else {\n    //   return null;\n    // }\n  }\n}\n","import { parsePuzzleDescription, PuzzleDescription } from \"./PuzzleGeometry\";\n\nexport function parseOptions(argv: string[]): {\n  puzzleDescription: PuzzleDescription | null;\n  options: PuzzleGeometryOptions;\n} {\n  let argp = 0;\n  const options: PuzzleGeometryOptions = {};\n  while (argp < argv.length && argv[argp][0] === \"-\") {\n    const option = argv[argp++];\n    if (option === \"--rotations\") {\n      options.addRotations = true;\n    } else if (option === \"--allmoves\") {\n      options.allMoves = true;\n    } else if (option === \"--outerblockmoves\") {\n      options.outerBlockMoves = true;\n    } else if (option === \"--vertexmoves\") {\n      options.vertexMoves = true;\n    } else if (option === \"--nocorners\") {\n      options.includeCornerOrbits = false;\n    } else if (option === \"--noedges\") {\n      options.includeEdgeOrbits = false;\n    } else if (option === \"--noorientation\") {\n      options.fixedOrientation = true;\n    } else if (option === \"--nocenters\") {\n      options.includeCenterOrbits = false;\n    } else if (option === \"--omit\") {\n      options.excludeOrbits = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--moves\") {\n      options.moveList = argv[argp].split(\",\");\n      argp++;\n    } else if (option === \"--optimize\") {\n      options.optimizeOrbits = true;\n    } else if (option === \"--scramble\") {\n      options.scrambleAmount = 100;\n    } else if (option === \"--fixcorner\") {\n      options.fixedPieceType = \"v\";\n    } else if (option === \"--fixedge\") {\n      options.fixedPieceType = \"e\";\n    } else if (option === \"--fixcenter\") {\n      options.fixedPieceType = \"f\";\n    } else if (option === \"--orientcenters\") {\n      options.orientCenters = true;\n    } else if (option === \"--puzzleorientation\") {\n      options.puzzleOrientation = JSON.parse(argv[argp]); // TODO: Validate input.\n      argp++;\n    } else {\n      throw new Error(\"Bad option: \" + option);\n    }\n  }\n  const puzzleDescription = parsePuzzleDescription(argv.slice(argp).join(\" \"));\n  return { puzzleDescription, options };\n}\n\ntype FaceName = string;\ntype OrientationDirection = [number, number, number];\nexport type FaceBasedOrientationDescription = [\n  [FaceName, OrientationDirection],\n  [FaceName, OrientationDirection],\n];\nexport type BaseFaceCount = 4 | 6 | 8 | 12 | 20;\nexport type FaceBasedOrientationDescriptionLookup = Record<\n  BaseFaceCount,\n  FaceBasedOrientationDescription\n>;\n\nfunction asstructured(v: any): any {\n  if (typeof v === \"string\") {\n    return JSON.parse(v);\n  }\n  return v;\n}\nfunction asboolean(v: any): boolean {\n  if (typeof v === \"string\") {\n    if (v === \"false\") {\n      return false;\n    }\n    return true;\n  } else {\n    return v ? true : false;\n  }\n}\n\nexport class PuzzleGeometryFullOptions {\n  verbosity: number = 0; // verbosity (console.log)\n\n  allMoves: boolean = false; // generate all slice moves in ksolve\n  outerBlockMoves: boolean; // generate outer block moves\n  vertexMoves: boolean = false; // generate vertex moves\n  addRotations: boolean = false; // add symmetry information to ksolve output\n  moveList: string[] | null = null; // move list to generate\n\n  fixedOrientation: boolean = false; // eliminate any orientations\n  fixedPieceType: null | \"e\" | \"v\" | \"f\" = null; // fix a piece?\n  orientCenters: boolean = false; // orient centers?\n\n  // TODO: Group these into a single object?\n  includeCornerOrbits: boolean = true; // include corner orbits\n  includeCenterOrbits: boolean = true; // include center orbits\n  includeEdgeOrbits: boolean = true; // include edge orbits\n  // Overrides the previous options.\n  excludeOrbits: string[] = []; // exclude these orbits\n  optimizeOrbits: boolean = false; // optimize PermOri\n\n  grayCorners: boolean = false; // make corner sets gray\n  grayCenters: boolean = false; // make center sets gray\n  grayEdges: boolean = false; // make edge sets gray\n\n  puzzleOrientation: FaceBasedOrientationDescription | null = null; // single puzzle orientation from options\n  puzzleOrientations: FaceBasedOrientationDescriptionLookup | null = null; // puzzle orientation override object from options // TODO: is this needed?\n\n  scrambleAmount: number = 0; // scramble?\n\n  constructor(options: PuzzleGeometryOptions = {}) {\n    Object.assign(this, options);\n  }\n}\n\nexport type PuzzleGeometryOptions = Partial<PuzzleGeometryFullOptions>;\n\nexport function parsePGOptionList(optionlist?: any[]): PuzzleGeometryOptions {\n  const options: PuzzleGeometryOptions = {};\n  if (optionlist !== undefined) {\n    if (optionlist.length % 2 !== 0) {\n      throw new Error(\"Odd length in option list?\");\n    }\n    for (let i = 0; i < optionlist.length; i += 2) {\n      if (optionlist[i] === \"verbose\") {\n        options.verbosity = (options.verbosity ?? 0) + 1;\n      } else if (optionlist[i] === \"quiet\") {\n        options.verbosity = 0;\n      } else if (optionlist[i] === \"allmoves\") {\n        options.allMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"outerblockmoves\") {\n        options.outerBlockMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"vertexmoves\") {\n        options.vertexMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"rotations\") {\n        options.addRotations = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"cornersets\") {\n        options.includeCornerOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"centersets\") {\n        options.includeCenterOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"edgesets\") {\n        options.includeEdgeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"omit\") {\n        options.excludeOrbits = optionlist[i + 1];\n      } else if (optionlist[i] === \"graycorners\") {\n        options.grayCorners = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"graycenters\") {\n        options.grayCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"grayedges\") {\n        options.grayEdges = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"movelist\") {\n        options.moveList = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"killorientation\") {\n        options.fixedOrientation = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"optimize\") {\n        options.optimizeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"scramble\") {\n        options.scrambleAmount = optionlist[i + 1];\n      } else if (optionlist[i] === \"fix\") {\n        options.fixedPieceType = optionlist[i + 1];\n      } else if (optionlist[i] === \"orientcenters\") {\n        options.orientCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientation\") {\n        options.puzzleOrientation = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientations\") {\n        options.puzzleOrientations = asstructured(optionlist[i + 1]);\n      } else {\n        throw new Error(\n          \"Bad option while processing option list \" + optionlist[i],\n        );\n      }\n    }\n  }\n  return options;\n}\n","const zeroCache: number[][] = [];\nconst iotaCache: number[][] = [];\n\nexport function zeros(n: number): number[] {\n  if (!zeroCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = 0;\n    }\n    zeroCache[n] = c;\n  }\n  return zeroCache[n];\n}\n\nexport function iota(n: number): number[] {\n  if (!iotaCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = i;\n    }\n    iotaCache[n] = c;\n  }\n  return iotaCache[n];\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm {\n  // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): number {\n  let r = 1;\n  while (a > 1) {\n    r *= a;\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return (a / gcd(a, b)) * b;\n}\n\nexport class Perm {\n  public n: number; // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n\n  public toString(): string {\n    // stringify\n    return \"Perm[\" + this.p.join(\" \") + \"]\";\n  }\n\n  public mul(p2: Perm): Perm {\n    // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public rmul(p2: Perm): Perm {\n    // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n\n  public compareTo(p2: Perm): number {\n    // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n\n  public toGap(): string {\n    const cyc = new Array<string>();\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array<number>();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(\"(\" + incyc.join(\",\") + \")\");\n    }\n    return cyc.join(\"\");\n  }\n\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n","import { Move } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\"; // TODO\nimport { NullMapper } from \"./notation-mapping\";\nimport type { NotationMapper } from \"./notation-mapping/NotationMapper\";\n/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ import {\n  factorial,\n  iota,\n  lcm,\n  Perm,\n  zeros,\n} from \"./Perm\";\nexport class PGOrbitDef {\n  constructor(public size: number, public mod: number) {}\n  public reassemblySize(): number {\n    return factorial(this.size) * Math.pow(this.mod, this.size);\n  }\n}\n\nlet lastGlobalDefinitionCounter = 0;\n\nexport function externalName(\n  mapper: NotationMapper,\n  moveString: string,\n): string {\n  const mv = Move.fromString(moveString);\n  const mv2 = mapper.notationToExternal(mv);\n  if (mv2 === null || mv === mv2) {\n    return moveString;\n  }\n  return mv2.toString();\n}\n\nexport class PGOrbitsDef {\n  constructor(\n    public orbitnames: string[],\n    private orbitdefs: PGOrbitDef[],\n    public solved: VisibleState,\n    public movenames: string[],\n    public moveops: PGTransform[],\n  ) {}\n\n  public transformToKTransformationData(t: PGTransform): KTransformationData {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < this.orbitnames.length; j++) {\n      mp[this.orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n\n  public static transformToKTransformationData(\n    orbitnames: string[],\n    t: PGTransform,\n  ): KTransformationData {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < orbitnames.length; j++) {\n      mp[orbitnames[j]] = t.orbits[j].toKPuzzle();\n    }\n    return mp;\n  }\n\n  public toKsolve(\n    name: string,\n    mapper: NotationMapper = new NullMapper(),\n  ): string[] {\n    const result = [];\n    result.push(\"Name \" + name);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\n        `Set ${this.orbitnames[i]} ${this.orbitdefs[i].size} ${this.orbitdefs[i].mod}`,\n      );\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      this.solved.orbits[i].appendDefinition(\n        result,\n        this.orbitnames[i],\n        false,\n        false,\n      );\n    }\n    result.push(\"End\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"\");\n      let name = externalName(mapper, this.movenames[i]);\n      let doinv = false;\n      if (name[name.length - 1] === \"'\") {\n        doinv = true;\n        name = name.substring(0, name.length - 1);\n      }\n      result.push(\"Move \" + name);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (doinv) {\n          this.moveops[i].orbits[j]\n            .inv()\n            .appendDefinition(result, this.orbitnames[j], true);\n        } else {\n          this.moveops[i].orbits[j].appendDefinition(\n            result,\n            this.orbitnames[j],\n            true,\n          );\n        }\n      }\n      result.push(\"End\");\n    }\n    // extra blank line on end lets us use join(\"\\n\") to terminate all\n    return result;\n  }\n\n  // TODO: return type.\n  public toKPuzzleDefinition(includemoves: boolean): KPuzzleDefinition {\n    const orbits: KPuzzleDefinition[\"orbits\"] = {};\n    const start: KPuzzleDefinition[\"startStateData\"] = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits[this.orbitnames[i]] = {\n        numPieces: this.orbitdefs[i].size,\n        numOrientations: this.orbitdefs[i].mod,\n      };\n      const startTransformation = this.solved.orbits[i].toKPuzzle();\n      start[this.orbitnames[i]] = {\n        pieces: startTransformation.permutation,\n        orientation: startTransformation.orientation,\n      };\n    }\n    const moves: { [moveName: string]: any } = {};\n    if (includemoves) {\n      for (let i = 0; i < this.movenames.length; i++) {\n        moves[this.movenames[i]] = this.transformToKTransformationData(\n          this.moveops[i],\n        );\n      }\n    }\n    return {\n      name: `PG3D #${++lastGlobalDefinitionCounter}`,\n      orbits,\n      startStateData: start,\n      moves,\n    };\n  }\n\n  public optimize(): PGOrbitsDef {\n    const neworbitnames: string[] = [];\n    const neworbitdefs: PGOrbitDef[] = [];\n    const newsolved: PGOrbit[] = [];\n    const newmoveops: PGOrbit[][] = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array<boolean>(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      for (let j = 0; j < this.moveops.length; j++) {\n        for (let k = 0; k < n; k++) {\n          if (\n            this.moveops[j].orbits[i].perm[k] !== k ||\n            this.moveops[j].orbits[i].ori[k] !== 0\n          ) {\n            changed[k] = true;\n            du.union(k, this.moveops[j].orbits[i].perm[k]);\n          }\n        }\n      }\n      let keepori = true;\n      // right now we kill ori only if solved is unique and\n      // if we can kill it completely.  This is not all the optimization\n      // we can perform.\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (\n              this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0\n            ) {\n              for (let o = 0; o < om; o++) {\n                duo.union(\n                  k * om + o,\n                  this.moveops[j].orbits[i].perm[k] * om +\n                    ((o + this.moveops[j].orbits[i].ori[k]) % om),\n                );\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (\n              this.solved.orbits[i].perm[j] === this.solved.orbits[i].perm[k]\n            ) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      // is there just one result set, or more than one?\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no: number[] = [];\n        const on: number[] = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(`${this.orbitnames[i]}_p${j}`);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new PGOrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new PGOrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(\n              this.moveops[k].orbits[i].remap(no, on, nv).killOri(),\n            );\n          }\n        }\n      }\n    }\n    return new PGOrbitsDef(\n      neworbitnames,\n      neworbitdefs,\n      new VisibleState(newsolved),\n      this.movenames,\n      newmoveops.map((_) => new PGTransform(_)),\n    );\n  }\n\n  // replace the solved state with a new scrambled state.\n  public scramble(n: number): void {\n    this.solved = this.solved.mul(this.getScrambleTransformation(n));\n  }\n\n  // generate a new \"random\" position based on an entropy pool\n  // this should be significantly faster and more random than just\n  // doing a large number of random moves, especially on big puzzles.\n  public getScrambleTransformation(n: number): PGTransform {\n    // don't let n be too tiny\n    if (n < 100) {\n      n = 100;\n    }\n    const pool: PGTransform[] = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) {\n        // break up parity\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    return s;\n  }\n\n  public reassemblySize(): number {\n    let n = 1;\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n}\n\nexport class PGOrbit {\n  private static kcache: Record<string, number[]>[] = [];\n\n  public static e(n: number, mod: number): PGOrbit {\n    return new PGOrbit(iota(n), zeros(n), mod);\n  }\n\n  constructor(\n    public perm: number[],\n    public ori: number[],\n    public orimod: number,\n  ) {}\n\n  public mul(b: PGOrbit): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    if (this.orimod === 1) {\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n      }\n      return new PGOrbit(newPerm, this.ori, this.orimod);\n    } else {\n      const newOri = new Array<number>(n);\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n        newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n      }\n      return new PGOrbit(newPerm, newOri, this.orimod);\n    }\n  }\n\n  public inv(): PGOrbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public equal(b: PGOrbit): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // in-place mutator\n  public killOri(): this {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + ((this.ori[i] + j) % o);\n      }\n    }\n    return new Perm(newPerm);\n  }\n\n  // returns tuple of sets of identical pieces in this orbit\n  public identicalPieces(): number[][] {\n    const done: boolean[] = [];\n    const n = this.perm.length;\n    const r: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === undefined) {\n        const s: number[] = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n\n  public order(): number {\n    // can be made more efficient\n    return this.toPerm().order();\n  }\n\n  public isIdentity(): boolean {\n    const n = this.perm.length;\n    if (this.perm === iota(n) && this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private zeroOris(): boolean {\n    const n = this.perm.length;\n    if (this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public remap(no: number[], on: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public remapVS(no: number[], nv: number): PGOrbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === undefined) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new PGOrbit(newPerm, newOri, this.orimod);\n  }\n\n  public appendDefinition(\n    result: string[],\n    name: string,\n    useVS: boolean,\n    concise: boolean = true,\n  ): void {\n    if (concise && this.isIdentity()) {\n      return;\n    }\n    result.push(name);\n    result.push(this.perm.map((_: number) => _ + 1).join(\" \"));\n    if (!this.zeroOris()) {\n      if (useVS) {\n        const newori = new Array<number>(this.ori.length);\n        for (let i = 0; i < newori.length; i++) {\n          newori[this.perm[i]] = this.ori[i];\n        }\n        result.push(newori.join(\" \"));\n      } else {\n        result.push(this.ori.join(\" \"));\n      }\n    }\n  }\n\n  // TODO: return type\n  public toKPuzzle(): Record<string, number[]> {\n    const n = this.perm.length;\n    if (this.isIdentity()) {\n      if (!PGOrbit.kcache[n]) {\n        PGOrbit.kcache[n] = { permutation: iota(n), orientation: zeros(n) };\n      }\n      return PGOrbit.kcache[n];\n    } else {\n      return { permutation: this.perm, orientation: this.ori };\n    }\n  }\n}\nexport class PGTransformBase {\n  constructor(public orbits: PGOrbit[]) {}\n  public internalMul(b: PGTransformBase): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n\n  protected internalInv(): PGOrbit[] {\n    const newOrbits: PGOrbit[] = [];\n    for (const orbit of this.orbits) {\n      newOrbits.push(orbit.inv());\n    }\n    return newOrbits;\n  }\n\n  public equal(b: PGTransformBase): boolean {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  protected killOri(): this {\n    for (const orbit of this.orbits) {\n      orbit.killOri();\n    }\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const perms = new Array<Perm>();\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const p = orbit.toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array<number>(n);\n    n = 0;\n    for (const p of perms) {\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n\n  public identicalPieces(): number[][] {\n    const r: number[][] = [];\n    let n = 0;\n    for (const orbit of this.orbits) {\n      const o = orbit.orimod;\n      const s = orbit.identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * orbit.perm.length;\n    }\n    return r;\n  }\n\n  public order(): number {\n    let r = 1;\n    for (const orbit of this.orbits) {\n      r = lcm(r, orbit.order());\n    }\n    return r;\n  }\n}\nexport class PGTransform extends PGTransformBase {\n  constructor(orbits: PGOrbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: PGTransform): PGTransform {\n    return new PGTransform(this.internalMul(b));\n  }\n\n  public mulScalar(n: number): PGTransform {\n    if (n === 0) {\n      return this.e();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let t: PGTransform = this;\n    if (n < 0) {\n      t = t.inv();\n      n = -n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n\n  public inv(): PGTransform {\n    return new PGTransform(this.internalInv());\n  }\n\n  public e(): PGTransform {\n    return new PGTransform(\n      this.orbits.map((_: PGOrbit) => PGOrbit.e(_.perm.length, _.orimod)),\n    );\n  }\n}\nexport class VisibleState extends PGTransformBase {\n  constructor(orbits: PGOrbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: PGTransform): VisibleState {\n    return new VisibleState(this.internalMul(b));\n  }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n  private heads: number[];\n  constructor(public n: number) {\n    this.heads = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n\n  public find(v: number): number {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n\n  public union(a: number, b: number): void {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n}\nexport function showcanon(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (\n          ((st >> mv) & 1) === 0 &&\n          (st & commutes[mv] & ((1 << mv) - 1)) === 0\n        ) {\n          const nst = (st & commutes[mv]) | (1 << mv);\n          if (nextlev[nst] === undefined) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(`${d}: canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g: PGOrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  disp(\"0: canonseq 1\");\n  for (let x = 0; x < orders.length; x++) {\n    curlev[x] = orders[x] - 1;\n  }\n  for (let d = 1; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (mv === st || (commutes[mv] & (1 << st) && mv < st)) {\n          continue;\n        }\n        if (nextlev[mv] === undefined) {\n          nextlev[mv] = 0;\n        }\n        nextlev[mv] += (orders[mv] - 1) * cnt;\n      }\n    }\n    disp(`${d}\": canonseq ${sum} states ${uniq}`);\n    curlev = nextlev;\n  }\n}\n","export type PuzzleDescriptionString = string;\n\nexport const PGPuzzles: { [name: string]: PuzzleDescriptionString } = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\":\n    \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\":\n    \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\":\n    \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\":\n    \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\":\n    \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"40x40x40\":\n    \"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95\",\n  \"skewb\": \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  \"helicopter\": \"c e 0.707106781186547\",\n  \"curvy copter\": \"c e 0.83\",\n  \"dino\": \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  \"pyramorphix\": \"t e 0\",\n  \"mastermorphix\": \"t e 0.346184634065199\",\n  \"pyraminx\": \"t v 0.333333333333333 v 1.66666666666667\",\n  \"tetraminx\": \"t v 0.333333333333333\",\n  \"master pyraminx\": \"t v 0 v 1 v 2\",\n  \"master tetraminx\": \"t v 0 v 1\",\n  \"professor pyraminx\": \"t v -0.2 v 0.6 v 1.4 v 2.2\",\n  \"professor tetraminx\": \"t v -0.2 v 0.6 v 1.4\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master pyramorphix\": \"t e 0.866025403784437\",\n  \"megaminx\": \"d f 0.7\",\n  \"gigaminx\": \"d f 0.64 f 0.82\",\n  \"teraminx\": \"d f 0.64 f 0.76 f 0.88\",\n  \"petaminx\": \"d f 0.64 f 0.73 f 0.82 f 0.91\",\n  \"examinx\": \"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928\",\n  \"zetaminx\": \"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94\",\n  \"yottaminx\": \"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486\",\n  \"pentultimate\": \"d f 0\",\n  \"master pentultimate\": \"d f 0.1\",\n  \"elite pentultimate\": \"d f 0 f 0.145905\",\n  // exact value for starminx is sqrt(5(5-2 sqrt(5))/3)\n  \"starminx\": \"d v 0.937962370425399\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  \"chopasaurus\": \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  \"FTO\": \"o f 0.333333333333333\",\n  \"master FTO\": \"o f 0.5 f 0\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  \"octastar\": \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  \"icosamate\": \"i v 0\",\n  \"icosahedron 2\": \"i v 0.18759247376021\",\n  \"icosahedron 3\": \"i v 0.18759247376021 e 0\",\n  \"icosahedron static faces\": \"i v 0.84\",\n  \"icosahedron moving faces\": \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.937962370425399\",\n};\n\nexport type PuzzleName = keyof typeof PGPuzzles;\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function solvethreeplanes(\n  p1: number,\n  p2: number,\n  p3: number,\n  planes: Quat[],\n): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if (\n        (planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)\n      ) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class Quat {\n  constructor(\n    public a: number,\n    public b: number,\n    public c: number,\n    public d: number,\n  ) {}\n\n  public mul(q: Quat): Quat {\n    // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a,\n    );\n  }\n\n  public toString(): string {\n    return `Q[${this.a},${this.b},${this.c},${this.d}]`;\n  }\n\n  public dist(q: Quat): number {\n    // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public len(): number {\n    // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n\n  public cross(q: Quat): Quat {\n    // cross product\n    return new Quat(\n      0,\n      this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d,\n      this.b * q.c - this.c * q.b,\n    );\n  }\n\n  public dot(q: Quat): number {\n    // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n\n  public normalize(): Quat {\n    // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public makenormal(): Quat {\n    // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n\n  public normalizeplane(): Quat {\n    // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public smul(m: number): Quat {\n    // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n\n  public sum(q: Quat): Quat {\n    // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n\n  public sub(q: Quat): Quat {\n    // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public angle(): number {\n    // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n\n  public invrot(): Quat {\n    // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n\n  public det3x3(\n    a00: number,\n    a01: number,\n    a02: number,\n    a10: number,\n    a11: number,\n    a12: number,\n    a20: number,\n    a21: number,\n    a22: number,\n  ): number {\n    // 3x3 determinant\n    return (\n      a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20)\n    );\n  }\n\n  public rotateplane(q: Quat): Quat {\n    // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n\n  // return any vector orthogonal to the given one.  Find the smallest\n  // component (in absolute value) and return the cross product of that\n  // axis with the given vector.\n  public orthogonal(): Quat {\n    const ab = Math.abs(this.b);\n    const ac = Math.abs(this.c);\n    const ad = Math.abs(this.d);\n    if (ab < ac && ab < ad) {\n      return this.cross(new Quat(0, 1, 0, 0)).normalize();\n    } else if (ac < ab && ac < ad) {\n      return this.cross(new Quat(0, 0, 1, 0)).normalize();\n    } else {\n      return this.cross(new Quat(0, 0, 0, 1)).normalize();\n    }\n  }\n\n  // return the Quaternion that will rotate the this vector\n  // to the b vector through rotatepoint.\n  public pointrotation(b: Quat): Quat {\n    const a = this.normalize();\n    b = b.normalize();\n    if (a.sub(b).len() < eps) {\n      return new Quat(1, 0, 0, 0);\n    }\n    let h = a.sum(b);\n    if (h.len() < eps) {\n      h = h.orthogonal();\n    } else {\n      h = h.normalize();\n    }\n    const r = a.cross(h);\n    r.a = a.dot(h);\n    return r;\n  }\n\n  // given two vectors, return the portion of the first that\n  // is not in the direction of the second.\n  public unproject(b: Quat): Quat {\n    return this.sum(b.smul(-this.dot(b) / (this.len() * b.len())));\n  }\n\n  public rotatepoint(q: Quat): Quat {\n    // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n\n  public rotateface(face: Quat[]): Quat[] {\n    // rotate a face by this Q.\n    return face.map((_: Quat) => _.rotatepoint(this));\n  }\n\n  public intersect3(p2: Quat, p3: Quat): Quat | false {\n    // intersect three planes if there is one\n    const det = this.det3x3(\n      this.b,\n      this.c,\n      this.d,\n      p2.b,\n      p2.c,\n      p2.d,\n      p3.b,\n      p3.c,\n      p3.d,\n    );\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(\n      0,\n      this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) /\n        det,\n      this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) /\n        det,\n      this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) /\n        det,\n    );\n  }\n\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * Cuts a face by this plane, or returns null if there\n   * is no intersection.\n   * @param face The face to cut.\n   */\n  public cutface(face: Quat[]): Quat[][] | null {\n    const d = this.a;\n    let seen = 0;\n    let r = null;\n    for (let i = 0; i < face.length; i++) {\n      seen |= 1 << (this.side(face[i].dot(this) - d) + 1);\n    }\n    if ((seen & 5) === 5) {\n      r = [];\n      // saw both sides\n      const inout = face.map((_: Quat) => this.side(_.dot(this) - d));\n      for (let s = -1; s <= 1; s += 2) {\n        const nface = [];\n        for (let k = 0; k < face.length; k++) {\n          if (inout[k] === s || inout[k] === 0) {\n            nface.push(face[k]);\n          }\n          const kk = (k + 1) % face.length;\n          if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n            const vk = face[k].dot(this) - d;\n            const vkk = face[kk].dot(this) - d;\n            const r = vk / (vk - vkk);\n            const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n            nface.push(pt);\n          }\n        }\n        r.push(nface);\n      }\n    }\n    return r;\n  }\n\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const t = this.cutface(face);\n      if (t) {\n        nfaces.push(t[0]);\n        nfaces.push(t[1]);\n      } else {\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n\n  public faceside(face: Quat[]): number {\n    // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n\n  public sameplane(p: Quat): boolean {\n    // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n\n  public makecut(r: number): Quat {\n    // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n","/* tslint:disable prefer-for-of */ // TODO\n\nimport { Quat, solvethreeplanes } from \"./Quat\";\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function cube(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\n\nexport function tetrahedron(): Quat[] {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\n\nexport function dodecahedron(): Quat[] {\n  const d36 = (2 * Math.PI) / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [\n    new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n    new Quat(0.5, 0.5, 0.5, 0.5),\n  ];\n}\n\nexport function icosahedron(): Quat[] {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = (2 * Math.PI) / 6;\n  return [\n    new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n    new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0),\n  ];\n}\n\nexport function octahedron(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\n\nexport function closure(g: Quat[]): Quat[] {\n  // compute the closure of a set of generators\n  // This is quadratic in the result size.  Also, it has no protection\n  // against you providing a bogus set of generators that would generate\n  // an infinite group.\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps || negns.dist(q[k]) < eps) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\n\nexport function uniqueplanes(p: Quat, g: Quat[]): Quat[] {\n  // compute unique plane rotations\n  // given a rotation group and a plane, find the rotations that\n  // generate unique planes.  This is quadratic in the return size.\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\n\nexport function getface(planes: Quat[]): Quat[] {\n  // compute a face given a set of planes\n  // The face returned will be a set of points that lie in the first plane\n  // in the given array, that are on the surface of the polytope defined\n  // by all the planes, and will be returned in clockwise order.\n  // This is O(planes^2 * return size + return_size^2).\n  const face: Quat[] = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  for (;;) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j: number = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t: Quat = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n","import { identity, Perm } from \"./Perm\";\n\nclass FactoredNumber {\n  public mult: number[];\n  constructor() {\n    this.mult = [];\n  }\n\n  public multiply(n: number): void {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (undefined !== this.mult[f]) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (undefined !== this.mult[n]) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n\n  public toString(): string {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (undefined !== this.mult[i]) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += `^${this.mult[i]}`;\n        }\n      }\n    }\n    return r;\n  }\n}\n\nexport function schreierSims(g: Perm[], disp: (s: string) => void): number {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs: Perm[][] = [];\n  let sgsi: Perm[][] = [];\n  let sgslen: number[][] = [];\n  let Tk: Perm[][] = [];\n  let Tklen: number[][] = [];\n  function resolve(p: Perm): boolean {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k: number, p: Perm, len: number): void {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k: number, p: Perm, len: number): void {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs(): number {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = 1;\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = 1;\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= cnt;\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(\n        `${i}: sz ${sz} T ${tks} sol ${sollen} none ${none} mults ${mults.toString()}`,\n      );\n    }\n    return sz;\n  }\n  return getsgs();\n}\n","import { Move, QuantumMove } from \"../alg\";\nimport type { KPuzzleDefinition, KTransformationData } from \"../kpuzzle\";\nimport { FaceNameSwizzler } from \"./FaceNameSwizzler\";\nimport {\n  FaceRenamingMapper,\n  FTONotationMapper,\n  MegaminxScramblingNotationMapper,\n  NotationMapper,\n  NullMapper,\n  NxNxNCubeMapper,\n  PyraminxNotationMapper,\n  SkewbNotationMapper,\n  TetraminxNotationMapper,\n} from \"./notation-mapping\";\nimport {\n  BaseFaceCount,\n  FaceBasedOrientationDescription,\n  FaceBasedOrientationDescriptionLookup,\n  PuzzleGeometryFullOptions,\n  PuzzleGeometryOptions,\n} from \"./Options\";\nimport { iota, Perm, zeros } from \"./Perm\";\nimport {\n  externalName,\n  PGOrbit,\n  PGOrbitDef,\n  PGOrbitsDef,\n  PGTransform,\n  showcanon,\n  VisibleState,\n} from \"./PermOriSet\";\nimport { PGPuzzles, PuzzleDescriptionString, PuzzleName } from \"./PGPuzzles\";\nimport {\n  closure,\n  cube,\n  dodecahedron,\n  getface,\n  icosahedron,\n  octahedron,\n  tetrahedron,\n  uniqueplanes,\n} from \"./PlatonicGenerator\";\nimport { centermassface, Quat } from \"./Quat\";\nimport { schreierSims } from \"./SchreierSims\";\n\nexport interface TextureMapper {\n  getuv(fn: number, threed: number[]): number[];\n}\n\nexport interface StickerDatSticker {\n  coords: number[];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n  face: number;\n  isDup?: boolean;\n}\n\nexport interface StickerDatFace {\n  coords: number[];\n  name: string;\n}\n\nexport type StickerDatAxis = {\n  coordinates: number[];\n  quantumMove: Move;\n  order: number;\n};\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n  unswizzle(mv: Move): string;\n  notationMapper: NotationMapper;\n  textureMapper: TextureMapper;\n}\n\n// you can fill these in to help with timing if you want\nfunction tstart(s: string): string {\n  return s;\n}\n\nfunction tend(_: string): void {}\n\nclass Face {\n  private coords: number[];\n  public length: number;\n  constructor(q: Quat[]) {\n    this.coords = new Array(q.length * 3);\n    for (let i = 0; i < q.length; i++) {\n      this.coords[3 * i] = q[i].b;\n      this.coords[3 * i + 1] = q[i].c;\n      this.coords[3 * i + 2] = q[i].d;\n    }\n    this.length = q.length;\n  }\n\n  get(off: number): Quat {\n    return new Quat(\n      0,\n      this.coords[3 * off],\n      this.coords[3 * off + 1],\n      this.coords[3 * off + 2],\n    );\n  }\n\n  centermass(): Quat {\n    let sx = 0;\n    let sy = 0;\n    let sz = 0;\n    for (let i = 0; i < this.length; i++) {\n      sx += this.coords[3 * i];\n      sy += this.coords[3 * i + 1];\n      sz += this.coords[3 * i + 2];\n    }\n    return new Quat(0, sx / this.length, sy / this.length, sz / this.length);\n  }\n\n  rotate(q: Quat): Face {\n    const a = [];\n    for (let i = 0; i < this.length; i++) {\n      a.push(this.get(i).rotatepoint(q));\n    }\n    return new Face(a);\n  }\n\n  rotateforward(): Face {\n    const a = [];\n    for (let i = 1; i < this.length; i++) {\n      a.push(this.get(i));\n    }\n    a.push(this.get(0));\n    return new Face(a);\n  }\n}\n\nexport class FaceTree {\n  constructor(\n    private face: Quat[],\n    private left?: FaceTree,\n    private right?: FaceTree,\n  ) {}\n\n  public split(q: Quat): FaceTree {\n    const t = q.cutface(this.face);\n    if (t !== null) {\n      if (this.left === undefined) {\n        this.left = new FaceTree(t[0]);\n        this.right = new FaceTree(t[1]);\n      } else {\n        this.left = this.left?.split(q);\n        this.right = this.right?.split(q);\n      }\n    }\n    return this;\n  }\n\n  public collect(arr: Face[], leftfirst: boolean): Face[] {\n    if (this.left === undefined) {\n      arr.push(new Face(this.face));\n    } else if (leftfirst) {\n      this.left?.collect(arr, false);\n      this.right?.collect(arr, true);\n    } else {\n      this.right?.collect(arr, false);\n      this.left?.collect(arr, true);\n    }\n    return arr;\n  }\n}\n\nexport function expandfaces(rots: Quat[], faces: Face[]): Face[] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (const rot of rots) {\n    for (const face of faces) {\n      nfaces.push(face.rotate(rot));\n    }\n  }\n  return nfaces;\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\nconst permissivieMoveParsing = false;\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\n// TODO: change this back to a const JSON definition.\nfunction defaultnets(): any {\n  return {\n    // four faces: tetrahedron\n    4: [[\"F\", \"D\", \"L\", \"R\"]],\n    // six faces: cube\n    6: [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n    // eight faces: octahedron\n    8: [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"],\n    ],\n    // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    12: [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n    ],\n    // twenty faces: icosahedron\n    20: [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n  };\n}\n\n// TODO: change this back to a const JSON definition.\nfunction defaultcolors(): any {\n  return {\n    // the colors should use the same naming convention as the nets, above.\n    4: { F: \"#00ff00\", D: \"#ffff00\", L: \"#ff0000\", R: \"#0000ff\" },\n    6: {\n      U: \"#ffffff\",\n      F: \"#00ff00\",\n      R: \"#ff0000\",\n      D: \"#ffff00\",\n      B: \"#0000ff\",\n      L: \"#ff8000\",\n    },\n    8: {\n      U: \"#ffffff\",\n      F: \"#ff0000\",\n      R: \"#00bb00\",\n      D: \"#ffff00\",\n      BB: \"#1122ff\",\n      L: \"#9524c5\",\n      BL: \"#ff8800\",\n      BR: \"#aaaaaa\",\n    },\n    12: {\n      U: \"#ffffff\",\n      F: \"#006633\",\n      R: \"#ff0000\",\n      C: \"#ffffd0\",\n      A: \"#3399ff\",\n      L: \"#660099\",\n      E: \"#ff66cc\",\n      BF: \"#99ff00\",\n      BR: \"#0000ff\",\n      BL: \"#ffff00\",\n      I: \"#ff6633\",\n      D: \"#999999\",\n    },\n    20: {\n      R: \"#db69f0\",\n      C: \"#178fde\",\n      F: \"#23238b\",\n      E: \"#9cc726\",\n      L: \"#2c212d\",\n      U: \"#177fa7\",\n      A: \"#e0de7f\",\n      G: \"#2b57c0\",\n      I: \"#41126b\",\n      S: \"#4b8c28\",\n      H: \"#7c098d\",\n      J: \"#7fe7b4\",\n      B: \"#85fb74\",\n      K: \"#3f4bc3\",\n      D: \"#0ff555\",\n      M: \"#f1c2c8\",\n      O: \"#58d340\",\n      P: \"#c514f2\",\n      N: \"#14494e\",\n      Q: \"#8b1be1\",\n    },\n  };\n}\n\n// the default precedence of the faces is given here.  This permits\n// the orientations to be reasonably predictable.  There are tradeoffs;\n// some face precedence orders do better things to the edge orientations\n// than the corner orientations and some are the opposite.\n// TODO: change this back to a const JSON definition.\nfunction defaultfaceorders(): any {\n  return {\n    4: [\"F\", \"D\", \"L\", \"R\"],\n    6: [\"U\", \"D\", \"F\", \"B\", \"L\", \"R\"],\n    8: [\"F\", \"BB\", \"D\", \"U\", \"BR\", \"L\", \"R\", \"BL\"],\n    12: [\"L\", \"E\", \"F\", \"BF\", \"R\", \"I\", \"U\", \"D\", \"BR\", \"A\", \"BL\", \"C\"],\n    20: [\n      \"L\",\n      \"S\",\n      \"E\",\n      \"O\",\n      \"F\",\n      \"B\",\n      \"I\",\n      \"P\",\n      \"R\",\n      \"K\",\n      \"U\",\n      \"D\",\n      \"J\",\n      \"A\",\n      \"Q\",\n      \"H\",\n      \"G\",\n      \"N\",\n      \"M\",\n      \"C\",\n    ],\n  };\n}\n\n/*\n *  Default orientations for the puzzles in 3D space.  Can be overridden\n *  by puzzleOrientation or puzzleOrientations options.\n *\n *  These are defined to have a strong intuitive vertical (y) direction\n *  since 3D orbital controls need this.  In comments, we list the\n *  preferred initial camera orientation for each puzzle for twizzle;\n *  this information is explicitly given in the twizzle app file.\n */\n// TODO: change this back to a const JSON definition.\nfunction defaultOrientations(): FaceBasedOrientationDescriptionLookup {\n  return {\n    4: [\n      [\"FLR\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLR towards viewer\n    6: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // URF towards viewer\n    8: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // FLUR towards viewer\n    12: [\n      [\"U\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // F towards viewer\n    20: [\n      [\"GUQMJ\", [0, 1, 0]],\n      [\"F\", [0, 0, 1]],\n    ], // F towards viewer\n  };\n}\n\nfunction findelement(a: Quat[][], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\n\nexport function getPG3DNamedPuzzles(): {\n  [s: string]: PuzzleDescriptionString;\n} {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles;\n}\n\nexport function getPuzzleDescriptionString(\n  puzzleName: PuzzleName,\n): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles[puzzleName];\n}\n\nexport type CutDescription = { cutType: string; distance: number };\nexport type PuzzleDescription = {\n  shape: string;\n  cuts: CutDescription[];\n};\n\nexport function parsePuzzleDescription(\n  s: PuzzleDescriptionString,\n): PuzzleDescription | null {\n  // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return null;\n  }\n  const shape = a[0];\n  if (\n    shape !== \"o\" &&\n    shape !== \"c\" &&\n    shape !== \"i\" &&\n    shape !== \"d\" &&\n    shape !== \"t\"\n  ) {\n    return null;\n  }\n  const cuts: CutDescription[] = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return null;\n    }\n    cuts.push({ cutType: a[i], distance: parseFloat(a[i + 1]) });\n  }\n  return { shape, cuts };\n}\n\nexport function getPuzzleGeometryByDesc(\n  desc: string,\n  options: PuzzleGeometryOptions = {},\n): PuzzleGeometry {\n  const parsed = parsePuzzleDescription(desc);\n  if (parsed === null) {\n    throw new Error(\"Could not parse the puzzle description\");\n  }\n  const pg = new PuzzleGeometry(\n    parsed,\n    Object.assign({}, { allMoves: true } as PuzzleGeometryOptions, options),\n  );\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(\n  puzzleName: PuzzleName,\n  options?: PuzzleGeometryOptions,\n): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(PGPuzzles[puzzleName], options);\n}\n\nfunction getmovename(\n  geo: any,\n  bits: number[],\n  slices: number,\n): [string, boolean] {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let inverted = false;\n  if (slices - bits[1] < bits[0]) {\n    // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = [slices - bits[1], slices - bits[0]];\n    inverted = true;\n  }\n  let movenameFamily = geo[0] as string;\n  let movenamePrefix = \"\";\n  if (bits[0] === 0 && bits[1] === slices) {\n    movenameFamily = movenameFamily + \"v\";\n  } else if (bits[0] === bits[1]) {\n    if (bits[1] > 0) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else if (bits[0] === 0) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (bits[1] > 1) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else {\n    throw `We only support slice and outer block moves right now. ${bits}`;\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  Do greedy match.\n// Permit underscores between names.\nfunction splitByFaceNames(s: string, facenames: [Quat[], string][]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    if (at > 0 && at < s.length && s[at] === \"_\") {\n      at++;\n    }\n    let currentMatch = \"\";\n    for (const facename of facenames) {\n      if (\n        s.substr(at).startsWith(facename[1]) &&\n        facename[1].length > currentMatch.length\n      ) {\n        currentMatch = facename[1];\n      }\n    }\n    if (currentMatch !== \"\") {\n      r.push(currentMatch);\n      at += currentMatch.length;\n    } else {\n      throw new Error(\"Could not split \" + s + \" into face names.\");\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Face, maxdist: number): number[] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    const pt = toCoords(q.get(n - i - 1), maxdist);\n    r[3 * i] = pt[0];\n    r[3 * i + 1] = pt[1];\n    r[3 * i + 2] = pt[2];\n  }\n  return r;\n}\n\nexport class PuzzleGeometry {\n  private rotations: Quat[]; // all members of the rotation group\n  public baseplanerot: Quat[]; // unique rotations of the baseplane\n  private baseplanes: Quat[]; // planes, corresponding to faces\n  private facenames: [Quat[], string][]; // face names\n  private faceplanes: [Quat, string][]; // face planes\n  private edgenames: [Quat, string][]; // edge names\n  private vertexnames: [Quat, string][]; // vertexnames\n  private geonormals: [Quat, string, string][]; // all geometric directions, with names and types\n  private moveplanes: Quat[]; // the planes that split moves\n  private moveplanes2: Quat[]; // the planes that split moves, filtered\n  public moveplanesets: Quat[][]; // the move planes, in parallel sets\n  private moveplanenormals: Quat[]; // one move plane\n  public movesetorders: number[]; // the order of rotations for each move set\n  public movesetgeos: [string, string, string, string, number][]; // geometric feature information for move sets\n  private basefaces: Face[]; // polytope faces before cuts\n  private faces: Face[]; // all the stickers\n  private facecentermass: Quat[]; // center of mass of all faces\n  private baseFaceCount: BaseFaceCount; // number of base faces\n  public stickersperface: number; // number of stickers per face\n  public shortedge: number; // number of stickers per face\n  public cubies: number[][]; // the cubies\n  private vertexdistance: number; // vertex distance\n  private edgedistance: number; // edge distance\n  private facetocubie: number[]; // map a face to a cubie index\n  private facetoord: number[]; // map a face to a cubie ord\n  private moverotations: Quat[][]; // move rotations\n  private facelisthash: Map<string, number[]>; // face list by key\n  private cubiesetnames: string[]; // cubie set names\n  private cubieords: number[]; // the size of each orbit\n  private cubiesetnums: number[];\n  private cubieordnums: number[];\n  private orbitoris: number[]; // the orientation size of each orbit\n  private cubievaluemap: number[]; // the map for identical cubies\n  private cubiesetcubies: number[][]; // cubies in each cubie set\n  public cmovesbyslice: number[][][] = []; // cmoves as perms by slice\n  public parsedmovelist: [\n    string | undefined,\n    number,\n    number,\n    number,\n    boolean,\n    number,\n  ][]; // parsed move list\n\n  private duplicatedFaces: number[] = []; // which faces are duplicated\n  private duplicatedCubies: number[] = []; // which cubies are duplicated\n  private fixedCubie: number = -1; // fixed cubie, if any\n  private net: string[][] = [];\n  private colors: any = [];\n  private faceorder: string[] = [];\n  private faceprecedence: number[] = [];\n  private swizzler: FaceNameSwizzler;\n  public notationMapper: NotationMapper = new NullMapper();\n  private addNotationMapper: string = \"\";\n  private setReidOrder: boolean = false;\n\n  private options: PuzzleGeometryFullOptions;\n\n  constructor(\n    private puzzleDescription: PuzzleDescription,\n    options: PuzzleGeometryOptions,\n  ) {\n    const t1 = tstart(\"genperms\");\n    this.options = new PuzzleGeometryFullOptions(options);\n    if (this.options.verbosity > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(puzzleDescription);\n    tend(t1);\n  }\n\n  public create(puzzleDescription: PuzzleDescription): void {\n    const { shape, cuts } = puzzleDescription;\n\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    this.moveplanes = [];\n    this.moveplanes2 = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\":\n        g = cube();\n        break;\n      case \"o\":\n        g = octahedron();\n        break;\n      case \"i\":\n        g = icosahedron();\n        break;\n      case \"t\":\n        g = tetrahedron();\n        break;\n      case \"d\":\n        g = dodecahedron();\n        break;\n      default:\n        throw new Error(\"Bad shape argument: \" + shape);\n    }\n    this.rotations = closure(g);\n    if (this.options.verbosity) {\n      console.log(\"# Rotations: \" + this.rotations.length);\n    }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.baseFaceCount = baseplanes.length as BaseFaceCount;\n    const net = defaultnets()[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors()[baseplanes.length];\n    this.faceorder = defaultfaceorders()[baseplanes.length];\n    if (this.options.verbosity > 0) {\n      console.log(\"# Base planes: \" + baseplanes.length);\n    }\n    const baseface = getface(baseplanes);\n    const zero = new Quat(0, 0, 0, 0);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Face vertices: \" + baseface.length);\n    }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Boundary is \" + boundary);\n    }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    const firstface = getface(planes);\n    this.edgedistance = firstface[0].sum(firstface[1]).smul(0.5).dist(zero);\n    this.vertexdistance = firstface[0].dist(zero);\n    const cutplanes = [];\n    const intersects = [];\n    let sawface = false; // what cuts did we see?\n    let sawedge = false;\n    let sawvertex = false;\n    for (const cut of cuts) {\n      let normal = null;\n      let distance = 0;\n      switch (cut.cutType) {\n        case \"f\":\n          normal = facenormal;\n          distance = 1;\n          sawface = true;\n          break;\n        case \"v\":\n          normal = vertexnormal;\n          distance = this.vertexdistance;\n          sawvertex = true;\n          break;\n        case \"e\":\n          normal = edgenormal;\n          distance = this.edgedistance;\n          sawedge = true;\n          break;\n        default:\n          throw new Error(\"Bad cut argument: \" + cut.cutType);\n      }\n      cutplanes.push(normal.makecut(cut.distance));\n      intersects.push(cut.distance < distance);\n    }\n    if (this.options.addRotations) {\n      if (!sawface) {\n        cutplanes.push(facenormal.makecut(10));\n      }\n      if (!sawvertex) {\n        cutplanes.push(vertexnormal.makecut(10));\n      }\n      if (!sawedge) {\n        cutplanes.push(edgenormal.makecut(10));\n      }\n    }\n    this.basefaces = [];\n    for (const baseplanerot of this.baseplanerot) {\n      const face = baseplanerot.rotateface(firstface);\n      this.basefaces.push(new Face(face));\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n where\n    //   n planes meet at a vertex.  We arbitrarily choose the one that is\n    //   alphabetically first (and we will probably want to change this).\n    //\n    const facenames: [Quat[], string][] = [];\n    const faceplanes: [Quat, string][] = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = firstface.length;\n    function searchaddelement(a: any[], p: Quat, name: any): void {\n      for (const el of a) {\n        if (el[0].dist(p) < eps) {\n          el.push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: string[] = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (const neti of net) {\n      const f0 = neti[0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === neti[1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < neti.length; j++) {\n        if (neti[j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== neti[j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = neti[j];\n        facenametoindex[neti[j]] = of;\n      }\n    }\n    for (let i = 0; i < faceindextoname.length; i++) {\n      let found = false;\n      for (let j = 0; j < this.faceorder.length; j++) {\n        if (faceindextoname[i] === this.faceorder[j]) {\n          this.faceprecedence[i] = j;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw new Error(\n          \"Could not find face \" +\n            faceindextoname[i] +\n            \" in face order list \" +\n            this.faceorder,\n        );\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(firstface);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    this.swizzler = new FaceNameSwizzler(facenames.map((_) => _[1]));\n    const sep = this.swizzler.prefixFree ? \"\" : \"_\";\n    // fix the edge names; use face precedence order\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(\"Bad length in edge names \" + edgenames[i]);\n      }\n      let c1 = faceindextoname[edgenames[i][1]];\n      const c2 = faceindextoname[edgenames[i][2]];\n      if (\n        this.faceprecedence[edgenames[i][1]] <\n        this.faceprecedence[edgenames[i][2]]\n      ) {\n        c1 = c1 + sep + c2;\n      } else {\n        c1 = c2 + sep + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; counterclockwise rotations; low face first.\n    for (let i = 0; i < vertexnames.length; i++) {\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      let st = 1;\n      for (let j = 2; j < vertexnames[i].length; j++) {\n        if (\n          this.faceprecedence[facenametoindex[vertexnames[i][j][0]]] <\n          this.faceprecedence[facenametoindex[vertexnames[i][st][0]]]\n        ) {\n          st = j;\n        }\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (j === 1) {\n          r = vertexnames[i][st][0];\n        } else {\n          r = r + sep + vertexnames[i][st][0];\n        }\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][1] === vertexnames[i][k][2]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    if (this.options.verbosity > 1) {\n      console.log(\"# Face precedence list: \" + this.faceorder.join(\" \"));\n      console.log(\"# Face names: \" + facenames.map((_) => _[1]).join(\" \"));\n      // TODO\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      console.log(\"# Edge names: \" + edgenames.map((_) => _[1]).join(\" \"));\n      // TODO\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      console.log(\"# Vertex names: \" + vertexnames.map((_) => _[1]).join(\" \"));\n    }\n    const geonormals: [Quat, string, string][] = [];\n    for (const faceplane of faceplanes) {\n      geonormals.push([faceplane[0].makenormal(), faceplane[1], \"f\"]);\n    }\n    for (const edgename of edgenames) {\n      geonormals.push([edgename[0].makenormal(), edgename[1], \"e\"]);\n    }\n    for (const vertexname of vertexnames) {\n      geonormals.push([vertexname[0].makenormal(), vertexname[1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const geonormalnames = geonormals.map((_) => _[1]);\n    this.swizzler.setGripNames(geonormalnames);\n    if (this.options.verbosity > 0) {\n      console.log(\n        \"# Distances: face \" +\n          1 +\n          \" edge \" +\n          this.edgedistance +\n          \" vertex \" +\n          this.vertexdistance,\n      );\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (const rotation of this.rotations) {\n        const q = cutplanes[c].rotateplane(rotation);\n        let wasseen = false;\n        for (const moveplane of this.moveplanes) {\n          if (q.sameplane(moveplane)) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          if (intersects[c]) {\n            this.moveplanes2.push(q);\n          }\n        }\n      }\n    }\n    let ft = new FaceTree(firstface);\n    const tar = this.moveplanes2.slice();\n    // we want to use Math.random() here but we can't, because when\n    // we call multiple times we'll get different orbits/layouts.\n    // to resolve this, we use a very simple linear congruential\n    // generator.  for our purposes, the numbers don't need to be\n    // very random.\n    let rval = 31;\n    for (let i = 0; i < tar.length; i++) {\n      const j = i + Math.floor((tar.length - i) * (rval / 65536.0));\n      ft = ft.split(tar[j]);\n      tar[j] = tar[i];\n      rval = (rval * 1657 + 101) % 65536;\n    }\n    const faces = ft.collect([], true);\n    this.faces = faces;\n    if (this.options.verbosity > 0) {\n      console.log(\"# Faces is now \" + faces.length);\n    }\n    this.stickersperface = faces.length;\n    // the faces when rotated don't preserve the vertex order at this\n    // point.  to improve 3d rendering speed, we would like to preserve\n    // vertex order on rotation.  First, let's see what rotations preserve\n    // the base face; these are the ones we want to work with.\n    const simplerot: Quat[] = [];\n    const cm = centermassface(firstface);\n    for (const rotation of this.rotations) {\n      const f = rotation.rotateface(firstface);\n      if (cm.dist(centermassface(f)) < eps) {\n        simplerot.push(rotation);\n      }\n    }\n    const finished = new Array<boolean>(faces.length);\n    const sortme: [number, Quat, number][] = [];\n    for (let i = 0; i < faces.length; i++) {\n      const cm2 = faces[i].centermass();\n      sortme.push([cm.dist(cm2), cm2, i]);\n    }\n    sortme.sort((a, b) => a[0] - b[0]);\n    for (let ii = 0; ii < faces.length; ii++) {\n      const i = sortme[ii][2];\n      if (!finished[i]) {\n        finished[i] = true;\n        for (const rot of simplerot) {\n          const f2 = faces[i].rotate(rot);\n          const cm = f2.centermass();\n          for (let kk = ii + 1; kk < faces.length; kk++) {\n            if (sortme[kk][0] - sortme[ii][0] > eps) {\n              break;\n            }\n            const k = sortme[kk][2];\n            if (!finished[k] && cm.dist(sortme[kk][1]) < eps) {\n              finished[k] = true;\n              faces[k] = f2;\n              break;\n            }\n          }\n        }\n      }\n    }\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    this.shortedge = 1e99;\n    for (const face of faces) {\n      for (let j = 0; j < face.length; j++) {\n        const k = (j + 1) % face.length;\n        const t = face.get(j).dist(face.get(k));\n        if (t < this.shortedge) {\n          this.shortedge = t;\n        }\n      }\n    }\n    if (this.options.verbosity > 0) {\n      console.log(\"# Short edge is \" + this.shortedge);\n    }\n    // add nxnxn cube notation if it has cube face moves\n    if (shape === \"c\" && sawface && !sawedge && !sawvertex) {\n      // In this case the mapper adding is deferred until we\n      // know the number of slices.\n      this.addNotationMapper = \"NxNxNCubeMapper\";\n      // try to set Reid order of the cubies within an orbit\n      this.setReidOrder = true;\n    }\n    if (shape === \"c\" && sawvertex && !sawface && !sawedge) {\n      this.addNotationMapper = \"SkewbMapper\";\n    }\n    if (shape === \"t\" && (sawvertex || sawface) && !sawedge) {\n      this.addNotationMapper = \"PyraminxOrTetraminxMapper\";\n    }\n    if (shape === \"o\" && sawface) {\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\"F\", \"D\", \"L\", \"BL\", \"R\", \"U\", \"BR\", \"B\"]),\n      );\n      if (!sawedge && !sawvertex) {\n        this.addNotationMapper = \"FTOMapper\";\n      }\n    }\n    if (shape === \"d\" && sawface) {\n      this.addNotationMapper = \"MegaminxMapper\";\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\n          \"U\",\n          \"F\",\n          \"L\",\n          \"BL\",\n          \"BR\",\n          \"R\",\n          \"FR\",\n          \"FL\",\n          \"DL\",\n          \"B\",\n          \"DR\",\n          \"D\",\n        ]),\n      );\n    }\n  }\n\n  private keyface(face: Face): string {\n    return this.keyface2(face.centermass());\n  }\n\n  private keyface2(cm: Quat): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    const sfcc = String.fromCharCode;\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        if (t < 47) {\n          s = s + sfcc(33 + t);\n        } else if (t < 47 + 47 * 47) {\n          s = s + sfcc(33 + 47 + Math.floor(t / 47) - 1) + sfcc(33 + (t % 47));\n        } else if (t < 47 + 47 * 47 + 47 * 47 * 47) {\n          s =\n            s +\n            sfcc(33 + 47 + Math.floor((t - 47) / (47 * 47) - 1)) +\n            sfcc(33 + 47 + (Math.floor((t - 47) / 47) % 47)) +\n            sfcc(33 + (t % 47));\n        } else {\n          throw Error(\"Too many slices for cubie encoding\");\n        }\n      }\n    }\n    return s;\n  }\n\n  // same as above, but instead of returning an encoded string, return\n  // an array with offsets.\n  private keyface3(face: Face): number[] {\n    const cm = face.centermass();\n    // take a face and figure out the sides of each move plane\n    const r = [];\n    for (const moveplaneset of this.moveplanesets) {\n      if (moveplaneset.length > 0) {\n        const dv = cm.dot(moveplaneset[0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= moveplaneset.length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (t + b <= moveplaneset.length && dv > moveplaneset[t + b - 1].a) {\n            t += b;\n          }\n        }\n        r.push(t);\n      }\n    }\n    return r;\n  }\n\n  private findface(cm: Quat): number {\n    const key = this.keyface2(cm);\n    const arr = this.facelisthash.get(key)!;\n    if (arr.length === 1) {\n      return arr[0];\n    }\n    for (let i = 0; i + 1 < arr.length; i++) {\n      const face2 = this.facelisthash.get(key)![i];\n      if (Math.abs(cm.dist(this.facecentermass[face2])) < eps) {\n        return face2;\n      }\n    }\n    return arr[arr.length - 1];\n  }\n\n  private project2d(\n    facen: number,\n    edgen: number,\n    targvec: Quat[],\n  ): [Quat, Quat, Quat] {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(\n      0,\n      targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]),\n      0,\n    );\n    return [x1, y1, off];\n  }\n\n  public allstickers(): void {\n    const t1 = tstart(\"allstickers\");\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Total stickers is now \" + this.faces.length);\n    }\n    this.facecentermass = new Array(this.faces.length);\n    for (let i = 0; i < this.faces.length; i++) {\n      this.facecentermass[i] = this.faces[i].centermass();\n    }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets: Quat[][] = [];\n    const moveplanenormals: Quat[] = [];\n    // get the normals, first, from unfiltered moveplanes.\n    for (const q of this.moveplanes) {\n      const qnormal = q.makenormal();\n      let wasseen = false;\n      for (const moveplanenormal of moveplanenormals) {\n        if (qnormal.sameplane(moveplanenormal.makenormal())) {\n          wasseen = true;\n        }\n      }\n      if (!wasseen) {\n        moveplanenormals.push(qnormal);\n        moveplanesets.push([]);\n      }\n    }\n    for (const q of this.moveplanes2) {\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moveplanesets[j].push(q);\n          break;\n        }\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = moveplanenormals[i];\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    this.moveplanenormals = moveplanenormals;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.options.verbosity > 0) {\n      console.log(\"# Move plane sets: \" + sizes);\n    }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (const q of this.rotations) {\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanenormals[i]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos: [string, string, string, string, number][] = [];\n    let gtype = \"?\";\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanenormals[i];\n      let neg = null;\n      let pos = null;\n      for (const geonormal of this.geonormals) {\n        const d = p0.dot(geonormal[0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [geonormal[1], geonormal[2]];\n          gtype = geonormal[2];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([\n        pos[0],\n        pos[1],\n        neg[0],\n        neg[1],\n        1 + moveplanesets[i].length,\n      ]);\n      if (this.addNotationMapper === \"NxNxNCubeMapper\" && gtype === \"f\") {\n        this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i].length);\n        this.addNotationMapper = \"\";\n      }\n      if (\n        this.addNotationMapper === \"SkewbMapper\" &&\n        moveplanesets[0].length === 1\n      ) {\n        this.notationMapper = new SkewbNotationMapper(this.swizzler);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"PyraminxOrTetraminxMapper\") {\n        if (\n          moveplanesets[0].length === 2 &&\n          moveplanesets[0][0].a === 0.333333333333333 &&\n          moveplanesets[0][1].a === 1.66666666666667\n        ) {\n          this.notationMapper = new PyraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        } else {\n          this.notationMapper = new TetraminxNotationMapper(this.swizzler);\n          this.addNotationMapper = \"\";\n        }\n      }\n      if (this.addNotationMapper === \"MegaminxMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new MegaminxScramblingNotationMapper(\n            this.notationMapper,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"FTOMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new FTONotationMapper(\n            this.notationMapper,\n            this.swizzler,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const facelisthash = new Map();\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!facelisthash.get(s)) {\n        facelisthash.set(s, [i]);\n      } else {\n        const arr = facelisthash.get(s)!;\n        arr.push(i);\n        //  If we find a core cubie, split it up into multiple cubies,\n        //  because ksolve doesn't handle orientations that are not\n        //  cyclic, and the rotation group of the core is not cyclic.\n        if (arr.length === this.baseFaceCount) {\n          if (this.options.verbosity > 0) {\n            console.log(\"# Splitting core.\");\n          }\n          for (let suff = 0; suff < arr.length; suff++) {\n            const s2 = s + \" \" + suff;\n            facelisthash.set(s2, [arr[suff]]);\n          }\n        }\n      }\n    }\n    this.facelisthash = facelisthash;\n    if (this.options.verbosity > 0) {\n      console.log(\"# Cubies: \" + facelisthash.size);\n    }\n    const cubies: number[][] = [];\n    const facetocubie = [];\n    const facetoord = [];\n    for (const facelist of facelisthash.values()) {\n      if (facelist.length === this.baseFaceCount) {\n        // this is the original \"cubie\" of a split core; we ignore it.\n        continue;\n      }\n      //  Sort the faces around each corner so they are counterclockwise.  Only\n      //  relevant for cubies that actually are corners (three or more\n      //  faces).  In general cubies might have many faces; for icosohedrons\n      //  there are five faces on the corner cubies.\n      if (facelist.length > 1) {\n        const cm = facelist.map((_: number) => faces[_].centermass());\n        const cmall = centermassface(cm);\n        for (let looplimit = 0; facelist.length > 2; looplimit++) {\n          let changed = false;\n          for (let i = 0; i < facelist.length; i++) {\n            const j = (i + 1) % facelist.length;\n            // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n            if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n              const u = cm[i];\n              cm[i] = cm[j];\n              cm[j] = u;\n              const v = facelist[i];\n              facelist[i] = facelist[j];\n              facelist[j] = v;\n              changed = true;\n            }\n          }\n          if (!changed) {\n            break;\n          }\n          if (looplimit > 1000) {\n            throw new Error(\"Bad epsilon math; too close to border\");\n          }\n        }\n        let mini = 0;\n        let minf = facelist[mini];\n        for (let i = 1; i < facelist.length; i++) {\n          const temp = facelist[i];\n          if (\n            this.faceprecedence[this.getfaceindex(temp)] <\n            this.faceprecedence[this.getfaceindex(minf)]\n          ) {\n            mini = i;\n            minf = temp;\n          }\n        }\n        if (mini !== 0) {\n          const ofacelist = facelist.slice();\n          for (let i = 0; i < facelist.length; i++) {\n            facelist[i] = ofacelist[(mini + i) % facelist.length];\n          }\n        }\n      }\n      for (let j = 0; j < facelist.length; j++) {\n        const k = facelist[j];\n        facetocubie[k] = cubies.length;\n        facetoord[k] = j;\n      }\n      cubies.push(facelist);\n    }\n    this.cubies = cubies;\n    this.facetocubie = facetocubie;\n    this.facetoord = facetoord;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTERS\", \"EDGES\", \"CORNERS\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    const getcolorkey = (cubienum: number): string => {\n      return cubies[cubienum].map((_) => this.getfaceindex(_)).join(\" \");\n    };\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      if (seen[i]) {\n        continue;\n      }\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.baseFaceCount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : typectr + 1);\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        if (queue.length < this.rotations.length) {\n          const cm = this.facecentermass[cubies[cind][0]];\n          for (const moverotation of moverotations) {\n            const tq =\n              this.facetocubie[this.findface(cm.rotatepoint(moverotation[0]))];\n            if (!seen[tq]) {\n              queue.push(tq);\n              seen[tq] = true;\n            }\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    if (\n      this.setReidOrder &&\n      4 <= this.stickersperface &&\n      this.stickersperface <= 9\n    ) {\n      const reidorder = [\n        [\n          \"UF\",\n          \"UR\",\n          \"UB\",\n          \"UL\",\n          \"DF\",\n          \"DR\",\n          \"DB\",\n          \"DL\",\n          \"FR\",\n          \"FL\",\n          \"BR\",\n          \"BL\",\n        ],\n        [\"UFR\", \"URB\", \"UBL\", \"ULF\", \"DRF\", \"DFL\", \"DLB\", \"DBR\"],\n        [\"U\", \"L\", \"F\", \"R\", \"B\", \"D\"],\n      ];\n      const reidmap: { [key: number]: number } = {};\n      for (const cubie of reidorder) {\n        for (let j = 0; j < cubie.length; j++) {\n          let mask = 0;\n          for (let k = 0; k < cubie[j].length; k++) {\n            mask |= 1 << (cubie[j].charCodeAt(k) - 65);\n          }\n          reidmap[mask] = j;\n        }\n      }\n      for (const cubieset of cubiesetcubies) {\n        for (const cubienum of cubieset) {\n          let mask = 0;\n          for (const cubie of cubies[cubienum]) {\n            mask |=\n              1 <<\n              (this.facenames[this.getfaceindex(cubie)][1].charCodeAt(0) - 65);\n          }\n          cubieordnums[cubienum] = reidmap[mask];\n        }\n      }\n    }\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.options.fixedPieceType !== null) {\n      for (let i = 0; i < cubies.length; i++) {\n        if (\n          (this.options.fixedPieceType === \"v\" && cubies[i].length > 2) ||\n          (this.options.fixedPieceType === \"e\" && cubies[i].length === 2) ||\n          (this.options.fixedPieceType === \"f\" && cubies[i].length === 1)\n        ) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\n          \"Could not find a cubie of type \" +\n            this.options.fixedPieceType +\n            \" to fix.\",\n        );\n      }\n    }\n    // show the orbits\n    if (this.options.verbosity > 0) {\n      console.log(\"# Cubie orbit sizes \" + cubieords);\n    }\n    tend(t1);\n  }\n\n  public unswizzle(mv: Move): string {\n    const newmv = this.notationMapper.notationToInternal(mv);\n    if (newmv === null) {\n      return \"\";\n    }\n    return this.swizzler.unswizzle(newmv.family);\n  }\n\n  // We use an extremely permissive parse here; any character but\n  // digits are allowed in a family name.\n  private stringToBlockMove(mv: string): Move {\n    // parse a move from the command line\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(\"Bad move passed \" + mv);\n    }\n    const grip = p[4];\n    let loslice = undefined;\n    let hislice = undefined;\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      hislice = parseInt(p[3], 10);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = \"-\" + amountstr.substring(1);\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    return new Move(new QuantumMove(grip, hislice, loslice), amount);\n  }\n\n  public parseMove(\n    move: Move,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const bm = this.notationMapper.notationToInternal(move); // pluggable notation\n    if (bm === null) {\n      throw new Error(\"Bad move \" + move.family);\n    }\n    move = bm;\n    let grip = move.family;\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (move.innerLayer !== undefined || move.outerLayer !== undefined) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    if (grip.endsWith(\"w\") && grip[0] <= \"Z\") {\n      grip = grip.slice(0, -1).toLowerCase();\n    }\n    let geo;\n    let msi = -1;\n    const geoname = this.swizzler.unswizzle(grip);\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (geoname === g[0]) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (geoname === g[2]) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (grip.toUpperCase() !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw new Error(\"Bad grip in move \" + move.family);\n    }\n    if (move.outerLayer !== undefined) {\n      loslice = move.outerLayer;\n    }\n    if (move.innerLayer !== undefined) {\n      if (move.outerLayer === undefined) {\n        hislice = move.innerLayer;\n        // big assumption here!  if outerlayer not specified, but inner\n        // layer is (like 2U), we use the case of the family (upper vs\n        // lower) to decide if it should be a slice turn or a wide turn.\n        if (grip <= \"Z\") {\n          // uppercase; slice move\n          loslice = hislice;\n        } else {\n          // lowercase; wide move\n          loslice = 1;\n        }\n      } else {\n        hislice = move.innerLayer;\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (\n      loslice < 0 ||\n      loslice > this.moveplanesets[msi].length ||\n      hislice < 0 ||\n      hislice > this.moveplanesets[msi].length\n    ) {\n      throw new Error(\n        \"Bad slice spec \" +\n          loslice +\n          \" \" +\n          hislice +\n          \" vs \" +\n          this.moveplanesets[msi].length,\n      );\n    }\n    if (\n      !permissivieMoveParsing &&\n      loslice === 0 &&\n      hislice === this.moveplanesets[msi].length &&\n      !fullrotation\n    ) {\n      throw new Error(\n        \"! full puzzle rotations must be specified with v suffix.\",\n      );\n    }\n    return [undefined, msi, loslice, hislice, firstgrip, move.amount];\n  }\n\n  private parsemove(\n    mv: string,\n  ): [string | undefined, number, number, number, boolean, number] {\n    const r = this.parseMove(this.stringToBlockMove(mv));\n    r[0] = mv;\n    return r;\n  }\n\n  public genperms(): void {\n    const t1 = tstart(\"genperms\");\n    // generate permutations for moves\n    if (this.cmovesbyslice.length > 0) {\n      // did this already?\n      return;\n    }\n    const cmovesbyslice = [];\n    // if orientCenters is set, we find all cubies that have only one\n    // sticker and that sticker is in the center of a face, and we\n    // introduce duplicate stickers so we can orient them properly.\n    if (this.options.orientCenters) {\n      for (let k = 0; k < this.cubies.length; k++) {\n        if (this.cubies[k].length === 1) {\n          const kk = this.cubies[k][0];\n          const i = this.getfaceindex(kk);\n          if (\n            this.basefaces[i].centermass().dist(this.facecentermass[kk]) < eps\n          ) {\n            const o = this.basefaces[i].length;\n            for (let m = 1; m < o; m++) {\n              this.cubies[k].push(this.cubies[k][m - 1]);\n            }\n            this.duplicatedFaces[kk] = o;\n            this.duplicatedCubies[k] = o;\n            this.orbitoris[this.cubiesetnums[k]] = o;\n          }\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [moveplaneset.length + 1, 0];\n      let bhi = 1;\n      while (bhi * 2 <= moveplaneset.length) {\n        bhi *= 2;\n      }\n      for (let i = 0; i < this.faces.length; i++) {\n        let t = 0;\n        if (moveplaneset.length > 0) {\n          const dv = this.facecentermass[i].dot(moveplaneset[0]);\n          for (let b = bhi; b > 0; b >>= 1) {\n            if (\n              t + b <= moveplaneset.length &&\n              dv > moveplaneset[t + b - 1].a\n            ) {\n              t += b;\n            }\n          }\n          t = moveplaneset.length - t;\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axiscmoves = new Array(slicecnts.length);\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        axiscmoves[sc] = [];\n      }\n      const cubiedone = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        if (slicenum[i] < 0) {\n          continue;\n        }\n        const b = [this.facetocubie[i], this.facetoord[i]];\n        let cm = this.facecentermass[i];\n        const ocm = cm;\n        let fi2 = i;\n        const sc = slicenum[fi2];\n        for (;;) {\n          slicenum[fi2] = -1;\n          const cm2 = cm.rotatepoint(this.moverotations[k][0]);\n          if (cm2.dist(ocm) < eps) {\n            break;\n          }\n          fi2 = this.findface(cm2);\n          b.push(this.facetocubie[fi2], this.facetoord[fi2]);\n          cm = cm2;\n        }\n        // If an oriented center is moving, we need to figure out\n        // the appropriate new orientation.  Normally we use the cubie\n        // sticker identity to locate, but this doesn't work here.\n        // Instead we need to redo the geometry of the sticker itself\n        // rotating and figure out how that maps to the destination\n        // sticker.\n        //\n        // We only need to do this for central center stickers: those\n        // where the face vertex goes through the center.  The others\n        // don't actually need orientation because they can only be\n        // in one orientation by physical constraints.  (You can't spin\n        // a point or cross sticker on the 5x5x5, for example.)\n        //\n        // This also simplifies things because it means the actual\n        // remapping has the same order as the moves themselves.\n        //\n        // The center may or may not have been duplicated at this point.\n        //\n        // The move moving the center might not be the same modulo as the\n        // center itself.\n        if (\n          b.length > 2 &&\n          this.options.orientCenters &&\n          (this.cubies[b[0]].length === 1 || this.duplicatedCubies[b[0]] > 1)\n        ) {\n          // is this a real center cubie, around an axis?\n          if (\n            this.facecentermass[i].dist(\n              this.basefaces[this.getfaceindex(i)].centermass(),\n            ) < eps\n          ) {\n            // how does remapping of the face/point set map to the original?\n            let face1 = this.faces[this.cubies[b[0]][0]];\n            for (let ii = 0; ii < b.length; ii += 2) {\n              const face0 = this.faces[this.cubies[b[ii]][0]];\n              let o = -1;\n              for (let jj = 0; jj < face1.length; jj++) {\n                if (face0.get(jj).dist(face1.get(0)) < eps) {\n                  o = jj;\n                  break;\n                }\n              }\n              if (o < 0) {\n                throw new Error(\n                  \"Couldn't find rotation of center faces; ignoring for now.\",\n                );\n              } else {\n                b[ii + 1] = o;\n                face1 = face1.rotate(this.moverotations[k][0]);\n              }\n            }\n          }\n        }\n        // b.length == 2 means a sticker is spinning in place.\n        // in this case we add duplicate stickers\n        // so that we can make it animate properly in a 3D world.\n        if (b.length === 2 && this.options.orientCenters) {\n          for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n            if (sc === 0) {\n              b.push(b[0], ii);\n            } else {\n              b.push(\n                b[0],\n                (this.movesetorders[k] - ii) % this.movesetorders[k],\n              );\n            }\n          }\n        }\n        if (b.length > 2 && !cubiedone[b[0]]) {\n          if (b.length !== 2 * this.movesetorders[k]) {\n            throw new Error(\"Bad length in perm gen\");\n          }\n          for (const v of b) {\n            axiscmoves[sc].push(v);\n          }\n        }\n        for (let j = 0; j < b.length; j += 2) {\n          cubiedone[b[j]] = true;\n        }\n      }\n      for (let kk = 0; kk < axiscmoves.length; kk++) {\n        axiscmoves[kk] = axiscmoves[kk].slice();\n      }\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.options.moveList) {\n      const parsedmovelist: [\n        string | undefined,\n        number,\n        number,\n        number,\n        boolean,\n        number,\n      ][] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (const moveString of this.options.moveList) {\n        parsedmovelist.push(this.parsemove(moveString));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n    this.facelisthash.clear();\n    this.facecentermass = [];\n    tend(t1);\n  }\n\n  private getboundarygeometry(): any {\n    // get the boundary geometry\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals,\n    };\n  }\n\n  private getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.moveplanesets[k].length;\n    let r: any[] = [];\n    if (this.parsedmovelist !== undefined) {\n      for (const parsedmove of this.parsedmovelist) {\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push([parsedmove[2], parsedmove[3]]);\n        } else {\n          r.push([slices - parsedmove[3], slices - parsedmove[2]]);\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.options.vertexMoves && !this.options.allMoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.options.outerBlockMoves) {\n              r.push([i + 1, slices]);\n            } else {\n              r.push([i + 1]);\n            }\n            r.push(1);\n          } else {\n            if (this.options.outerBlockMoves) {\n              r.push([0, i]);\n            } else {\n              r.push([i, i]);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.options.allMoves && i + i === slices) {\n          continue;\n        }\n        if (this.options.outerBlockMoves) {\n          if (i + i > slices) {\n            r.push([i, slices]);\n          } else {\n            r.push([0, i]);\n          }\n        } else {\n          r.push([i, i]);\n        }\n        r.push(1);\n      }\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (dep >= o[0] && dep <= o[1]) {\n          if (o[0] === 0) {\n            o = [o[1] + 1, slices];\n          } else if (slices === o[1]) {\n            o = [0, o[0] - 1];\n          } else {\n            throw Error(\"fixed cubie option would disconnect move\");\n          }\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (\n            newr[j][0] === o[0] &&\n            newr[j][1] === o[1] &&\n            newr[j + 1] === r[i + 1]\n          ) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    // TODO\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return r;\n  }\n\n  private graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 &&\n        (this.options.grayCenters || !this.options.includeCenterOrbits)) ||\n      (ori === 2 &&\n        (this.options.grayEdges || !this.options.includeEdgeOrbits)) ||\n      (ori > 2 &&\n        (this.options.grayCorners || !this.options.includeCornerOrbits))\n    );\n  }\n\n  private skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && !this.options.includeCenterOrbits) ||\n      (ori === 2 && !this.options.includeEdgeOrbits) ||\n      (ori > 2 && !this.options.includeCornerOrbits)\n    );\n  }\n\n  private skipcubie(fi: number): boolean {\n    return this.skipbyori(fi);\n  }\n\n  private header(comment: string): string {\n    return comment + copyright + \"\\n\" + comment + \"\\n\";\n  }\n\n  public writegap(): string {\n    // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      let movename = \"M_\" + externalName(this.notationMapper, os.movenames[i]);\n      let doinv = false;\n      if (movename[movename.length - 1] === \"'\") {\n        movename = movename.substring(0, movename.length - 1);\n        doinv = true;\n      }\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      if (doinv) {\n        r.push(movename + \":=\" + os.moveops[i].toPerm().inv().toGap() + \";\");\n      } else {\n        r.push(movename + \":=\" + os.moveops[i].toPerm().toGap() + \";\");\n      }\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\n      \"ip:=[\" +\n        ip.map((_) => \"[\" + _.map((__) => __ + 1).join(\",\") + \"]\").join(\",\") +\n        \"];\",\n    );\n    r.push(\"# Size(Group(Gen));\");\n    r.push(\"# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));\");\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writeksolve(name: string = \"PuzzleGeometryPuzzle\"): string {\n    const od = this.getOrbitsDef(false);\n    return (\n      this.header(\"# \") + od.toKsolve(name, this.notationMapper).join(\"\\n\")\n    );\n  }\n\n  public getKPuzzleDefinition(\n    fortwisty: boolean = true,\n    includemoves: boolean = true,\n  ): KPuzzleDefinition {\n    const od = this.getOrbitsDef(fortwisty, includemoves);\n    const internalDefinition = od.toKPuzzleDefinition(includemoves);\n    (internalDefinition as any).experimentalPuzzleDescription =\n      this.puzzleDescription;\n    if (!internalDefinition) {\n      throw new Error(\"Missing definition!\");\n    }\n    return internalDefinition;\n  }\n\n  public getMoveFromBits(\n    moverange: number[],\n    amount: number,\n    inverted: boolean,\n    axiscmoves: number[][],\n    setmoves: number[] | undefined,\n    movesetorder: number,\n  ): PGTransform {\n    const moveorbits: PGOrbit[] = [];\n    const perms = [];\n    const oris = [];\n    for (const len of this.cubieords) {\n      perms.push(iota(len));\n      oris.push(zeros(len));\n    }\n    for (let m = moverange[0]; m <= moverange[1]; m++) {\n      const slicecmoves = axiscmoves[m];\n      for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n        const mperm = slicecmoves.slice(j, j + 2 * movesetorder);\n        const setnum = this.cubiesetnums[mperm[0]];\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          mperm[ii] = this.cubieordnums[mperm[ii]];\n        }\n        let inc = 2;\n        let oinc = 3;\n        if (inverted) {\n          inc = mperm.length - 2;\n          oinc = mperm.length - 1;\n        }\n        if (perms[setnum] === iota(this.cubieords[setnum])) {\n          perms[setnum] = perms[setnum].slice();\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum] = oris[setnum].slice();\n          }\n        }\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n          if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {\n            oris[setnum][mperm[ii]] =\n              (mperm[(ii + oinc) % mperm.length] -\n                mperm[(ii + 1) % mperm.length] +\n                2 * this.orbitoris[setnum]) %\n              this.orbitoris[setnum];\n          }\n        }\n      }\n    }\n    let lastId = new PGOrbit(iota(24), zeros(24), 1);\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      if (setmoves && !setmoves[ii]) {\n        continue;\n      }\n      if (this.orbitoris[ii] === 1 || this.options.fixedOrientation) {\n        if (perms[ii] === iota(lastId.perm.length)) {\n          if (perms[ii] !== lastId.perm) {\n            lastId = new PGOrbit(perms[ii], oris[ii], 1);\n          }\n          moveorbits.push(lastId);\n        } else {\n          moveorbits.push(new PGOrbit(perms[ii], oris[ii], 1));\n        }\n      } else {\n        const no = new Array<number>(oris[ii].length);\n        // convert ksolve oris to our internal ori rep\n        for (let jj = 0; jj < perms[ii].length; jj++) {\n          no[jj] = oris[ii][perms[ii][jj]];\n        }\n        moveorbits.push(new PGOrbit(perms[ii], no, this.orbitoris[ii]));\n      }\n    }\n    let mv = new PGTransform(moveorbits);\n    if (amount !== 1) {\n      mv = mv.mulScalar(amount);\n    }\n    return mv;\n  }\n\n  private omitSet(name: string): boolean {\n    for (const excludedSet of this.options.excludeOrbits) {\n      if (excludedSet === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private diffmvsets(a: any[], b: any[], slices: number, neg: boolean) {\n    for (let i = 0; i < a.length; i += 2) {\n      let found = false;\n      for (let j = 0; !found && j < b.length; j += 2) {\n        if (neg) {\n          if (\n            a[i][0] + b[j][1] === slices &&\n            a[i][1] + b[j][0] === slices &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        } else {\n          if (\n            a[i][0] === b[j][0] &&\n            a[i][1] === b[j][1] &&\n            a[i + 1] === b[j + 1]\n          ) {\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // TODO: This is only public for testing; can we make it private again?\n  public getOrbitsDef(\n    fortwisty: boolean,\n    includemoves: boolean = true,\n  ): PGOrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    if (fortwisty) {\n      for (let i = 0; i < this.cubiesetnames.length; i++) {\n        setmoves.push(1);\n      }\n    }\n    const setnames: string[] = [];\n    const setdefs: PGOrbitDef[] = [];\n    // if both a movelist and rotations are needed, eliminate rotations\n    // that do not preserve the movelist.\n    const mps = [];\n    const addrot = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      mps.push(moveset);\n      if (this.options.addRotations) {\n        addrot.push(1);\n      } else {\n        addrot.push(0);\n      }\n    }\n    if (this.options.moveList && this.options.addRotations) {\n      for (let i = 0; i < this.moverotations.length; i++) {\n        addrot[i] = 0;\n      }\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        // does a rotation around k preserve the move set?\n        for (let i = 0; i < this.moverotations.length; i++) {\n          let nn = this.moveplanenormals[k];\n          for (let ii = 1; ii * 2 <= this.movesetorders[i]; ii++) {\n            nn = nn.rotatepoint(this.moverotations[i][0]);\n            if (addrot[i] & ii) {\n              continue;\n            }\n            let found = -1;\n            let neg = false;\n            for (let j = 0; j < this.moveplanenormals.length; j++) {\n              if (nn.dist(this.moveplanenormals[j]) < eps) {\n                found = j;\n                break;\n              } else if (nn.dist(this.moveplanenormals[j].smul(-1)) < eps) {\n                found = j;\n                neg = true;\n                break;\n              }\n            }\n            if (found < 0) {\n              throw new Error(\"Could not find rotation\");\n            }\n            const cmp = mps[found];\n            if (\n              cmp.length !== mps[k].length ||\n              this.moveplanesets[k].length !==\n                this.moveplanesets[found].length ||\n              this.diffmvsets(\n                cmp,\n                mps[k],\n                this.moveplanesets[found].length,\n                neg,\n              )\n            ) {\n              addrot[i] |= ii;\n            }\n          }\n        }\n      }\n      for (let i = 0; i < this.moverotations.length; i++) {\n        if (addrot[i] === 0) {\n          addrot[i] = 1;\n        } else if (addrot[i] === 1) {\n          if (this.movesetorders[i] > 3) {\n            addrot[i] = 2;\n          } else {\n            addrot[i] = 0;\n          }\n        } else if (addrot[i] === 3) {\n          addrot[i] = 0;\n        } else {\n          throw new Error(\"Impossible addrot val\");\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      if (addrot[k] !== 0) {\n        mps[k].push([0, this.moveplanesets[k].length]);\n        mps[k].push(addrot[k]);\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = mps[k];\n      const movesetorder = this.movesetorders[k];\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (moveset[i] === moveset[j] && moveset[i + 1] === moveset[j + 1]) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      const allbits = [];\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = moveset[i][0]; j <= moveset[i][1]; j++) {\n          allbits[j] = 1;\n        }\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (allbits[i] !== 1) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        setmoves[i] = 0;\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(\n        new PGOrbitDef(\n          this.cubieords[i],\n          this.options.fixedOrientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const solved: PGOrbit[] = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      if (this.omitSet(this.cubiesetnames[i])) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(\n        new PGOrbit(\n          p,\n          o,\n          this.options.fixedOrientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const movenames: string[] = [];\n    const moves: PGTransform[] = [];\n    if (includemoves) {\n      for (let k = 0; k < this.moveplanesets.length; k++) {\n        const moveplaneset = this.moveplanesets[k];\n        const slices = moveplaneset.length;\n        const moveset = mps[k];\n        const movesetgeo = this.movesetgeos[k];\n        for (let i = 0; i < moveset.length; i += 2) {\n          const movebits = moveset[i];\n          const mna = getmovename(movesetgeo, movebits, slices);\n          const movename = mna[0];\n          const inverted = mna[1];\n          if (moveset[i + 1] === 1) {\n            movenames.push(movename);\n          } else {\n            movenames.push(movename + moveset[i + 1]);\n          }\n          const mv = this.getMoveFromBits(\n            movebits,\n            moveset[i + 1],\n            inverted,\n            this.cmovesbyslice[k],\n            setmoves,\n            this.movesetorders[k],\n          );\n          moves.push(mv);\n        }\n      }\n    }\n    let r = new PGOrbitsDef(\n      setnames,\n      setdefs,\n      new VisibleState(solved),\n      movenames,\n      moves,\n    );\n    if (this.options.optimizeOrbits) {\n      r = r.optimize();\n    }\n    if (this.options.scrambleAmount !== 0) {\n      r.scramble(this.options.scrambleAmount);\n    }\n    return r;\n  }\n\n  public getScramble(n: number = 0): KTransformationData {\n    const od = this.getOrbitsDef(false);\n    return od.transformToKTransformationData(od.getScrambleTransformation(n));\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.map((_) => _.toPerm());\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm {\n    // get a solved position\n    const r = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  // Given a rotation description that says to align feature1\n  // with a given vector, and then as much as possible feature2\n  // with another given vector, return a Quaternion that\n  // performs this rotation.\n  private getOrientationRotation(desiredRotation: any[]): Quat {\n    const [feature1name, [x1, y1, z1]] = desiredRotation[0];\n    const direction1 = new Quat(0, x1, -y1, z1);\n\n    const [feature2name, [x2, y2, z2]] = desiredRotation[1];\n    const direction2 = new Quat(0, x2, -y2, z2);\n    let feature1: Quat | null = null;\n    let feature2: Quat | null = null;\n    const feature1geoname = this.swizzler.unswizzle(feature1name);\n    const feature2geoname = this.swizzler.unswizzle(feature2name);\n    for (const gn of this.geonormals) {\n      if (feature1geoname === gn[1]) {\n        feature1 = gn[0];\n      }\n      if (feature2geoname === gn[1]) {\n        feature2 = gn[0];\n      }\n    }\n    if (!feature1) {\n      throw new Error(\"Could not find feature \" + feature1name);\n    }\n    if (!feature2) {\n      throw new Error(\"Could not find feature \" + feature2name);\n    }\n    const r1 = feature1.pointrotation(direction1);\n    const feature2rot = feature2.rotatepoint(r1);\n    const r2 = feature2rot\n      .unproject(direction1)\n      .pointrotation(direction2.unproject(direction1));\n    return r2.mul(r1);\n  }\n\n  private getInitial3DRotation(): Quat {\n    const basefacecount = this.baseFaceCount;\n    let orientationDescription: FaceBasedOrientationDescription | null = null;\n    if (this.options.puzzleOrientation) {\n      orientationDescription = this.options.puzzleOrientation;\n    } else if (this.options.puzzleOrientations) {\n      orientationDescription = this.options.puzzleOrientations[basefacecount];\n    }\n    // either no option specified or no matching key in\n    // puzzleOrientations.\n    if (!orientationDescription) {\n      orientationDescription = defaultOrientations()[basefacecount];\n    }\n    if (!orientationDescription) {\n      throw new Error(\"No default orientation?\");\n    }\n    return this.getOrientationRotation(orientationDescription);\n  }\n\n  private generate2dmapping(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n    twodshrink: number = 0.92,\n  ): (fn: number, q: Quat) => number[] {\n    // generate a mapping to use for 2D for textures, svg\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = (2 * Math.PI) / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [\n      [1, 0],\n      [0, 0],\n    ];\n    extendedges(edges[net[0][0]], polyn);\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (const esi of es) {\n        minx = Math.min(minx, esi[0]);\n        maxx = Math.max(maxx, esi[0]);\n        miny = Math.min(miny, esi[1]);\n        maxy = Math.max(maxy, esi[1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: Record<string, Quat[]> = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [\n      [sc + xoff, yoff],\n      [xoff, yoff],\n    ];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0, [\n      new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0),\n    ]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (const neti of net) {\n      const f0 = neti[0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(\"Could not find first face name \" + f0);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < neti.length; j++) {\n        const f1 = neti[j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [\n          edges2[f0][j % polyn],\n          edges2[f0][(j + polyn - 1) % polyn],\n        ];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn]\n          .sum(thisface[(caf0 + j + polyn - 1) % polyn])\n          .smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[f0 === el[0] ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k, [\n              new Quat(0, p2[0], p2[1], 0),\n              new Quat(0, p1[0], p1[1], 0),\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let face of this.faces) {\n      if (threed) {\n        face = face.rotate(rot);\n      }\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face.get(j).b));\n        hiy = Math.max(hiy, Math.abs(face.get(j).c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const mappt2d = (fn: number, q: Quat): number[] => {\n      if (threed) {\n        q = q.rotatepoint(rot);\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = this.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1;\n        return [\n          trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),\n          trim + h * 0.5 + q.c * sc2,\n        ];\n      } else {\n        const g = geos[this.facenames[fn][1]];\n        return [\n          trim + twodshrink * q.dot(g[0]) + g[2].b,\n          trim + h - twodshrink * q.dot(g[1]) - g[2].c,\n        ];\n      }\n    };\n    return mappt2d;\n  }\n\n  public generatesvg(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n  ): string {\n    const mappt2d = this.generate2dmapping(w, h, trim, threed);\n    function drawedges(id: string, pts: number[][], color: string): string {\n      return (\n        '<polygon id=\"' +\n        id +\n        '\" class=\"sticker\" style=\"fill: ' +\n        color +\n        '\" points=\"' +\n        pts.map((p) => p[0] + \" \" + p[1]).join(\" \") +\n        '\"/>\\n'\n      );\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.baseFaceCount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const facenum = Math.floor(i / this.stickersperface);\n      const fg = [];\n      for (let j = 0; j < face.length; j++) {\n        fg.push(mappt2d(facenum, face.get(j)));\n      }\n      facegeo.push(fg);\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.baseFaceCount; j++) {\n      svg.push(\"<g>\");\n      svg.push(\"<title>\" + this.facenames[j][1] + \"</title>\\n\");\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubie[i];\n        const cubieori = this.facetoord[i];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id =\n          this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + cubieori;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + jj;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const html =\n      '<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n' +\n      '<style type=\"text/css\"><![CDATA[' +\n      \".sticker { stroke: #000000; stroke-width: 1px; }\" +\n      \"]]></style>\\n\" +\n      svg.join(\"\") +\n      \"</svg>\";\n    return html;\n  }\n\n  // The colorfrac parameter says how much of the face should be\n  // colored (vs dividing lines); we default to 0.77 which seems\n  // to work pretty well.  It should be a number between probably\n  // 0.4 and 0.9.\n  public get3d(options?: { stickerColors?: string[] }): StickerDat {\n    const stickers = [];\n    const rot = this.getInitial3DRotation();\n    const faces = [];\n    const maxdist: number = 0.52 * this.basefaces[0].get(0).len();\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = this.basefaces[i].rotate(rot);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n    }\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubie[i];\n      const cubieori = this.facetoord[i];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      let color = this.graybyori(cubie)\n        ? \"#808080\"\n        : this.colors[this.facenames[facenum][1]];\n      if (options?.stickerColors) {\n        color = options.stickerColors[i];\n      }\n      const coords = this.faces[i].rotate(rot);\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n        face: facenum,\n      });\n      let fcoords = coords;\n      if (this.duplicatedFaces[i]) {\n        const rotdist = fcoords.length / this.duplicatedFaces[i];\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          for (let k = 0; k < rotdist; k++) {\n            fcoords = fcoords.rotateforward();\n          }\n          stickers.push({\n            coords: toFaceCoords(fcoords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n            face: facenum,\n            isDup: true,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (const gn of this.geonormals) {\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot), 1),\n            quantumMove: new Move(msg[0]),\n            order,\n          });\n          grips.push({\n            coordinates: toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n            quantumMove: new Move(msg[2]),\n            order,\n          });\n        }\n      }\n    }\n    const twodmapper = this.generate2dmapping(2880, 2160, 0, false, 1.0);\n    const g = (function () {\n      const irot = rot.invrot();\n      return function (facenum: number, coords: number[]): number[] {\n        let q = new Quat(\n          0,\n          coords[0] * maxdist,\n          -coords[1] * maxdist,\n          coords[2] * maxdist,\n        );\n        q = q.rotatepoint(irot);\n        const x = twodmapper(facenum, q);\n        x[0] /= 2880;\n        x[1] = 1 - x[1] / 2160;\n        return x;\n      };\n    })().bind(this);\n    return {\n      stickers,\n      faces,\n      axis: grips,\n      unswizzle: this.unswizzle.bind(this),\n      notationMapper: this.notationMapper,\n      textureMapper: { getuv: g },\n    };\n  }\n\n  //  From the name of a geometric element (face, vertex, edge), get a\n  //  normal vector respecting the default orientation.  This is useful\n  //  to define the initial position of the camera in a 3D scene.  The\n  //  return value is normalized, so multiply it by the camera distance.\n  //  Returns undefined if no such geometric element.\n  public getGeoNormal(geoname: string): number[] | undefined {\n    const rot = this.getInitial3DRotation();\n    const grip = this.swizzler.unswizzle(geoname);\n    for (const gn of this.geonormals) {\n      if (grip === gn[1]) {\n        const r = toCoords(gn[0].rotatepoint(rot), 1);\n        //  This routine is intended to use for the camera location.\n        //  If the camera location is vertical, and we give some\n        //  near-zero values for x and z, then the rotation in the\n        //  X/Z plane will be somewhat arbitrary.  So we clean up the\n        //  returned vector here.  We give a very slight positive\n        //  z value.\n        if (Math.abs(r[0]) < eps && Math.abs(r[2]) < eps) {\n          r[0] = 0.0;\n          r[2] = 1e-6;\n        }\n        return r;\n      }\n    }\n    return undefined;\n  }\n\n  private getfaceindex(facenum: number): number {\n    const divid = this.stickersperface;\n    return Math.floor(facenum / divid);\n  }\n\n  public textForTwizzleExplorer(): string {\n    return `Faces ${this.baseplanerot.length}\nStickers per face ${this.stickersperface}\nShort edge ${this.shortedge}\nCubies ${this.cubies.length}\nEdge distance ${this.edgedistance}\nVertex distance ${this.vertexdistance}`;\n  }\n\n  writeSchreierSims(tw: (s: string) => void) {\n    const os = this.getOrbitsDef(false);\n    const as = os.reassemblySize();\n    tw(`Reassembly size is ${as}`);\n    const ss = schreierSims(this.getMovesAsPerms(), tw);\n    const r = as / ss;\n    tw(`Ratio is ${r}`);\n  }\n}\n\nexport class PGNotation {\n  private orbitNames: string[];\n  constructor(private pg: PuzzleGeometry, od: PGOrbitsDef) {\n    this.orbitNames = od.orbitnames;\n  }\n\n  public lookupMove(move: Move): KTransformationData | null {\n    const mv = this.pg.parseMove(move);\n    // if a move list subset is defined, don't return moves outside the subset.\n    if (this.pg.parsedmovelist) {\n      let found = false;\n      for (const parsedmove of this.pg.parsedmovelist) {\n        if (\n          parsedmove[1] === mv[1] &&\n          parsedmove[2] === mv[2] &&\n          parsedmove[3] === mv[3] &&\n          parsedmove[4] === mv[4]\n        ) {\n          found = true;\n        }\n      }\n      if (!found) {\n        return null;\n      }\n    }\n    let bits = [mv[2], mv[3]];\n    if (!mv[4]) {\n      const slices = this.pg.moveplanesets[mv[1]].length;\n      bits = [slices - mv[3], slices - mv[2]];\n    }\n    const pgmv = this.pg.getMoveFromBits(\n      bits,\n      mv[5],\n      !mv[4],\n      this.pg.cmovesbyslice[mv[1]],\n      undefined,\n      this.pg.movesetorders[mv[1]],\n    );\n    const r = PGOrbitsDef.transformToKTransformationData(this.orbitNames, pgmv);\n    return r;\n  }\n}\n","export enum IterationDirection {\n  Forwards = 1,\n  Backwards = -1,\n}\n\nexport function toggleDirection(\n  iterationDirection: IterationDirection,\n  flip: boolean = true,\n): IterationDirection {\n  if (!flip) {\n    return iterationDirection;\n  }\n  switch (iterationDirection) {\n    case IterationDirection.Forwards:\n      return IterationDirection.Backwards;\n    case IterationDirection.Backwards:\n      return IterationDirection.Forwards;\n  }\n}\n\nexport function direct<T>(\n  g: Iterable<T>,\n  iterDir: IterationDirection,\n): Iterable<T> {\n  return iterDir === IterationDirection.Backwards ? Array.from(g).reverse() : g;\n}\n\nexport function reverse<T>(g: Iterable<T>): Iterable<T> {\n  return Array.from(g).reverse();\n}\n\nexport function* directedGenerator<T>(\n  g: Generator<T>,\n  direction: IterationDirection,\n): Generator<T> {\n  direction === IterationDirection.Backwards\n    ? yield* reverseGenerator(g)\n    : yield* g;\n}\n\nexport function* reverseGenerator<T>(g: Generator<T>): Generator<T> {\n  for (const t of Array.from(g).reverse()) {\n    yield t;\n  }\n}\n","import type { Alg } from \"./Alg\";\nimport type { IterationDirection } from \"./iteration\";\nimport type { LeafUnit, Unit } from \"./units/Unit\";\n\nlet writeAlgDebugField = false;\nexport function setAlgDebugField(debug: boolean): void {\n  writeAlgDebugField = debug;\n}\n\nexport abstract class Comparable {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  is(c: any): boolean {\n    return this instanceof c;\n  }\n\n  as<T>(c: new (...args: any) => T): T | null {\n    return this instanceof c ? this : null;\n  }\n\n  abstract isIdentical(other: Comparable): boolean;\n}\n\nexport interface Repeatable extends Comparable {\n  experimentalExpand(\n    iterDir?: IterationDirection,\n    depth?: number,\n  ): Generator<LeafUnit>;\n}\n\n// Common to algs or units\nexport abstract class AlgCommon<T extends Alg | Unit>\n  extends Comparable\n  implements Repeatable\n{\n  constructor() {\n    super();\n    if (writeAlgDebugField) {\n      Object.defineProperty(this, \"_debugStr\", {\n        get: () => {\n          return this.toString();\n        },\n      });\n    }\n  }\n\n  get log(): (message?: any) => void {\n    // By returning a (bound) version of `console.log`, we ensure that DevTools\n    // logs the call site instead of this function.\n    return console.log.bind(console, this, this.toString()) as (\n      message?: any,\n    ) => void;\n  }\n\n  abstract toString(): string;\n\n  abstract invert(): T;\n\n  abstract experimentalExpand(iterDir: IterationDirection): Generator<LeafUnit>;\n}\n","export const MAX_INT = 0x7fffffff; // 2^32-1, the max value for signed 32-bit ints.\nexport const MAX_INT_DESCRIPTION = \"2^31 - 1\";\nexport const MIN_INT = -0x80000000;\nexport const MINT_INT_DESCRIPTION = \"-2^31\";\n","import { Alg } from \"./Alg\";\nimport type { Unit } from \"./units/Unit\";\n\nexport class AlgBuilder {\n  #units: Unit[] = [];\n\n  push(u: Unit): void {\n    this.#units.push(u);\n  }\n\n  // TODO: Allow FlexibleAlgSource?\n  /** @deprecated */\n  experimentalPushAlg(alg: Alg): void {\n    // TODO: Optimize?\n    for (const u of alg.units()) {\n      this.push(u);\n    }\n  }\n\n  // TODO: can we guarantee this to be fast in the permanent API?\n  experimentalNumUnits(): number {\n    return this.#units.length;\n  }\n\n  // can be called multiple times, even if you push units inbetween.\n  toAlg(): Alg {\n    return new Alg(this.#units);\n  }\n\n  reset(): void {\n    this.#units = [];\n  }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\nexport class Commutator extends AlgCommon<Commutator> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsCommutator = other.as(Commutator);\n    return !!(\n      otherAsCommutator?.A.isIdentical(this.A) &&\n      otherAsCommutator?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Commutator {\n    return new Commutator(this.#B, this.#A);\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      if (iterDir === IterationDirection.Forwards) {\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      } else {\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      }\n    }\n  }\n\n  toString(): string {\n    return `[${this.#A.toString()}, ${this.#B.toString()}]`;\n  }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\nexport class Conjugate extends AlgCommon<Conjugate> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsConjugate = other.as(Conjugate);\n    return !!(\n      otherAsConjugate?.A.isIdentical(this.A) &&\n      otherAsConjugate?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Conjugate {\n    return new Conjugate(this.#A, this.#B.invert());\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.A.experimentalExpand(IterationDirection.Forwards, depth - 1);\n      yield* this.B.experimentalExpand(iterDir, depth - 1);\n      yield* this.A.experimentalExpand(IterationDirection.Backwards, depth - 1);\n    }\n  }\n\n  toString(): string {\n    return `[${this.A}: ${this.B}]`;\n  }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\n// TODO: hash\n// TODO: this conflicts with the HTML `LineComment` class\nexport class LineComment extends AlgCommon<LineComment> {\n  readonly #text: string;\n\n  constructor(commentText: string) {\n    super();\n    if (commentText.includes(\"\\n\") || commentText.includes(\"\\r\")) {\n      throw new Error(\"LineComment cannot contain newline\");\n    }\n    this.#text = commentText;\n  }\n\n  get text(): string {\n    return this.#text;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsLineComment = other as LineComment;\n    return other.is(LineComment) && this.#text === otherAsLineComment.#text;\n  }\n\n  invert(): LineComment {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<LeafUnit> {\n    yield this;\n  }\n\n  toString(): string {\n    return `//${this.#text}`;\n  }\n\n  // toJSON(): LineCommentJSON {\n  //   return {\n  //     type: \"comment\",\n  //     text: this.#text,\n  //   };\n  // }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\nexport class Newline extends AlgCommon<Newline> {\n  toString(): string {\n    return `\\n`;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Newline);\n  }\n\n  invert(): Newline {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<LeafUnit> {\n    yield this;\n  }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\nexport class Pause extends AlgCommon<Pause> {\n  toString(): string {\n    return `.`;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Pause);\n  }\n\n  invert(): Pause {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<LeafUnit> {\n    yield this;\n  }\n}\n","import { Alg } from \"./Alg\";\nimport { AlgBuilder } from \"./AlgBuilder\";\nimport type { Unit } from \"./units\";\nimport { Commutator } from \"./units/containers/Commutator\";\nimport { Conjugate } from \"./units/containers/Conjugate\";\nimport { Grouping } from \"./units/containers/Grouping\";\nimport { LineComment } from \"./units/leaves/LineComment\";\nimport { Move, QuantumMove } from \"./units/leaves/Move\";\nimport { Newline } from \"./units/leaves/Newline\";\nimport { Pause } from \"./units/leaves/Pause\";\n\ntype StoppingChar = \",\" | \":\" | \"]\" | \")\";\n\nfunction parseIntWithEmptyFallback<T>(n: string, emptyFallback: T): number | T {\n  return n ? parseInt(n) : emptyFallback;\n}\n\nconst amountRegex = /^(\\d+)?('?)/;\nconst moveStartRegex = /^[_\\dA-Za-z]/; // TODO: Handle slash\nconst quantumMoveRegex = /^((([1-9]\\d*)-)?([1-9]\\d*))?([_A-Za-z]+)?/;\nconst commentTextRegex = /^[^\\n]*/;\nconst square1PairStart = /^(-?\\d+), ?/; // TODO: match up with other whitespace handling?\nconst square1PairEnd = /^(-?\\d+)\\)/; // TODO: match up with other whitespace handling?\n\nexport function parseAlg(s: string): Alg {\n  return new AlgParser().parseAlg(s);\n}\n\nexport function parseMove(s: string): Move {\n  return new AlgParser().parseMove(s);\n}\n\nexport function parseQuantumMove(s: string): QuantumMove {\n  return new AlgParser().parseQuantumMove(s);\n}\n\nexport interface ParserIndexed {\n  startCharIndex: number;\n  endCharIndex: number;\n}\n\nexport type Parsed<T extends Alg | Unit> = T & ParserIndexed;\n\n// TODO: attach to parser so the end char index can default to `this.#idx`?\nfunction addCharIndices<T extends Alg | Unit>(\n  t: T,\n  startCharIndex: number,\n  endCharIndex: number,\n): Parsed<T> {\n  const parsedT = t as ParserIndexed & T;\n  parsedT.startCharIndex = startCharIndex;\n  parsedT.endCharIndex = endCharIndex;\n  return parsedT;\n}\n\nexport function transferCharIndex<T extends Alg | Unit>(from: T, to: T): T {\n  if (\"startCharIndex\" in from) {\n    (to as Parsed<T>).startCharIndex = (from as Parsed<T>).startCharIndex;\n  }\n  if (\"endCharIndex\" in from) {\n    (to as Parsed<T>).endCharIndex = (from as Parsed<T>).endCharIndex;\n  }\n  return to;\n}\n\ntype MoveSuffix = \"+\" | \"++\" | \"-\" | \"--\";\n\n// TODO: support recording string locations for moves.\nclass AlgParser {\n  #input: string = \"\";\n  #idx: number = 0;\n\n  parseAlg(input: string): Parsed<Alg> {\n    this.#input = input;\n    this.#idx = 0;\n    const alg = this.parseAlgWithStopping([]);\n    this.mustBeAtEndOfInput();\n    return alg;\n  }\n\n  parseMove(input: string): Parsed<Move> {\n    this.#input = input;\n    this.#idx = 0;\n    const move = this.parseMoveImpl();\n    this.mustBeAtEndOfInput();\n    return move;\n  }\n\n  parseQuantumMove(input: string): QuantumMove {\n    this.#input = input;\n    this.#idx = 0;\n    const quantumMove = this.parseQuantumMoveImpl();\n    this.mustBeAtEndOfInput();\n    return quantumMove;\n  }\n\n  private mustBeAtEndOfInput() {\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"parsing unexpectedly ended early\");\n    }\n  }\n\n  private parseAlgWithStopping(stopBefore: StoppingChar[]): Parsed<Alg> {\n    let algStartIdx = this.#idx;\n    let algEndIdx = this.#idx;\n    const algBuilder = new AlgBuilder();\n\n    // We're \"crowded\" if there was not a space or newline since the last unit.\n    let crowded = false;\n\n    const mustNotBeCrowded = (idx: number): void => {\n      if (crowded) {\n        throw new Error(\n          `Unexpected character at index ${idx}. Are you missing a space?`,\n        ); // TODO better error message\n      }\n    };\n\n    mainLoop: while (this.#idx < this.#input.length) {\n      const savedCharIndex = this.#idx;\n      if ((stopBefore as string[]).includes(this.#input[this.#idx])) {\n        return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n      }\n      if (this.tryConsumeNext(\" \")) {\n        crowded = false;\n        if (algBuilder.experimentalNumUnits() === 0) {\n          algStartIdx = this.#idx;\n        }\n        continue mainLoop;\n      } else if (moveStartRegex.test(this.#input[this.#idx])) {\n        mustNotBeCrowded(savedCharIndex);\n        const move = this.parseMoveImpl();\n        algBuilder.push(move);\n        crowded = true;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"(\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const sq1PairStartMatch = this.tryRegex(square1PairStart);\n        if (sq1PairStartMatch) {\n          const topAmountString = sq1PairStartMatch[1];\n          const savedCharIndexD = this.#idx;\n          const sq1PairEndMatch = this.parseRegex(square1PairEnd);\n          const uMove = addCharIndices(\n            new Move(new QuantumMove(\"U_SQ_\"), parseInt(topAmountString)),\n            savedCharIndex + 1,\n            savedCharIndex + 1 + topAmountString.length,\n          );\n          const dMove = addCharIndices(\n            new Move(new QuantumMove(\"D_SQ_\"), parseInt(sq1PairEndMatch[1])),\n            savedCharIndexD,\n            this.#idx - 1,\n          );\n          const alg = addCharIndices(\n            new Alg([uMove, dMove]),\n            savedCharIndex + 1,\n            this.#idx - 1,\n          );\n          algBuilder.push(\n            addCharIndices(new Grouping(alg), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        } else {\n          const alg = this.parseAlgWithStopping([\")\"]);\n          this.mustConsumeNext(\")\");\n          const amount = this.parseAmount();\n          algBuilder.push(\n            addCharIndices(\n              new Grouping(alg, amount),\n              savedCharIndex,\n              this.#idx,\n            ),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\"[\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const A = this.parseAlgWithStopping([\",\", \":\"]);\n        const separator = this.popNext();\n        const B = this.parseAlgWithStopping([\"]\"]);\n        this.mustConsumeNext(\"]\");\n        switch (separator) {\n          case \":\":\n            algBuilder.push(\n              addCharIndices(new Conjugate(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          case \",\":\n            algBuilder.push(\n              addCharIndices(new Commutator(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          default:\n            throw \"unexpected parsing error\";\n        }\n      } else if (this.tryConsumeNext(\"\\n\")) {\n        algBuilder.push(\n          addCharIndices(new Newline(), savedCharIndex, this.#idx),\n        );\n        crowded = false;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"/\")) {\n        if (this.tryConsumeNext(\"/\")) {\n          mustNotBeCrowded(savedCharIndex);\n          const [text] = this.parseRegex(commentTextRegex);\n          algBuilder.push(\n            addCharIndices(new LineComment(text), savedCharIndex, this.#idx),\n          );\n          crowded = false;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        } else {\n          // We allow crowding here to account for csTimer scrambles, which don't have a space between a Square-1 tuple and the following slash.\n          algBuilder.push(\n            addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\".\")) {\n        mustNotBeCrowded(savedCharIndex);\n        algBuilder.push(addCharIndices(new Pause(), savedCharIndex, this.#idx));\n        crowded = true;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else {\n        throw new Error(`Unexpected character: ${this.popNext()}`);\n      }\n    }\n\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"did not finish parsing?\");\n    }\n    if (stopBefore.length > 0) {\n      throw new Error(\"expected stopping\");\n    }\n    return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n  }\n\n  private parseQuantumMoveImpl(): QuantumMove {\n    const [, , , outerLayerStr, innerLayerStr, family] =\n      this.parseRegex(quantumMoveRegex);\n\n    return new QuantumMove(\n      family,\n      parseIntWithEmptyFallback(innerLayerStr, undefined),\n      parseIntWithEmptyFallback(outerLayerStr, undefined),\n    );\n  }\n\n  private parseMoveImpl(): Parsed<Move> {\n    const savedCharIndex = this.#idx;\n\n    if (this.tryConsumeNext(\"/\")) {\n      return addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx);\n    }\n\n    let quantumMove = this.parseQuantumMoveImpl();\n    // Only `hadEmptyAbsAmount` is `const`.\n    // eslint-disable-next-line prefer-const\n    let [amount, hadEmptyAbsAmount] = this.parseAmountAndTrackEmptyAbsAmount();\n    const suffix = this.parseMoveSuffix();\n\n    if (suffix) {\n      if (amount < 0) {\n        throw new Error(\"uh-oh\");\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && amount !== 1) {\n        // TODO: Handle 1 vs. null\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount other than 1.\",\n        );\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && !hadEmptyAbsAmount) {\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount written as a number.\",\n        );\n      }\n      if ((suffix === \"+\" || suffix === \"-\") && hadEmptyAbsAmount) {\n        throw new Error(\n          \"Clock dial moves must have an amount written as a natural number followed by + or -.\",\n        );\n      }\n      if (suffix.startsWith(\"+\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"+\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n      }\n      if (suffix.startsWith(\"-\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"-\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n        amount *= -1;\n      }\n    }\n\n    const move = addCharIndices(\n      new Move(quantumMove, amount),\n      savedCharIndex,\n      this.#idx,\n    );\n    return move;\n  }\n\n  private parseMoveSuffix(): MoveSuffix | null {\n    if (this.tryConsumeNext(\"+\")) {\n      if (this.tryConsumeNext(\"+\")) {\n        return \"++\";\n      }\n      return \"+\";\n    }\n    if (this.tryConsumeNext(\"-\")) {\n      if (this.tryConsumeNext(\"-\")) {\n        return \"--\";\n      }\n      return \"-\";\n    }\n    return null;\n  }\n\n  private parseAmountAndTrackEmptyAbsAmount(): [number, boolean] {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(amountRegex);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return [\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1),\n      !absAmountStr,\n    ];\n  }\n\n  private parseAmount(): number {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(amountRegex);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount number can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return (\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1)\n    );\n  }\n\n  private parseRegex(regex: RegExp): RegExpExecArray {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      throw new Error(\"internal parsing error\"); // TODO\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  // TOD: can we avoid this?\n  private tryRegex(regex: RegExp): RegExpExecArray | null {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      return null;\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  private remaining(): string {\n    return this.#input.slice(this.#idx);\n  }\n\n  private popNext(): string {\n    const next = this.#input[this.#idx];\n    this.#idx++;\n    return next;\n  }\n\n  private tryConsumeNext(expected: string): boolean {\n    if (this.#input[this.#idx] === expected) {\n      this.#idx++;\n      return true;\n    }\n    return false;\n  }\n\n  private mustConsumeNext(expected: string): string {\n    const next = this.popNext();\n    if (next !== expected) {\n      throw new Error(\n        `expected \\`${expected}\\` while parsing, encountered ${next}`,\n      ); // TODO: be more helpful\n    }\n    return next;\n  }\n}\n","const warned = new Set<string>();\nexport function warnOnce(s: string): void {\n  if (!warned.has(s)) {\n    console.warn(s);\n    warned.add(s);\n  }\n}\n","import type { Repeatable } from \"../common\";\nimport { IterationDirection, toggleDirection } from \"../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION, MIN_INT } from \"../limits\";\nimport type { LeafUnit } from \"./Unit\";\n\nexport class QuantumWithAmount<Q extends Repeatable> {\n  readonly quantum: Q;\n  readonly amount: number;\n\n  constructor(quantum: Q, amount: number = 1) {\n    this.quantum = quantum;\n    this.amount = amount;\n\n    if (\n      !Number.isInteger(this.amount) ||\n      this.amount < MIN_INT ||\n      this.amount > MAX_INT\n    ) {\n      throw new Error(\n        `Unit amount absolute value must be a non-negative integer from ${MAX_INT_DESCRIPTION} to ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n  }\n\n  suffix(): string {\n    let s: string = \"\";\n    // TODO\n    const absAmount = Math.abs(this.amount);\n    if (absAmount !== 1) {\n      s += absAmount;\n    }\n    if (this.amount < 0) {\n      s += \"'\";\n    }\n    return s;\n  }\n\n  isIdentical(other: QuantumWithAmount<Q>): boolean {\n    return (\n      this.quantum.isIdentical(other.quantum) && this.amount === other.amount\n    );\n  }\n\n  // TODO: `Conjugate` and `Commutator` decrement `depth` inside the quantum, `Grouping` has to do it outside the quantum.\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth: number,\n  ): Generator<LeafUnit> {\n    const absAmount = Math.abs(this.amount);\n    const newIterDir = toggleDirection(iterDir, this.amount < 0);\n    for (let i = 0; i < absAmount; i++) {\n      yield* this.quantum.experimentalExpand(newIterDir, depth);\n    }\n  }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION } from \"../../limits\";\nimport { parseMove, parseQuantumMove, transferCharIndex } from \"../../parse\";\nimport { warnOnce } from \"../../warnOnce\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { LeafUnit } from \"../Unit\";\n\ninterface QuantumMoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n}\n\nexport class QuantumMove extends Comparable {\n  readonly #family: string;\n  readonly #innerLayer: number | null;\n  readonly #outerLayer: number | null;\n\n  constructor(\n    family: string,\n    innerLayer?: number | null,\n    outerLayer?: number | null,\n  ) {\n    super();\n    this.#family = family;\n    this.#innerLayer = innerLayer ?? null;\n    this.#outerLayer = outerLayer ?? null;\n    Object.freeze(this);\n\n    if (\n      this.#innerLayer !== null &&\n      (!Number.isInteger(this.#innerLayer) ||\n        this.#innerLayer < 1 ||\n        this.#innerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove inner layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      (!Number.isInteger(this.#outerLayer) ||\n        this.#outerLayer < 1 ||\n        this.#outerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove outer layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      this.#innerLayer !== null &&\n      this.#innerLayer <= this.#outerLayer\n    ) {\n      throw new Error(\n        \"QuantumMove outer layer must be smaller than inner layer.\",\n      );\n    }\n\n    if (this.#outerLayer !== null && this.#innerLayer === null) {\n      throw new Error(\n        \"QuantumMove with an outer layer must have an inner layer\",\n      ); // TODO: test\n    }\n  }\n\n  static fromString(s: string): QuantumMove {\n    return parseQuantumMove(s);\n  }\n\n  // TODO: `modify`?\n  modified(modifications: QuantumMoveModifications): QuantumMove {\n    return new QuantumMove(\n      modifications.family ?? this.#family,\n      modifications.innerLayer ?? this.#innerLayer,\n      modifications.outerLayer ?? this.#outerLayer,\n    );\n  }\n\n  isIdentical(other: QuantumMove): boolean {\n    const otherAsQuantumMove = other;\n    return (\n      other.is(QuantumMove) &&\n      this.#family === otherAsQuantumMove.#family &&\n      this.#innerLayer === otherAsQuantumMove.#innerLayer &&\n      this.#outerLayer === otherAsQuantumMove.#outerLayer\n    );\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get family(): string {\n    return this.#family;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get outerLayer(): number | null {\n    return this.#outerLayer;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get innerLayer(): number | null {\n    return this.#innerLayer;\n  }\n\n  experimentalExpand(): Generator<LeafUnit> {\n    throw new Error(\n      \"experimentalExpand() cannot be called on a `QuantumMove` directly.\",\n    );\n  }\n\n  toString(): string {\n    let s = this.#family;\n    if (this.#innerLayer !== null) {\n      s = String(this.#innerLayer) + s;\n      if (this.#outerLayer !== null) {\n        s = String(this.#outerLayer) + \"-\" + s;\n      }\n    }\n    return s;\n  }\n}\n\nexport interface MoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n  amount?: number;\n}\n\nexport class Move extends AlgCommon<Move> {\n  readonly #quantumWithAmount: QuantumWithAmount<QuantumMove>;\n\n  constructor(\n    ...args: [QuantumMove] | [QuantumMove, number] | [string] | [string, number]\n  ) {\n    super();\n    if (typeof args[0] === \"string\") {\n      if (args[1] ?? null) {\n        this.#quantumWithAmount = new QuantumWithAmount(\n          QuantumMove.fromString(args[0]),\n          args[1],\n        );\n        return;\n      } else {\n        return Move.fromString(args[0]); // TODO: can we return here?\n      }\n    }\n    this.#quantumWithAmount = new QuantumWithAmount<QuantumMove>(\n      args[0],\n      args[1],\n    );\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsMove = other.as(Move);\n    return (\n      !!otherAsMove &&\n      this.#quantumWithAmount.isIdentical(otherAsMove.#quantumWithAmount)\n    );\n  }\n\n  invert(): Move {\n    // TODO: handle char indices more consistently among units.\n    return transferCharIndex(\n      this,\n      new Move(this.#quantumWithAmount.quantum, -this.amount),\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n  ): Generator<LeafUnit> {\n    if (iterDir === IterationDirection.Forwards) {\n      yield this;\n    } else {\n      yield this.modified({\n        amount: -this.amount,\n      });\n    }\n  }\n\n  get quantum(): QuantumMove {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  // TODO: `modify`?\n  modified(modifications: MoveModifications): Move {\n    // TODO: Avoid creating a new quantum move\n    return new Move(\n      this.#quantumWithAmount.quantum.modified(modifications),\n      modifications.amount ?? this.amount,\n    );\n  }\n\n  static fromString(s: string): Move {\n    return parseMove(s);\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"blockMove\";\n  }\n\n  /** @deprecated */\n  get family(): string {\n    return this.#quantumWithAmount.quantum.family ?? undefined;\n  }\n\n  /** @deprecated */\n  get outerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.outerLayer ?? undefined;\n  }\n\n  /** @deprecated */\n  get innerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.innerLayer ?? undefined;\n  }\n\n  toString(): string {\n    if (this.family === \"_SLASH_\") {\n      return \"/\"; // TODO: validate no amount\n    }\n    if (this.family.endsWith(\"_PLUS_\")) {\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -6) +\n        Math.abs(this.amount) +\n        (this.amount < 0 ? \"-\" : \"+\")\n      ); // TODO\n    }\n    if (this.family.endsWith(\"_PLUSPLUS_\")) {\n      const absAmount = Math.abs(this.amount);\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -10) +\n        (absAmount === 1 ? \"\" : absAmount) +\n        (this.amount < 0 ? \"--\" : \"++\")\n      ); // TODO\n    }\n\n    return (\n      this.#quantumWithAmount.quantum.toString() +\n      this.#quantumWithAmount.suffix()\n    );\n  }\n\n  // // TODO: Serialize as a string?\n  // toJSON(): MoveJSON {\n  //   return {\n  //     type: \"move\",\n  //     family: this.family,\n  //     innerLayer: this.innerLayer,\n  //     outerLayer: this.outerLayer,\n  //   };\n  // }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { Move, QuantumMove } from \"../leaves/Move\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { LeafUnit } from \"../Unit\";\n\n// This is a workaround for `jest`, which doesn't handle cycles of imports inside `cubing/alg`.\n// We need to lazy-initialize the reusable quantum moves for Square-1, so we create this wrapper for it.\nclass Square1TupleFormatter {\n  quantumU_SQ_: QuantumMove | null = null;\n  quantumD_SQ_: QuantumMove | null = null;\n\n  format(grouping: Grouping): string | null {\n    const amounts = this.tuple(grouping);\n    if (!amounts) {\n      return null;\n    }\n    return `(${amounts.map((move) => move.amount).join(\", \")})`;\n  }\n\n  tuple(grouping: Grouping): [moveU: Move, moveD: Move] | null {\n    this.quantumU_SQ_ ||= new QuantumMove(\"U_SQ_\");\n    this.quantumD_SQ_ ||= new QuantumMove(\"D_SQ_\");\n\n    const quantumAlg = grouping.alg;\n    if (quantumAlg.experimentalNumUnits() === 2) {\n      const [U, D] = quantumAlg.units();\n      if (\n        U.as(Move)?.quantum.isIdentical(this.quantumU_SQ_) &&\n        D.as(Move)?.quantum.isIdentical(this.quantumD_SQ_)\n      ) {\n        if (grouping.amount !== 1) {\n          throw new Error(\n            \"Square-1 tuples cannot have an amount other than 1.\",\n          );\n        }\n        return [U as Move, D as Move]; // TODO: can we reuse the casting from above?\n      }\n    }\n    return null;\n  }\n}\nconst square1TupleFormatterInstance = new Square1TupleFormatter();\n\nexport class Grouping extends AlgCommon<Grouping> {\n  readonly #quantumWithAmount: QuantumWithAmount<Alg>;\n\n  constructor(algSource: FlexibleAlgSource, amount?: number) {\n    super();\n    const alg = experimentalEnsureAlg(algSource);\n    this.#quantumWithAmount = new QuantumWithAmount(alg, amount);\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsGrouping = other as Grouping;\n    return (\n      other.is(Grouping) &&\n      this.#quantumWithAmount.isIdentical(otherAsGrouping.#quantumWithAmount)\n    );\n  }\n\n  get alg(): Alg {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get experimentalRepetitionSuffix(): string {\n    return this.#quantumWithAmount.suffix();\n  }\n\n  invert(): Grouping {\n    return new Grouping(\n      this.#quantumWithAmount.quantum,\n      -this.#quantumWithAmount.amount,\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.#quantumWithAmount.experimentalExpand(iterDir, depth - 1);\n    }\n  }\n\n  static fromString(): Grouping {\n    throw new Error(\"unimplemented\");\n  }\n\n  toString(): string {\n    return (\n      square1TupleFormatterInstance.format(this) ??\n      `(${this.#quantumWithAmount.quantum.toString()})${this.#quantumWithAmount.suffix()}`\n    );\n  }\n\n  experimentalAsSquare1Tuple(): [moveU: Move, moveD: Move] | null {\n    return square1TupleFormatterInstance.tuple(this);\n  }\n\n  // toJSON(): GroupingJSON {\n  //   return {\n  //     type: \"grouping\",\n  //     alg: this.#quanta.quantum.toJSON(),\n  //   };\n  // }\n}\n","import type { Alg } from \"./Alg\";\nimport {\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n} from \"./units\";\n\nexport function experimentalIs(\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  v: any,\n  c:\n    | typeof Alg\n    | typeof Grouping\n    | typeof LineComment\n    | typeof Commutator\n    | typeof Conjugate\n    | typeof Move\n    | typeof Newline\n    | typeof Pause,\n): boolean {\n  return v instanceof c;\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function experimentalIsUnit(v: any): boolean {\n  return (\n    experimentalIs(v, Grouping) ||\n    experimentalIs(v, LineComment) ||\n    experimentalIs(v, Commutator) ||\n    experimentalIs(v, Conjugate) ||\n    experimentalIs(v, Move) ||\n    experimentalIs(v, Newline) ||\n    experimentalIs(v, Pause)\n  );\n}\n","import type { Alg } from \"./Alg\";\nimport { Grouping } from \"./units/containers/Grouping\";\nimport type { Comparable } from \"./common\";\nimport { Commutator } from \"./units/containers/Commutator\";\nimport { Move, QuantumMove } from \"./units/leaves/Move\";\nimport { Newline } from \"./units/leaves/Newline\";\nimport { Pause } from \"./units/leaves/Pause\";\nimport { Conjugate } from \"./units/containers/Conjugate\";\nimport { LineComment } from \"./units/leaves/LineComment\";\nimport type { Unit } from \"./units/Unit\";\n\nfunction dispatch<DataDown, DataAlgUp, DataUnitUp>(\n  t: TraversalDownUp<DataDown, DataAlgUp, DataUnitUp>,\n  unit: Unit,\n  dataDown: DataDown,\n): DataUnitUp {\n  // TODO: Can we turn this back into a `switch` or something more efficiently?\n  if (unit.is(Grouping)) {\n    return t.traverseGrouping(unit as Grouping, dataDown);\n  }\n  if (unit.is(Move)) {\n    return t.traverseMove(unit as Move, dataDown);\n  }\n  if (unit.is(Commutator)) {\n    return t.traverseCommutator(unit as Commutator, dataDown);\n  }\n  if (unit.is(Conjugate)) {\n    return t.traverseConjugate(unit as Conjugate, dataDown);\n  }\n  if (unit.is(Pause)) {\n    return t.traversePause(unit as Pause, dataDown);\n  }\n  if (unit.is(Newline)) {\n    return t.traverseNewline(unit as Newline, dataDown);\n  }\n  if (unit.is(LineComment)) {\n    return t.traverseLineComment(unit as LineComment, dataDown);\n  }\n  throw new Error(`unknown unit`);\n}\n\nfunction assertIsUnit(t: Comparable): Unit {\n  if (\n    t.is(Grouping) ||\n    t.is(Move) ||\n    t.is(Commutator) ||\n    t.is(Conjugate) ||\n    t.is(Pause) ||\n    t.is(Newline) ||\n    t.is(LineComment)\n  ) {\n    return t as Unit;\n  }\n  throw \"internal error: expected unit\"; // TODO: Make more helpful, add tests\n}\n\nexport abstract class TraversalDownUp<\n  DataDown,\n  DataAlgUp,\n  DataUnitUp = DataAlgUp,\n> {\n  // Immediate subclasses should overwrite this.\n  public traverseUnit(unit: Unit, dataDown: DataDown): DataUnitUp {\n    return dispatch(this, unit, dataDown);\n  }\n\n  public traverseIntoUnit(unit: Unit, dataDown: DataDown): Unit {\n    return assertIsUnit(this.traverseUnit(unit, dataDown) as any);\n  }\n\n  public abstract traverseAlg(alg: Alg, dataDown: DataDown): DataAlgUp;\n\n  public abstract traverseGrouping(\n    grouping: Grouping,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traverseMove(move: Move, dataDown: DataDown): DataUnitUp;\n\n  public abstract traverseCommutator(\n    commutator: Commutator,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traverseConjugate(\n    conjugate: Conjugate,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traversePause(pause: Pause, dataDown: DataDown): DataUnitUp;\n  public abstract traverseNewline(\n    newline: Newline,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traverseLineComment(\n    comment: LineComment,\n    dataDown: DataDown,\n  ): DataUnitUp;\n}\n\nexport abstract class TraversalUp<\n  DataAlgUp,\n  DataUnitUp = DataAlgUp,\n> extends TraversalDownUp<undefined, DataAlgUp, DataUnitUp> {\n  public traverseUnit(unit: Unit): DataUnitUp {\n    return dispatch<unknown, DataAlgUp, DataUnitUp>(this, unit, undefined);\n  }\n\n  public traverseIntoUnit(unit: Unit): Unit {\n    return assertIsUnit(this.traverseUnit(unit) as any);\n  }\n\n  public abstract traverseAlg(alg: Alg): DataAlgUp;\n  public abstract traverseGrouping(grouping: Grouping): DataUnitUp;\n  public abstract traverseMove(move: Move): DataUnitUp;\n  public abstract traverseCommutator(commutator: Commutator): DataUnitUp;\n  public abstract traverseConjugate(conjugate: Conjugate): DataUnitUp;\n  public abstract traversePause(pause: Pause): DataUnitUp;\n  public abstract traverseNewline(newline: Newline): DataUnitUp;\n  public abstract traverseLineComment(comment: LineComment): DataUnitUp;\n}\n\nexport interface SimplifyOptions {\n  collapseMoves?: boolean;\n  quantumMoveOrder?: (quantumMove: QuantumMove) => number;\n  depth?: number | null; // TODO: test\n}\n\n// TODO: Test that inverses are bijections.\nclass Simplify extends TraversalDownUp<SimplifyOptions, Generator<Unit>> {\n  static #newAmount(\n    move: Move,\n    deltaAmount: number,\n    options: SimplifyOptions,\n  ): number {\n    let newAmount = move.amount + deltaAmount;\n    if (options?.quantumMoveOrder) {\n      const order = options.quantumMoveOrder(move.quantum);\n      // Examples:\n      //  order 4  min -1 (e.g. cube)\n      //  order 5  min -2 (e.g. Megaminx)\n      //  order 3  min -1 (e.g. Pyraminx)\n      const min = Math.floor(order / 2) + 1 - order;\n      newAmount = (((newAmount % order) + order - min) % order) + min; // TODO\n    }\n    return newAmount;\n  }\n\n  // TODO: Handle\n  public *traverseAlg(alg: Alg, options: SimplifyOptions): Generator<Unit> {\n    if (options.depth === 0) {\n      yield* alg.units();\n      return;\n    }\n\n    const newUnits: Unit[] = [];\n    let lastUnit: Unit | null = null;\n    const collapseMoves = options?.collapseMoves ?? true;\n    function appendMoveWithNewAmount(move: Move, deltaAmount: number): boolean {\n      const newAmount = Simplify.#newAmount(move, deltaAmount, options);\n      if (newAmount === 0) {\n        return false;\n      }\n      const newMove = new Move(move.quantum, newAmount);\n      newUnits.push(newMove);\n      lastUnit = newMove;\n      return true;\n    }\n    function appendCollapsed(newUnit: Unit) {\n      if (\n        collapseMoves &&\n        lastUnit?.is(Move) &&\n        newUnit.is(Move) &&\n        (lastUnit as Move).quantum.isIdentical((newUnit as Move).quantum)\n      ) {\n        newUnits.pop();\n        if (\n          !appendMoveWithNewAmount(lastUnit as Move, (newUnit as Move).amount)\n        ) {\n          lastUnit = newUnits.slice(-1)[0];\n        }\n      } else {\n        if (newUnit.is(Move)) {\n          appendMoveWithNewAmount(newUnit as Move, 0);\n        } else {\n          newUnits.push(newUnit);\n          lastUnit = newUnit;\n        }\n      }\n    }\n\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    for (const unit of alg.units()) {\n      for (const ancestorUnit of this.traverseUnit(unit, newOptions)) {\n        appendCollapsed(ancestorUnit);\n      }\n    }\n    for (const unit of newUnits) {\n      yield unit;\n    }\n  }\n\n  public *traverseGrouping(\n    grouping: Grouping,\n    options: SimplifyOptions,\n  ): Generator<Unit> {\n    if (options.depth === 0) {\n      yield grouping;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    yield new Grouping(this.traverseAlg(grouping.alg, newOptions));\n  }\n\n  public *traverseMove(move: Move, _options: SimplifyOptions): Generator<Unit> {\n    yield move;\n  }\n\n  public *traverseCommutator(\n    commutator: Commutator,\n    options: SimplifyOptions,\n  ): Generator<Unit> {\n    if (options.depth === 0) {\n      yield commutator;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    yield new Commutator(\n      this.traverseAlg(commutator.A, newOptions),\n      this.traverseAlg(commutator.B, newOptions),\n    );\n  }\n\n  public *traverseConjugate(\n    conjugate: Conjugate,\n    options: SimplifyOptions,\n  ): Generator<Unit> {\n    if (options.depth === 0) {\n      yield conjugate;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    yield new Conjugate(\n      this.traverseAlg(conjugate.A, newOptions),\n      this.traverseAlg(conjugate.B, newOptions),\n    );\n  }\n\n  public *traversePause(\n    pause: Pause,\n    _options: SimplifyOptions,\n  ): Generator<Unit> {\n    yield pause;\n  }\n\n  public *traverseNewline(\n    newline: Newline,\n    _options: SimplifyOptions,\n  ): Generator<Unit> {\n    yield newline;\n  }\n\n  public *traverseLineComment(\n    comment: LineComment,\n    _options: SimplifyOptions,\n  ): Generator<Unit> {\n    yield comment;\n  }\n}\n\nconst simplifyInstance = new Simplify();\nexport const simplify = simplifyInstance.traverseAlg.bind(simplifyInstance) as (\n  alg: Alg,\n  options: SimplifyOptions,\n) => Generator<Unit>;\n","import { AlgCommon, Comparable } from \"./common\";\nimport { experimentalIs, experimentalIsUnit } from \"./is\";\nimport { direct, IterationDirection, reverse } from \"./iteration\";\nimport { parseAlg } from \"./parse\";\nimport { simplify, SimplifyOptions } from \"./traversal\";\nimport { LineComment } from \"./units/leaves/LineComment\";\nimport { Move } from \"./units/leaves/Move\";\nimport { Newline } from \"./units/leaves/Newline\";\nimport type { LeafUnit, Unit } from \"./units/Unit\";\nimport { warnOnce } from \"./warnOnce\";\n\nexport type FlexibleAlgSource = string | Iterable<Unit> | Alg;\n\n// TODO: validate\nfunction toIterable(input?: FlexibleAlgSource): Iterable<Unit> {\n  if (!input) {\n    return [];\n  }\n\n  if (experimentalIs(input, Alg)) {\n    return (input as Alg).units();\n  }\n\n  if (typeof input === \"string\") {\n    return parseAlg(input).units(); // TODO: something more direct?\n  }\n\n  // const seq = inputUnits as Sequence;\n  // if (seq.type === \"sequence\" && seq.nestedUnits) {\n  //   throw new Error(\"unimplemented\");\n  //   // return seq.nestedUnits;\n  // }\n\n  const iter = input as Iterable<Unit>;\n  if (typeof iter[Symbol.iterator] === \"function\") {\n    return iter; // TODO: avoid allocations\n  }\n\n  throw \"Invalid unit\";\n}\n\n// Preserves the alg if it's already an `Alg`.\nexport function experimentalEnsureAlg(alg: FlexibleAlgSource): Alg {\n  if (experimentalIs(alg, Alg)) {\n    return alg as Alg;\n  }\n  return new Alg(alg);\n}\n\n/**\n * Alg is a class that encapsulated a structured alg. To create an alg from a string, use:\n *\n *     new Alg(\"R U R'\"); // Convenient\n *     Alg.fromString(dynamicString); // Recommended when handling dynamic input.\n *\n * Once you have an Alg, you can call methods to transform it:\n *\n *     new Alg(\"[[R: U], R U R2']\").expand().simplify().invert();\n *\n * To convert an Alg to a string, use .toString():\n *\n *     new Alg(\"R U F\").invert().toString();\n *\n * If you need to debug, you may also find it convenient to use .log():\n *\n *     if (alg.isIdentical(alg.invert())) {\n *       alg.log(\"A self-inverse!\")\n *     }\n *\n * For more information, see: {@link https://js.cubing.net/cubing/alg/}\n *\n */\nexport class Alg extends AlgCommon<Alg> {\n  // #debugString: string;\n  #units: Iterable<Unit>; // TODO: freeze?\n  constructor(alg?: FlexibleAlgSource) {\n    super();\n    this.#units = Array.from(toIterable(alg)); // TODO: can we avoid array-casting?\n    // this.#debugString = this.toString();\n\n    for (const unit of this.#units) {\n      if (!experimentalIsUnit(unit)) {\n        throw new Error(\"An alg can only contain units.\");\n      }\n    }\n  }\n\n  /**\n   * Checks whether this Alg is structurally identical to another Alg. This\n   * essentially means that they are written identically apart from whitespace.\n   *\n   *     const alg1 = new Alg(\"R U L'\");\n   *     const alg2 = new Alg(\"L U' R'\").invert();\n   *     // true\n   *     alg1.isIdentical(alg2);\n   *\n   *     // false\n   *     new Alg(\"[R, U]\").isIdentical(new Alg(\"R U R' U'\"));\n   *     // true\n   *     new Alg(\"[R, U]\").expand().isIdentical(new Alg(\"R U R' U'\"));\n   *\n   * Note that .isIdentical() efficiently compares algorithms, but mainly exists\n   * to help optimize code when the structure of an algorithm hasn't changed.\n   * There are many ways to write the \"same\" alg on most puzzles, but is\n   * *highly* recommended to avoid expanding two Alg instances to compare them,\n   * since that can easily slow your program to a crawl if someone inputs an alg\n   * containing a large repetition. In general, you should use `cubing/kpuzzle`\n   * to compare if two algs have the same effect on a puzzle.\n   *\n   * Also note that parser annotations are not take into account while comparing\n   * algs:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\")]);\n   *     // true, even though one of the algs has parser annotations\n   *     alg.isIdentical(new Alg(\"R U2\"))\n   *\n   */\n  isIdentical(other: Comparable): boolean {\n    const otherAsAlg = other as Alg;\n    if (!other.is(Alg)) {\n      return false;\n    }\n\n    // TODO: avoid converting to array\n    const l1 = Array.from(this.#units);\n    const l2 = Array.from(otherAsAlg.#units);\n    if (l1.length !== l2.length) {\n      return false;\n    }\n    for (let i = 0; i < l1.length; i++) {\n      if (!l1[i].isIdentical(l2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the inverse of the given alg.\n   *\n   * Note that that this does not make any assumptions about what puzzle the alg\n   * is for. For example, U2 is its own inverse on a cube, but U2' has the same\n   * effect U3 (and not U2) on Megaminx:\n   *\n   *     // Outputs: R U2' L'\n   *     new Alg(\"L U2 R'\").invert().log();\n   */\n  invert(): Alg {\n    // TODO: Handle newLines and comments correctly\n    // TODO: Make more efficient.\n    return new Alg(reverse(Array.from(this.#units).map((u) => u.invert())));\n  }\n\n  /** @deprecated Use {@link Alg.expand} instead. */\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    for (const unit of direct(this.#units, iterDir)) {\n      yield* unit.experimentalExpand(iterDir, depth);\n    }\n  }\n\n  /**\n   * Expands all Grouping, Commutator, and Conjugate parts nested inside the\n   * alg.\n   *\n   *     // F R U R' U' F'\n   *     new Alg(\"[F: [R, U]]\").expand().log();\n   *\n   *     // F [R, U] F'\n   *     new Alg(\"[F: [R, U]]\").expand(({ depth: 1 }).log();\n   *\n   * Avoid calling this on a user-provided alg unless the user explicitly asks\n   * to see the expanded alg. Otherwise, it's easy to make your program freeze\n   * when someone passes in an alg like: (R U)10000000\n   *\n   * Generally, if you want to perform an operation on an entire alg, you'll\n   * want to use something based on the `Traversal` mechanism, like countMoves()\n   * from `cubing/notation`.\n   */\n  expand(options?: { depth?: number }): Alg {\n    return new Alg(\n      this.experimentalExpand(\n        IterationDirection.Forwards,\n        options?.depth ?? Infinity,\n      ),\n    );\n  }\n\n  /** @deprecated */\n  *experimentalLeafMoves(): Generator<Move> {\n    for (const leaf of this.experimentalExpand()) {\n      if (leaf.is(Move)) {\n        yield leaf as Move;\n      }\n    }\n  }\n\n  concat(input: FlexibleAlgSource): Alg {\n    return new Alg(\n      Array.from(this.#units).concat(Array.from(toIterable(input))),\n    );\n  }\n\n  /** @deprecated */\n  experimentalIsEmpty(): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const _ of this.#units) {\n      return false;\n    }\n    return true;\n  }\n\n  static fromString(s: string): Alg {\n    return parseAlg(s);\n  }\n\n  *units(): Generator<Unit> {\n    for (const unit of this.#units) {\n      yield unit;\n    }\n  }\n\n  experimentalNumUnits(): number {\n    return Array.from(this.#units).length;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"sequence\";\n  }\n\n  // toJSON(): AlgJSON {\n  //   return {\n  //     type: \"alg\",\n  //     units: Array.from(this.#units) as UnitJSON[],\n  //   };\n  // }\n\n  /**\n   * Converts the Alg to a string:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\"), new Move(\"L\")])\n   *     // R U2 L\n   *     console.log(alg.toString())\n   */\n  toString(): string {\n    let output = \"\";\n    let previousUnit: Unit | null = null;\n    for (const unit of this.#units) {\n      if (previousUnit) {\n        output += spaceBetween(previousUnit, unit);\n        // console.log(\"l\", previousUnit.toString(), unit.toString(), output);\n      }\n      output += unit.toString();\n      previousUnit = unit;\n    }\n    return output;\n  }\n\n  // *experimentalExpand(options: ExperimentalExpandOptions): Generator<Unit> {\n  //   // if (options.depth === 0) {\n  //   //   yield* this.units();\n  //   //   return;\n  //   // }\n  //   // const newOptions = {\n  //   //   depth: options.depth ? options.depth - 1 : null,\n  //   // }; // TODO: avoid allocations?\n  //   // for (const unit of this.#units) {\n  //   //   yield* unit.experimentalExpandIntoAlg(newOptions);\n  //   // }\n  // }\n\n  simplify(options?: SimplifyOptions): Alg {\n    return new Alg(simplify(this, options ?? {}));\n  }\n}\n\nfunction spaceBetween(u1: Unit, u2: Unit): string {\n  if (u1.is(Newline) || u2.is(Newline)) {\n    return \"\";\n  }\n  if (u1.is(LineComment) && !u2.is(Newline)) {\n    return \"\\n\"; /// TODO\n  }\n  return \" \";\n}\n","// tslint:disable-next-line no-namespace // TODO: nested module\n\nimport { Alg } from \"./Alg\";\nimport { Grouping } from \"./units\";\nimport { Commutator } from \"./units/containers/Commutator\";\nimport { Conjugate } from \"./units/containers/Conjugate\";\nimport { Move } from \"./units/leaves/Move\";\nimport { Pause } from \"./units/leaves/Pause\";\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport const Example = {\n  Sune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -2),\n    new Move(\"R\", -1),\n  ]),\n\n  AntiSune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 2),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n  ]),\n\n  SuneCommutator: new Alg([\n    new Commutator(\n      new Alg([new Move(\"R\", 1), new Move(\"U\", 1), new Move(\"R\", -2)]),\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n    ),\n  ]),\n\n  Niklas: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"L\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"L\", 1),\n    new Move(\"U\", 1),\n  ]),\n\n  EPerm: new Alg([\n    new Move(\"x\", -1),\n    new Commutator(\n      new Alg([\n        new Conjugate(\n          new Alg([new Move(\"R\", 1)]),\n          new Alg([new Move(\"U\", -1)]),\n        ),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Commutator(\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Move(\"x\", 1),\n  ]),\n\n  FURURFCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"U\", 1)]),\n          new Alg([new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  APermCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"R\", 2)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"F\", 2)]),\n          new Alg([new Move(\"R\", -1), new Move(\"B\", -1), new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  FURURFMoves: new Alg([\n    new Move(\"F\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  TPerm: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", 1),\n    new Move(\"R\", 2),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  HeadlightSwaps: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Grouping(\n          new Alg([\n            new Commutator(\n              new Alg([new Move(\"R\", 1)]),\n              new Alg([new Move(\"U\", 1)]),\n            ),\n          ]),\n          3,\n        ),\n      ]),\n    ),\n  ]),\n\n  TriplePause: new Alg([new Pause(), new Pause(), new Pause()]),\n\n  // AllAlgParts: [\n  //   new Alg([new Move(\"R\", 1), new Move(\"U\", -1)]),\n  //   new Grouping(new Alg([new Move(\"F\", 1)]), 2),\n  //   // new Rotation(\"y\", -1),\n  //   new Move(\"R\", 2),\n  //   new Commutator(new Alg([new Move(\"R\", 2)]), new Alg([new Move(\"U\", 2)]), 2),\n  //   new Conjugate(new Alg([new Move(\"L\", 2)]), new Alg([new Move(\"D\", -1)]), 2),\n  //   new Pause(),\n  //   new Newline(),\n  //   new LineComment(\"line comment\"),\n  // ],\n};\n","import { Move } from \"./units/leaves/Move\";\n\nconst cubeKeyMapping: { [key: number]: Move } = {\n  73: new Move(\"R\"),\n  75: new Move(\"R'\"),\n  87: new Move(\"B\"),\n  79: new Move(\"B'\"),\n  83: new Move(\"D\"),\n  76: new Move(\"D'\"),\n  68: new Move(\"L\"),\n  69: new Move(\"L'\"),\n  74: new Move(\"U\"),\n  70: new Move(\"U'\"),\n  72: new Move(\"F\"),\n  71: new Move(\"F'\"),\n\n  78: new Move(\"x'\"),\n  67: new Move(\"l\"),\n  82: new Move(\"l'\"),\n  85: new Move(\"r\"),\n  77: new Move(\"r'\"),\n\n  88: new Move(\"d\"),\n  188: new Move(\"d'\"),\n\n  84: new Move(\"x\"),\n  89: new Move(\"x\"),\n  66: new Move(\"x'\"),\n  186: new Move(\"y\"),\n  59: new Move(\"y\"),\n  65: new Move(\"y'\"), // 186 is WebKit, 59 is Mozilla; see http://unixpapa.com/js/key.html\n  80: new Move(\"z\"),\n  81: new Move(\"z'\"),\n\n  90: new Move(\"M'\"),\n  190: new Move(\"M'\"),\n};\n\n// TODO: options about whether to ignore modifier keys (e.g. alt, ctrl).\n// TODO: Support different mappings.\n// TODO: Return BaseMove instead?\nexport function keyToMove(e: KeyboardEvent): Move | null {\n  if (e.altKey || e.ctrlKey) {\n    return null;\n  }\n\n  return cubeKeyMapping[e.keyCode] || null;\n}\n","import { Alg } from \"./Alg\";\nimport type { Move } from \"./units/leaves/Move\";\n\nexport function experimentalAppendMove(\n  alg: Alg,\n  newMove: Move,\n  options?: {\n    coalesce?: boolean; // defaults to false\n    mod?: number;\n  },\n): Alg {\n  const oldUnits = Array.from(alg.units());\n  const oldLastMove = oldUnits[oldUnits.length - 1] as Move | undefined;\n  if (\n    options?.coalesce &&\n    oldLastMove &&\n    oldLastMove.quantum &&\n    oldLastMove.quantum.isIdentical(newMove.quantum)\n  ) {\n    const newUnits = oldUnits.slice(0, oldUnits.length - 1);\n    let newAmount = oldLastMove.amount + newMove.amount;\n    const mod = options?.mod;\n    if (mod) {\n      newAmount = ((newAmount % mod) + mod) % mod;\n      if (newAmount * 2 > mod) {\n        newAmount -= mod;\n      }\n    }\n    if (newAmount !== 0) {\n      newUnits.push(oldLastMove.modified({ amount: newAmount }));\n    }\n    return new Alg(newUnits);\n  } else {\n    return new Alg([...oldUnits, newMove]);\n  }\n}\n"],"names":["$061a4b1b33fae4e3$var$FaceNameSwizzler","facenames","gripnames_arg","this","prefixFree","gripnames","i","length","j","startsWith","setGripNames","names","splitByFaceNames","s","r","at","currentMatch","substr","Error","push","joinByFaceIndices","list","sep","join","spinmatch","userinput","longname","e1","e2","found","j1","e","spinmatchv","endsWith","slice","unswizzle","upperCaseGrip","toUpperCase","g","$061a4b1b33fae4e3$var$NullMapper","notationToInternal","move","notationToExternal","$061a4b1b33fae4e3$var$FTONotationMapper","child","sw","family","innerLayer","outerLayer","$98KNc","Move","QuantumMove","amount","fam","substring","$061a4b1b33fae4e3$var$FaceRenamingMapper","internalNames","externalNames","convertString","grip","a","b","suffix","upper","isLowerCase","toLowerCase","convert","ngrip","$061a4b1b33fae4e3$var$MegaminxScramblingNotationMapper","Math","abs","$061a4b1b33fae4e3$var$NxNxNCubeMapper","slices","$061a4b1b33fae4e3$var$pyraminxFamilyMap","U","L","R","B","u","l","Uv","Lv","Rv","Bv","D","F","BL","BR","$061a4b1b33fae4e3$var$tetraminxFamilyMap","d","f","bl","br","$061a4b1b33fae4e3$var$pyraminxFamilyMapWCA","$061a4b1b33fae4e3$var$pyraminxExternalQuantumY","$061a4b1b33fae4e3$var$pyraminxInternalQuantumY","$061a4b1b33fae4e3$var$PyraminxNotationMapper","wcaHack","map","newFamilyWCA","newFamily","isIdentical","quantum","external","internal","Object","entries","external1","internal1","$061a4b1b33fae4e3$var$TetraminxNotationMapper","super","$061a4b1b33fae4e3$var$skewbFamilyMap","UL","UR","ULv","Fv","URv","Dv","$061a4b1b33fae4e3$var$skewbExternalQuantumX","$061a4b1b33fae4e3$var$skewbInternalQuantumX","$061a4b1b33fae4e3$var$skewbInternalQuantumXPrime","$061a4b1b33fae4e3$var$skewbExternalQuantumY","$061a4b1b33fae4e3$var$skewbInternalQuantumY","$061a4b1b33fae4e3$var$skewbInternalQuantumYPrime","$061a4b1b33fae4e3$var$skewbExternalQuantumZ","$061a4b1b33fae4e3$var$skewbInternalQuantumZ","$061a4b1b33fae4e3$var$skewbInternalQuantumZPrime","$061a4b1b33fae4e3$var$SkewbNotationMapper","$061a4b1b33fae4e3$export$49fe41a914eb071d","argv","argp","options","option","addRotations","allMoves","outerBlockMoves","vertexMoves","includeCornerOrbits","includeEdgeOrbits","fixedOrientation","includeCenterOrbits","excludeOrbits","split","moveList","optimizeOrbits","scrambleAmount","fixedPieceType","orientCenters","puzzleOrientation","JSON","parse","$061a4b1b33fae4e3$export$f4bd658db3408711","$061a4b1b33fae4e3$var$zeroCache","$061a4b1b33fae4e3$var$iotaCache","$061a4b1b33fae4e3$var$zeros","n","c","Array","$061a4b1b33fae4e3$var$iota","$061a4b1b33fae4e3$var$lcm","t","m","$061a4b1b33fae4e3$var$gcd","$061a4b1b33fae4e3$var$Perm","p","toString","mul","p2","rmul","inv","compareTo","toGap","cyc","seen","incyc","order","cs","$061a4b1b33fae4e3$var$PGOrbitDef","size","mod","reassemblySize","$061a4b1b33fae4e3$var$factorial","pow","$061a4b1b33fae4e3$var$lastGlobalDefinitionCounter","$061a4b1b33fae4e3$var$externalName","mapper","moveString","mv","fromString","mv2","$061a4b1b33fae4e3$var$PGOrbitsDef","orbitnames","orbitdefs","solved","movenames","moveops","transformToKTransformationData","mp","orbits","toKPuzzle","toKsolve","name","result","i1","appendDefinition","i2","name2","doinv","toKPuzzleDefinition","includemoves","start","numPieces","numOrientations","startTransformation","pieces","permutation","orientation","moves","i3","startStateData","optimize","neworbitnames","neworbitdefs","newsolved","newmoveops","om","du","$061a4b1b33fae4e3$var$DisjointUnion","changed","k","perm","ori","union","keepori","duo","o","j4","find","j5","nontriv","multiple","j2","h","j3","no","on","nv","remapVS","remap","killOri","$061a4b1b33fae4e3$var$VisibleState","_","$061a4b1b33fae4e3$var$PGTransform","scramble","getScrambleTransformation","pool","i4","floor","random","i5","ri","rj","rm","i6","$061a4b1b33fae4e3$var$_PGOrbit","orimod","newPerm","newOri","equal","toPerm","identicalPieces","done","v","isIdentity","zeroOris","nextNew","reassign","ov","useVS","concise","newori","kcache","$061a4b1b33fae4e3$var$PGOrbit","$061a4b1b33fae4e3$var$PGTransformBase","internalMul","newOrbits","internalInv","orbit","perms","mulScalar","heads","ah","bh","$061a4b1b33fae4e3$var$PGPuzzles","skewb","helicopter","dino","pyramorphix","mastermorphix","pyraminx","tetraminx","megaminx","gigaminx","teraminx","petaminx","examinx","zetaminx","yottaminx","pentultimate","starminx","chopasaurus","FTO","octastar","icosamate","$061a4b1b33fae4e3$var$eps","$061a4b1b33fae4e3$var$centermassface","face","$061a4b1b33fae4e3$export$5edfe12bb88684c8","sum","smul","$061a4b1b33fae4e3$var$solvethreeplanes","p1","p3","planes","intersect3","dt","q","dist","hypot","len","cross","dot","normalize","sqrt","makenormal","normalizeplane","sub","angle","acos","invrot","det3x3","a00","a01","a02","a10","a11","a12","a20","a21","a22","rotateplane","orthogonal","ab","ac","ad","pointrotation","unproject","rotatepoint","rotateface","det","side","x","cutface","inout","nface","kk","vk","r2","pt","cutfaces","faces","nfaces","faceside","sameplane","makecut","$061a4b1b33fae4e3$var$eps2","$061a4b1b33fae4e3$var$uniqueplanes","planerot","wasseen","$061a4b1b33fae4e3$var$getface","$061a4b1b33fae4e3$var$FactoredNumber","mult","multiply","$061a4b1b33fae4e3$export$f17eb225ad7d7738","disp","$061a4b1b33fae4e3$var$identity","sgs","sgsi","sgslen","Tk","Tklen","knutha","knuthb","resolve","none","sz","i7","tks","sollen","avgs","mults","cnt","lensum","avg","getsgs","$061a4b1b33fae4e3$var$Face","coords","get","off","centermass","sx","sy","rotate","rotateforward","$061a4b1b33fae4e3$var$FaceTree","left","right","collect","arr","leftfirst","$061a4b1b33fae4e3$var$eps3","$061a4b1b33fae4e3$var$findelement","$061a4b1b33fae4e3$export$6d6c096d5214295b","$061a4b1b33fae4e3$export$1f9f297c0a9a9cd1","puzzleName","filter","Boolean","shape","cuts","cutType","distance","parseFloat","$061a4b1b33fae4e3$export$898ad9435742d552","desc","parsed","pg","$061a4b1b33fae4e3$export$b89c271f50b83709","assign","allstickers","genperms","$061a4b1b33fae4e3$export$37497081d872df9","$061a4b1b33fae4e3$var$getmovename","geo","bits","inverted","movenameFamily","movenamePrefix","String","$061a4b1b33fae4e3$var$splitByFaceNames","facename","$061a4b1b33fae4e3$var$toCoords","maxdist","$061a4b1b33fae4e3$var$toFaceCoords","puzzleDescription","cmovesbyslice","duplicatedFaces","duplicatedCubies","fixedCubie","net","colors","faceorder","faceprecedence","notationMapper","addNotationMapper","setReidOrder","verbosity","grayCorners","grayCenters","grayEdges","puzzleOrientations","console","log","header","create","moveplanes","moveplanes2","cubies","s5","$061a4b1b33fae4e3$var$cube","$061a4b1b33fae4e3$var$octahedron","dx","dy","dd","ang","PI","cos","sin","$061a4b1b33fae4e3$var$icosahedron","d36","$061a4b1b33fae4e3$var$dodecahedron","rotations","ns","negns","$061a4b1b33fae4e3$var$closure","baseplane","baseplanerot","baseplanes","baseFaceCount","BB","C","A","E","BF","I","G","S","H","J","K","M","O","P","N","Q","baseface","zero","facenormal","edgenormal","vertexnormal","boundary","firstface","edgedistance","vertexdistance","cutplanes","intersects","sawface","sawedge","sawvertex","cut","normal","basefaces","faceplanes","vertexnames","edgenames","edgesperface","searchaddelement","el","jj","otherfaces","i8","facelist","facenametoindex","faceindextoname","neti","fi","ii","fn2","j6","of","i9","i10","faceplane","i11","midpoint","jjj","midpoint2","swizzler","i12","c1","c2","i13","st","j7","geonormals","edgename","vertexname","geonormalnames","rotation","moveplane","ft","tar","rval","i14","stickersperface","simplerot","cm","rotation1","finished","sortme","i15","cm2","sort","rot","f2","shortedge","keyface","keyface2","sfcc","fromCharCode","moveplaneset","moveplanesets","dv","keyface3","findface","key","facelisthash","face2","facecentermass","project2d","facen","edgen","targvec","edgen2","plane","x0","olen","y0","delta","cosr","sinr","x1","y1","rots","$061a4b1b33fae4e3$var$expandfaces","moveplanenormals","qnormal","moveplanenormal","q1","i16","goodnormal","sizes","moverotations","i17","q2","i18","reverse","sizes2","movesetorders","movesetgeos","gtype","i19","p0","neg","pos","geonormal","Map","i20","suff","s2","set","facetocubie","facetoord","values","cmall","looplimit","mini","minf","temp","getfaceindex","ofacelist","typenames","cubiesetnames","cubietypecounts","orbitoris","cubiesetnum","cubiesetnums","cubieordnums","cubieords","cubievaluemap","getcolorkey","cubienum","cubiesetcubies","i21","cubie","cubiekeymap","cubievalueid","facecnt","typectr","typename","queue","qg","cind","cubiecolorkey","moverotation","tq","reidorder","reidmap","mask","charCodeAt","cubieset","newmv","stringToBlockMove","re","RegExp","match","loslice","hislice","parseInt","amountstr","parseMove","bm","fullrotation","msi","geoname","firstgrip","parsemove","slicenum","slicecnts","bhi","axiscmoves","sc","cubiedone","i22","ocm","fi2","face1","face0","parsedmovelist","clear","getboundarygeometry","getmovesets","parsedmove","msg","dep","newr","graybyori","skipbyori","skipcubie","comment","writegap","os","getOrbitsDef","mvs","movename","ip","__","writeksolve","od","getKPuzzleDefinition","fortwisty","internalDefinition","experimentalPuzzleDescription","getMoveFromBits","moverange","setmoves","movesetorder","moveorbits","oris","slicecmoves","mperm","setnum","inc","oinc","ii1","lastId","omitSet","excludedSet","diffmvsets","setnames","setdefs","mps","addrot","moveset","i25","nn","cmp","i26","k1","k2","allbits","i27","j8","i28","i23","i24","k3","movesetgeo","movebits","mna","getScramble","getMovesAsPerms","showcanon","orders","commutes","permA","permB","curlev","nextlev","uniq","sti","nst","$061a4b1b33fae4e3$var$showcanon","getsolved","getOrientationRotation","desiredRotation","feature1name","z1","direction1","feature2name","x2","y2","z2","direction2","feature1","feature2","feature1geoname","feature2geoname","gn","r1","getInitial3DRotation","basefacecount","orientationDescription","generate2dmapping","w","trim","threed","twodshrink","extendedges","cosa","sina","ndx","polyn","edges","minx","miny","maxx","maxy","f0","f1","es","esi","min","max","xoff","yoff","geos","bg","edges2","initv","connectat","neti1","gfi","thisface","j9","caf0","epi","gf1","gf1i","otherface","k4","hix","hiy","sc2","fn","xoff2","xmul","generatesvg","mappt2d","drawedges","id","pts","color","colormap","facegeo","i29","facenum","fg","svg","cubieori","cubieord","get3d","stickers","i30","stickerColors","ord","fcoords","rotdist","isDup","grips","i31","coordinates","quantumMove","twodmapper","irot","bind","axis","textureMapper","getuv","getGeoNormal","divid","textForTwizzleExplorer","writeSchreierSims","tw","as","$061a4b1b33fae4e3$export$32c5b60afe204e84","orbitNames","lookupMove","pgmv","$6a79286bccd321dd$export$ec810cf44eb98f56","IterationDirection3","$6a79286bccd321dd$var$Comparable","is","$6a79286bccd321dd$var$AlgCommon","$6a79286bccd321dd$export$d32346616aa538f3","iterDir","from","$6a79286bccd321dd$export$845111c728f7985d","direction","$6a79286bccd321dd$var$reverseGenerator","$6a79286bccd321dd$var$_units","$6a79286bccd321dd$var$_A","$6a79286bccd321dd$var$_B","$6a79286bccd321dd$var$MAX_INT","$6a79286bccd321dd$export$d5b45e94760ffddd","$cks0r","__privateAdd","__privateGet","experimentalPushAlg","alg","units","experimentalNumUnits","toAlg","$6a79286bccd321dd$export$e5a7308a1ffbe909","reset","__privateSet","WeakMap","$6a79286bccd321dd$var$_A2","$6a79286bccd321dd$var$_B2","$6a79286bccd321dd$var$_Commutator","aSource","bSource","$6a79286bccd321dd$var$experimentalEnsureAlg","other","otherAsCommutator","invert","Forwards","depth","Infinity","experimentalExpand","Backwards","$6a79286bccd321dd$export$13a2aeb669e49c0","$6a79286bccd321dd$var$_text","$6a79286bccd321dd$var$_Conjugate","otherAsConjugate","$6a79286bccd321dd$export$21829b047cfb53df","$6a79286bccd321dd$var$_LineComment","commentText","includes","text","otherAsLineComment","_iterDir","_depth","$6a79286bccd321dd$export$e6476262d0d4122e","$6a79286bccd321dd$export$5e2e13009fd73086","$6a79286bccd321dd$export$59704c468e1a1527","$6a79286bccd321dd$var$parseIntWithEmptyFallback","emptyFallback","$6a79286bccd321dd$var$_input","$6a79286bccd321dd$var$_idx","$6a79286bccd321dd$var$amountRegex","$6a79286bccd321dd$var$moveStartRegex","$6a79286bccd321dd$var$quantumMoveRegex","$6a79286bccd321dd$var$commentTextRegex","$6a79286bccd321dd$var$square1PairStart","$6a79286bccd321dd$var$square1PairEnd","$6a79286bccd321dd$var$parseAlg","$6a79286bccd321dd$var$AlgParser","parseAlg","$6a79286bccd321dd$var$addCharIndices","startCharIndex","endCharIndex","parsedT","input","parseAlgWithStopping","mustBeAtEndOfInput","parseMoveImpl","parseQuantumMove","parseQuantumMoveImpl","stopBefore","algStartIdx","algEndIdx","algBuilder","crowded","mustNotBeCrowded","idx","mainLoop","savedCharIndex","tryConsumeNext","test","sq1PairStartMatch","tryRegex","topAmountString","savedCharIndexD","sq1PairEndMatch","parseRegex","uMove","$6a79286bccd321dd$export$e49a5ad3dd6df925","$6a79286bccd321dd$export$9bfa9ee45a81759e","dMove","$6a79286bccd321dd$export$3885c0af90651e94","mustConsumeNext","parseAmount","popNext","separator","outerLayerStr","innerLayerStr","hadEmptyAbsAmount","parseAmountAndTrackEmptyAbsAmount","parseMoveSuffix","modified","savedIdx","absAmountStr","primeStr","regex","exec","remaining","next","__privateWrapper","expected","$6a79286bccd321dd$var$warned","Set","$6a79286bccd321dd$var$warnOnce","has","warn","add","$6a79286bccd321dd$var$_family","$6a79286bccd321dd$var$_innerLayer","$6a79286bccd321dd$var$_outerLayer","$6a79286bccd321dd$var$_quantumWithAmount","$6a79286bccd321dd$var$QuantumWithAmount","Number","isInteger","absAmount","newIterDir","iterationDirection","flip","$6a79286bccd321dd$var$toggleDirection","$6a79286bccd321dd$var$_QuantumMove","freeze","$6a79286bccd321dd$var$parseQuantumMove","modifications","otherAsQuantumMove","$6a79286bccd321dd$var$_Move","args","otherAsMove","to","$6a79286bccd321dd$var$parseMove","type","$6a79286bccd321dd$var$_quantumWithAmount2","$6a79286bccd321dd$var$square1TupleFormatterInstance","quantumU_SQ_","quantumD_SQ_","format","grouping","amounts","tuple","quantumAlg","$6a79286bccd321dd$var$_Grouping","algSource","otherAsGrouping","experimentalRepetitionSuffix","experimentalAsSquare1Tuple","$6a79286bccd321dd$export$8f2093504a51c1a5","$6a79286bccd321dd$var$dispatch","unit","dataDown","traverseGrouping","traverseMove","traverseCommutator","traverseConjugate","traversePause","traverseNewline","traverseLineComment","$6a79286bccd321dd$var$assertIsUnit","$6a79286bccd321dd$var$_newAmount","$6a79286bccd321dd$var$newAmount_fn","$6a79286bccd321dd$export$5b23793b60fb4cfe","traverseUnit","traverseIntoUnit","$6a79286bccd321dd$export$78fadb44b4228be0","$6a79286bccd321dd$var$_Simplify","newUnits","lastUnit","collapseMoves","appendMoveWithNewAmount","deltaAmount","_a","newAmount","__privateMethod","call","newMove","newOptions","ancestorUnit","newUnit","pop","unit1","traverseAlg","_options","commutator","conjugate","pause","newline","$6a79286bccd321dd$var$Simplify","WeakSet","quantumMoveOrder","$6a79286bccd321dd$var$_units2","$6a79286bccd321dd$var$simplifyInstance","$6a79286bccd321dd$var$simplify","$6a79286bccd321dd$var$toIterable","iter","Symbol","iterator","$6a79286bccd321dd$var$_Alg","otherAsAlg","l1","l2","expand","leaf","concat","experimentalIsEmpty","output","previousUnit","$6a79286bccd321dd$var$spaceBetween","simplify","u1","u2","$6a79286bccd321dd$export$730b7873cfa7a92","oldUnits","oldLastMove","coalesce"],"version":3,"file":"puzzle-geometry.0190f2b3.js.map"}