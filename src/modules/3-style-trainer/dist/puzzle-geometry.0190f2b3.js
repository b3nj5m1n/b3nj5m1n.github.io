function t(t,e,s,n){Object.defineProperty(t,e,{get:s,set:n,enumerable:!0,configurable:!0})}var e=("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{}).parcelRequire4b33;e.register("wu2HC",(function(s,n){t(s.exports,"parseOptions",(()=>E)),t(s.exports,"parsePuzzleDescription",(()=>ht)),t(s.exports,"Quat",(()=>Z)),t(s.exports,"schreierSims",(()=>et)),t(s.exports,"getPG3DNamedPuzzles",(()=>ot)),t(s.exports,"getPuzzleDescriptionString",(()=>at)),t(s.exports,"getPuzzleGeometryByDesc",(()=>lt)),t(s.exports,"PuzzleGeometry",(()=>dt)),t(s.exports,"getPuzzleGeometryByName",(()=>ut)),t(s.exports,"PGNotation",(()=>vt));var i=e("98KNc"),r=class{constructor(t,e){this.facenames=t,this.prefixFree=!0,this.gripnames=[],e&&(this.gripnames=e);for(let e=0;this.prefixFree&&e<t.length;e++)for(let s=0;this.prefixFree&&s<t.length;s++)e!==s&&t[e].startsWith(t[s])&&(this.prefixFree=!1)}setGripNames(t){this.gripnames=t}splitByFaceNames(t){const e=[];let s=0;for(;s<t.length;){s>0&&s<t.length&&"_"===t[s]&&s++;let n=-1;for(let e=0;e<this.facenames.length;e++)t.substr(s).startsWith(this.facenames[e])&&(n<0||this.facenames[e].length>this.facenames[n].length)&&(n=e);if(!(n>=0))throw new Error("Could not split "+t+" into face names.");e.push(n),s+=this.facenames[n].length}return e}joinByFaceIndices(t){let e="";const s=[];for(let n=0;n<t.length;n++)s.push(e),s.push(this.facenames[t[n]]),this.prefixFree||(e="_");return s.join("")}spinmatch(t,e){if(t===e)return!0;try{const s=this.splitByFaceNames(t),n=this.splitByFaceNames(e);if(s.length!==n.length&&s.length<3)return!1;for(let t=0;t<s.length;t++){for(let e=0;e<t;e++)if(s[t]===s[e])return!1;let e=!1;for(let i=0;i<n.length;i++)if(s[t]===n[i]){e=!0;break}if(!e)return!1}return!0}catch(t){return!1}}spinmatchv(t,e){return t.endsWith("v")&&e.endsWith("v")?this.spinmatch(t.slice(0,t.length-1),e.slice(0,e.length-1)):this.spinmatch(t,e)}unswizzle(t){(t.endsWith("v")||t.endsWith("w"))&&t[0]<="Z"&&(t=t.slice(0,t.length-1));const e=t.toUpperCase();for(let t=0;t<this.gripnames.length;t++){const s=this.gripnames[t];if(this.spinmatch(e,s))return s}return t}},o=class{notationToInternal(t){return t}notationToExternal(t){return t}},a=class{constructor(t,e){this.child=t,this.sw=e}notationToInternal(t){if("T"===t.family&&void 0===t.innerLayer&&void 0===t.outerLayer)return new i.Move(new i.QuantumMove("FLRv",t.innerLayer,t.outerLayer),t.amount);return this.child.notationToInternal(t)}notationToExternal(t){let e=t.family;return e.length>0&&"v"===e[e.length-1]&&(e=e.substring(0,e.length-1)),this.sw.spinmatch(e,"FLUR")?new i.Move(new i.QuantumMove("T",t.innerLayer,t.outerLayer),t.amount):this.child.notationToExternal(t)}},h=class{constructor(t,e){this.internalNames=t,this.externalNames=e}convertString(t,e,s){let n="";(t.endsWith("v")||t.endsWith("v"))&&t<="_"&&(n=t.slice(t.length-1),t=t.slice(0,t.length-1));const i=t.toUpperCase();let r=!1;return t!==i&&(r=!0,t=i),t=s.joinByFaceIndices(e.splitByFaceNames(t)),r&&(t=t.toLowerCase()),t+n}convert(t,e,s){const n=t.family,r=this.convertString(n,e,s);return n===r?t:new i.Move(new i.QuantumMove(r,t.innerLayer,t.outerLayer),t.amount)}notationToInternal(t){return this.convert(t,this.externalNames,this.internalNames)}notationToExternal(t){return this.convert(t,this.internalNames,this.externalNames)}},l=class{constructor(t){this.child=t}notationToInternal(t){if(void 0===t.innerLayer&&void 0===t.outerLayer){if(1===Math.abs(t.amount)){if("R++"===t.family)return new i.Move(new i.QuantumMove("L",3,2),-2*t.amount);if("R--"===t.family)return new i.Move(new i.QuantumMove("L",3,2),2*t.amount);if("D++"===t.family)return new i.Move(new i.QuantumMove("U",3,2),-2*t.amount);if("D--"===t.family)return new i.Move(new i.QuantumMove("U",3,2),2*t.amount);if("R_PLUSPLUS_"===t.family)return new i.Move(new i.QuantumMove("L",3,2),-2*t.amount);if("D_PLUSPLUS_"===t.family)return new i.Move(new i.QuantumMove("U",3,2),-2*t.amount)}if("y"===t.family)return new i.Move("Uv",t.amount)}return this.child.notationToInternal(t)}notationToExternal(t){return"Uv"===t.family?new i.Move(new i.QuantumMove("y",t.innerLayer,t.outerLayer),t.amount):"Dv"===t.family?new i.Move("y",-t.amount):this.child.notationToExternal(t)}},u=class{constructor(t){this.slices=t}notationToInternal(t){const e=t.family;return t.innerLayer||t.outerLayer||("x"===e?t=new i.Move("Rv",t.amount):"y"===e?t=new i.Move("Uv",t.amount):"z"===e&&(t=new i.Move("Fv",t.amount)),1==(1&this.slices)&&("E"===e?t=new i.Move(new i.QuantumMove("D",(this.slices+1)/2),t.amount):"M"===e?t=new i.Move(new i.QuantumMove("L",(this.slices+1)/2),t.amount):"S"===e&&(t=new i.Move(new i.QuantumMove("F",(this.slices+1)/2),t.amount))),this.slices>2&&("e"===e?t=new i.Move(new i.QuantumMove("D",this.slices-1,2),t.amount):"m"===e?t=new i.Move(new i.QuantumMove("L",this.slices-1,2),t.amount):"s"===e&&(t=new i.Move(new i.QuantumMove("F",this.slices-1,2),t.amount)))),t}notationToExternal(t){const e=t.family;if(!t.innerLayer&&!t.outerLayer){if("Rv"===e)return new i.Move("x",t.amount);if("Uv"===e)return new i.Move("y",t.amount);if("Fv"===e)return new i.Move("z",t.amount);if("Lv"===e)return new i.Move("x",-t.amount);if("Dv"===e)return new i.Move("y",-t.amount);if("Bv"===e)return new i.Move("z",-t.amount)}return t}},c={U:"frl",L:"fld",R:"fdr",B:"dlr",u:"FRL",l:"FLD",r:"FDR",b:"DLR",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R"},f={U:"FRL",L:"FLD",R:"FDR",B:"DLR",u:"frl",l:"fld",r:"fdr",b:"dlr",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R",d:"d",f:"f",bl:"l",br:"r"},p={U:"FRL",L:"FLD",R:"FDR",B:"DLR"},m=new i.QuantumMove("y"),d=new i.QuantumMove("Dv"),v=class{constructor(t){this.child=t,this.wcaHack=!1,this.map=c}notationToInternal(t){if(this.wcaHack&&2===t.innerLayer&&null===t.outerLayer){const e=p[t.family];if(e)return new i.Move(new i.QuantumMove(e,t.innerLayer,t.outerLayer),t.amount)}const e=this.map[t.family];return e?new i.Move(new i.QuantumMove(e,t.innerLayer,t.outerLayer),t.amount):m.isIdentical(t.quantum)?new i.Move(d,-t.amount):null}notationToExternal(t){if(this.wcaHack&&2===t.innerLayer&&null===t.outerLayer)for(const[e,s]of Object.entries(p))if(this.child.spinmatch(t.family,s))return new i.Move(new i.QuantumMove(e,t.innerLayer,t.outerLayer),t.amount);for(const[e,s]of Object.entries(this.map))if(this.child.spinmatch(t.family,s))return new i.Move(new i.QuantumMove(e,t.innerLayer,t.outerLayer),t.amount);return d.isIdentical(t.quantum)?new i.Move(m,-t.amount):null}},g=class extends v{constructor(t){super(t),this.map=f}},w={U:"UBL",UL:"ULF",F:"UFR",UR:"URB",B:"DBL",D:"DFR",L:"DLF",R:"DRB",Uv:"UBLv",ULv:"ULFv",Fv:"UFRv",URv:"URBv",Bv:"DBLv",Dv:"DFRv",Lv:"DLFv",Rv:"DRBv"},b=new i.QuantumMove("x"),_=new i.QuantumMove("Rv"),x=new i.QuantumMove("Lv"),y=new i.QuantumMove("y"),M=new i.QuantumMove("Uv"),L=new i.QuantumMove("Dv"),z=new i.QuantumMove("z"),G=new i.QuantumMove("Fv"),R=new i.QuantumMove("Bv"),F=class{constructor(t){this.child=t}notationToInternal(t){if(t.innerLayer||t.outerLayer)return null;const e=w[t.family];return e?new i.Move(new i.QuantumMove(e,t.outerLayer,t.innerLayer),t.amount):b.isIdentical(t.quantum)?new i.Move(_,t.amount):y.isIdentical(t.quantum)?new i.Move(M,t.amount):z.isIdentical(t.quantum)?new i.Move(G,t.amount):null}notationToExternal(t){for(const[e,s]of Object.entries(w))if(this.child.spinmatchv(t.family,s))return new i.Move(new i.QuantumMove(e,t.innerLayer,t.outerLayer),t.amount);return _.isIdentical(t.quantum)?new i.Move(b,t.amount):x.isIdentical(t.quantum)?new i.Move(b,-t.amount):M.isIdentical(t.quantum)?new i.Move(y,t.amount):L.isIdentical(t.quantum)?new i.Move(y,-t.amount):G.isIdentical(t.quantum)?new i.Move(z,t.amount):R.isIdentical(t.quantum)?new i.Move(z,-t.amount):null}};function E(t){let e=0;const s={};for(;e<t.length&&"-"===t[e][0];){const n=t[e++];if("--rotations"===n)s.addRotations=!0;else if("--allmoves"===n)s.allMoves=!0;else if("--outerblockmoves"===n)s.outerBlockMoves=!0;else if("--vertexmoves"===n)s.vertexMoves=!0;else if("--nocorners"===n)s.includeCornerOrbits=!1;else if("--noedges"===n)s.includeEdgeOrbits=!1;else if("--noorientation"===n)s.fixedOrientation=!0;else if("--nocenters"===n)s.includeCenterOrbits=!1;else if("--omit"===n)s.excludeOrbits=t[e].split(","),e++;else if("--moves"===n)s.moveList=t[e].split(","),e++;else if("--optimize"===n)s.optimizeOrbits=!0;else if("--scramble"===n)s.scrambleAmount=100;else if("--fixcorner"===n)s.fixedPieceType="v";else if("--fixedge"===n)s.fixedPieceType="e";else if("--fixcenter"===n)s.fixedPieceType="f";else if("--orientcenters"===n)s.orientCenters=!0;else{if("--puzzleorientation"!==n)throw new Error("Bad option: "+n);s.puzzleOrientation=JSON.parse(t[e]),e++}}return{puzzleDescription:ht(t.slice(e).join(" ")),options:s}}var S=[],k=[];function B(t){if(!S[t]){const e=Array(t);for(let s=0;s<t;s++)e[s]=0;S[t]=e}return S[t]}function A(t){if(!k[t]){const e=Array(t);for(let s=0;s<t;s++)e[s]=s;k[t]=e}return k[t]}function U(t,e){return t/function(t,e){if(t>e){const s=t;t=e,e=s}for(;t>0;){const s=e%t;e=t,t=s}return e}(t,e)*e}var D=class{constructor(t){this.n=t.length,this.p=t}toString(){return"Perm["+this.p.join(" ")+"]"}mul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=t.p[this.p[s]];return new D(e)}rmul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=this.p[t.p[s]];return new D(e)}inv(){const t=Array(this.n);for(let e=0;e<this.n;e++)t[this.p[e]]=e;return new D(t)}compareTo(t){for(let e=0;e<this.n;e++)if(this.p[e]!==t.p[e])return this.p[e]-t.p[e];return 0}toGap(){const t=new Array,e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;const n=new Array;for(let t=s;!e[t];t=this.p[t])n.push(1+t),e[t]=!0;t.push("("+n.join(",")+")")}return t.join("")}order(){let t=1;const e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;let n=0;for(let t=s;!e[t];t=this.p[t])n++,e[t]=!0;t=U(t,n)}return t}},C=class{constructor(t,e){this.size=t,this.mod=e}reassemblySize(){return function(t){let e=1;for(;t>1;)e*=t,t--;return e}(this.size)*Math.pow(this.mod,this.size)}},I=0;function N(t,e){const s=i.Move.fromString(e),n=t.notationToExternal(s);return null===n||s===n?e:n.toString()}var O=class{constructor(t,e,s,n,i){this.orbitnames=t,this.orbitdefs=e,this.solved=s,this.movenames=n,this.moveops=i}transformToKTransformationData(t){const e={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]=t.orbits[s].toKPuzzle();return e}static transformToKTransformationData(t,e){const s={};for(let n=0;n<t.length;n++)s[t[n]]=e.orbits[n].toKPuzzle();return s}toKsolve(t,e=new o){const s=[];s.push("Name "+t),s.push("");for(let t=0;t<this.orbitnames.length;t++)s.push(`Set ${this.orbitnames[t]} ${this.orbitdefs[t].size} ${this.orbitdefs[t].mod}`);s.push(""),s.push("Solved");for(let t=0;t<this.orbitnames.length;t++)this.solved.orbits[t].appendDefinition(s,this.orbitnames[t],!1,!1);s.push("End");for(let t=0;t<this.movenames.length;t++){s.push("");let n=N(e,this.movenames[t]),i=!1;"'"===n[n.length-1]&&(i=!0,n=n.substring(0,n.length-1)),s.push("Move "+n);for(let e=0;e<this.orbitnames.length;e++)i?this.moveops[t].orbits[e].inv().appendDefinition(s,this.orbitnames[e],!0):this.moveops[t].orbits[e].appendDefinition(s,this.orbitnames[e],!0);s.push("End")}return s}toKPuzzleDefinition(t){const e={},s={};for(let t=0;t<this.orbitnames.length;t++){e[this.orbitnames[t]]={numPieces:this.orbitdefs[t].size,numOrientations:this.orbitdefs[t].mod};const n=this.solved.orbits[t].toKPuzzle();s[this.orbitnames[t]]={pieces:n.permutation,orientation:n.orientation}}const n={};if(t)for(let t=0;t<this.movenames.length;t++)n[this.movenames[t]]=this.transformToKTransformationData(this.moveops[t]);return{name:"PG3D #"+ ++I,orbits:e,startStateData:s,moves:n}}optimize(){const t=[],e=[],s=[],n=[];for(let t=0;t<this.moveops.length;t++)n.push([]);for(let i=0;i<this.orbitdefs.length;i++){const r=this.orbitdefs[i].mod,o=this.orbitdefs[i].size,a=new W(o),h=new Array(this.orbitdefs[i].size);for(let t=0;t<o;t++)h[t]=!1;for(let t=0;t<this.moveops.length;t++)for(let e=0;e<o;e++)this.moveops[t].orbits[i].perm[e]===e&&0===this.moveops[t].orbits[i].ori[e]||(h[e]=!0,a.union(e,this.moveops[t].orbits[i].perm[e]));let l=!0;if(r>1){l=!1;const t=new W(this.orbitdefs[i].size*r);for(let e=0;e<this.moveops.length;e++)for(let s=0;s<o;s++)if(this.moveops[e].orbits[i].perm[s]!==s||0!==this.moveops[e].orbits[i].ori[s])for(let n=0;n<r;n++)t.union(s*r+n,this.moveops[e].orbits[i].perm[s]*r+(n+this.moveops[e].orbits[i].ori[s])%r);for(let e=0;!l&&e<o;e++)for(let s=1;s<r;s++)t.find(e*r)===t.find(e*r+s)&&(l=!0);for(let t=0;!l&&t<o;t++)for(let e=0;e<t;e++)this.solved.orbits[i].perm[t]===this.solved.orbits[i].perm[e]&&(l=!0)}let u=-1,c=!1;for(let t=0;t<this.orbitdefs[i].size;t++)if(h[t]){const e=a.find(t);u<0?u=e:u!==e&&(c=!0)}for(let r=0;r<this.orbitdefs[i].size;r++){if(!h[r])continue;if(a.find(r)!==r)continue;const o=[],u=[];let f=0;for(let t=0;t<this.orbitdefs[i].size;t++)a.find(t)===r&&(o[f]=t,u[t]=f,f++);if(c?t.push(`${this.orbitnames[i]}_p${r}`):t.push(this.orbitnames[i]),l){e.push(new C(f,this.orbitdefs[i].mod)),s.push(this.solved.orbits[i].remapVS(o,f));for(let t=0;t<this.moveops.length;t++)n[t].push(this.moveops[t].orbits[i].remap(o,u,f))}else{e.push(new C(f,1)),s.push(this.solved.orbits[i].remapVS(o,f).killOri());for(let t=0;t<this.moveops.length;t++)n[t].push(this.moveops[t].orbits[i].remap(o,u,f).killOri())}}}return new O(t,e,new $(s),this.movenames,n.map((t=>new Q(t))))}scramble(t){this.solved=this.solved.mul(this.getScrambleTransformation(t))}getScrambleTransformation(t){t<100&&(t=100);const e=[];for(let t=0;t<this.moveops.length;t++)e[t]=this.moveops[t];for(let t=0;t<e.length;t++){const s=Math.floor(Math.random()*e.length),n=e[t];e[t]=e[s],e[s]=n}t<e.length&&(t=e.length);for(let s=0;s<t;s++){const t=Math.floor(Math.random()*e.length),s=Math.floor(Math.random()*e.length),n=Math.floor(Math.random()*this.moveops.length);e[t]=e[t].mul(e[s]).mul(this.moveops[n]),Math.random()<.1&&(e[t]=e[t].mul(this.moveops[n]))}let s=e[0];for(let t=1;t<e.length;t++)s=s.mul(e[t]);return s}reassemblySize(){let t=1;for(let e=0;e<this.orbitdefs.length;e++)t*=this.orbitdefs[e].reassemblySize();return t}},T=class{constructor(t,e,s){this.perm=t,this.ori=e,this.orimod=s}static e(t,e){return new T(A(t),B(t),e)}mul(t){const e=this.perm.length,s=new Array(e);if(1===this.orimod){for(let n=0;n<e;n++)s[n]=this.perm[t.perm[n]];return new T(s,this.ori,this.orimod)}{const n=new Array(e);for(let i=0;i<e;i++)s[i]=this.perm[t.perm[i]],n[i]=(this.ori[t.perm[i]]+t.ori[i])%this.orimod;return new T(s,n,this.orimod)}}inv(){const t=this.perm.length,e=new Array(t),s=new Array(t);for(let n=0;n<t;n++)e[this.perm[n]]=n,s[this.perm[n]]=(this.orimod-this.ori[n])%this.orimod;return new T(e,s,this.orimod)}equal(t){const e=this.perm.length;for(let s=0;s<e;s++)if(this.perm[s]!==t.perm[s]||this.ori[s]!==t.ori[s])return!1;return!0}killOri(){const t=this.perm.length;for(let e=0;e<t;e++)this.ori[e]=0;return this.orimod=1,this}toPerm(){const t=this.orimod;if(1===t)return new D(this.perm);const e=this.perm.length,s=new Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;e++)s[n*t+e]=t*this.perm[n]+(this.ori[n]+e)%t;return new D(s)}identicalPieces(){const t=[],e=this.perm.length,s=[];for(let n=0;n<e;n++){const i=this.perm[n];if(void 0===t[i]){const r=[n];t[i]=!0;for(let t=n+1;t<e;t++)this.perm[t]===i&&r.push(t);s.push(r)}}return s}order(){return this.toPerm().order()}isIdentity(){const t=this.perm.length;if(this.perm===A(t)&&this.ori===B(t))return!0;for(let e=0;e<t;e++)if(this.perm[e]!==e||0!==this.ori[e])return!1;return!0}zeroOris(){const t=this.perm.length;if(this.ori===B(t))return!0;for(let e=0;e<t;e++)if(0!==this.ori[e])return!1;return!0}remap(t,e,s){const n=new Array(s),i=new Array(s);for(let r=0;r<s;r++)n[r]=e[this.perm[t[r]]],i[r]=this.ori[t[r]];return new T(n,i,this.orimod)}remapVS(t,e){const s=new Array(e),n=new Array(e);let i=0;const r=[];for(let o=0;o<e;o++){const e=this.perm[t[o]];void 0===r[e]&&(r[e]=i++),s[o]=r[e],n[o]=this.ori[t[o]]}return new T(s,n,this.orimod)}appendDefinition(t,e,s,n=!0){if(!(n&&this.isIdentity()||(t.push(e),t.push(this.perm.map((t=>t+1)).join(" ")),this.zeroOris())))if(s){const e=new Array(this.ori.length);for(let t=0;t<e.length;t++)e[this.perm[t]]=this.ori[t];t.push(e.join(" "))}else t.push(this.ori.join(" "))}toKPuzzle(){const t=this.perm.length;return this.isIdentity()?(T.kcache[t]||(T.kcache[t]={permutation:A(t),orientation:B(t)}),T.kcache[t]):{permutation:this.perm,orientation:this.ori}}},P=T;P.kcache=[];var q=class{constructor(t){this.orbits=t}internalMul(t){const e=[];for(let s=0;s<this.orbits.length;s++)e.push(this.orbits[s].mul(t.orbits[s]));return e}internalInv(){const t=[];for(const e of this.orbits)t.push(e.inv());return t}equal(t){for(let e=0;e<this.orbits.length;e++)if(!this.orbits[e].equal(t.orbits[e]))return!1;return!0}killOri(){for(const t of this.orbits)t.killOri();return this}toPerm(){const t=new Array;let e=0;for(const s of this.orbits){const n=s.toPerm();t.push(n),e+=n.n}const s=new Array(e);e=0;for(const n of t){for(let t=0;t<n.n;t++)s[e+t]=e+n.p[t];e+=n.n}return new D(s)}identicalPieces(){const t=[];let e=0;for(const s of this.orbits){const n=s.orimod,i=s.identicalPieces();for(let s=0;s<i.length;s++)t.push(i[s].map((t=>t*n+e)));e+=n*s.perm.length}return t}order(){let t=1;for(const e of this.orbits)t=U(t,e.order());return t}},Q=class extends q{constructor(t){super(t)}mul(t){return new Q(this.internalMul(t))}mulScalar(t){if(0===t)return this.e();let e=this;for(t<0&&(e=e.inv(),t=-t);0==(1&t);)e=e.mul(e),t>>=1;if(1===t)return e;let s=e,n=this.e();for(;t>0;)1&t&&(n=n.mul(s)),t>1&&(s=s.mul(s)),t>>=1;return n}inv(){return new Q(this.internalInv())}e(){return new Q(this.orbits.map((t=>P.e(t.perm.length,t.orimod))))}},$=class extends q{constructor(t){super(t)}mul(t){return new $(this.internalMul(t))}},W=class{constructor(t){this.n=t,this.heads=new Array(t);for(let e=0;e<t;e++)this.heads[e]=e}find(t){let e=this.heads[t];return this.heads[e]===e||(e=this.find(this.heads[e]),this.heads[t]=e),e}union(t,e){const s=this.find(t),n=this.find(e);s<n?this.heads[n]=s:s>n&&(this.heads[s]=n)}};var j={"2x2x2":"c f 0","3x3x3":"c f 0.333333333333333","4x4x4":"c f 0.5 f 0","5x5x5":"c f 0.6 f 0.2","6x6x6":"c f 0.666666666666667 f 0.333333333333333 f 0","7x7x7":"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143","8x8x8":"c f 0.75 f 0.5 f 0.25 f 0","9x9x9":"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111","10x10x10":"c f 0.8 f 0.6 f 0.4 f 0.2 f 0","11x11x11":"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909","12x12x12":"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0","13x13x13":"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769","20x20x20":"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9","30x30x30":"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333","40x40x40":"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95",skewb:"c v 0","master skewb":"c v 0.275","professor skewb":"c v 0 v 0.38","compy cube":"c v 0.915641442663986",helicopter:"c e 0.707106781186547","curvy copter":"c e 0.83",dino:"c v 0.577350269189626","little chop":"c e 0",pyramorphix:"t e 0",mastermorphix:"t e 0.346184634065199",pyraminx:"t v 0.333333333333333 v 1.66666666666667",tetraminx:"t v 0.333333333333333","master pyraminx":"t v 0 v 1 v 2","master tetraminx":"t v 0 v 1","professor pyraminx":"t v -0.2 v 0.6 v 1.4 v 2.2","professor tetraminx":"t v -0.2 v 0.6 v 1.4","Jing pyraminx":"t f 0","master pyramorphix":"t e 0.866025403784437",megaminx:"d f 0.7",gigaminx:"d f 0.64 f 0.82",teraminx:"d f 0.64 f 0.76 f 0.88",petaminx:"d f 0.64 f 0.73 f 0.82 f 0.91",examinx:"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928",zetaminx:"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94",yottaminx:"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486",pentultimate:"d f 0","master pentultimate":"d f 0.1","elite pentultimate":"d f 0 f 0.145905",starminx:"d v 0.937962370425399","starminx 2":"d f 0.23606797749979","pyraminx crystal":"d f 0.447213595499989",chopasaurus:"d v 0","big chop":"d e 0","skewb diamond":"o f 0",FTO:"o f 0.333333333333333","master FTO":"o f 0.5 f 0","Christopher's jewel":"o v 0.577350269189626",octastar:"o e 0","Trajber's octahedron":"o v 0.433012701892219","radio chop":"i f 0",icosamate:"i v 0","icosahedron 2":"i v 0.18759247376021","icosahedron 3":"i v 0.18759247376021 e 0","icosahedron static faces":"i v 0.84","icosahedron moving faces":"i v 0.73","Eitan's star":"i f 0.61803398874989","2x2x2 + dino":"c f 0 v 0.577350269189626","2x2x2 + little chop":"c f 0 e 0","dino + little chop":"c v 0.577350269189626 e 0","2x2x2 + dino + little chop":"c f 0 v 0.577350269189626 e 0","megaminx + chopasaurus":"d f 0.61803398875 v 0","starminx combo":"d f 0.23606797749979 v 0.937962370425399"},K=1e-9;function H(t){let e=new Z(0,0,0,0);for(let s=0;s<t.length;s++)e=e.sum(t[s]);return e.smul(1/t.length)}function J(t,e,s,n){const i=n[t].intersect3(n[e],n[s]);if(!i)return i;for(let r=0;r<n.length;r++)if(r!==t&&r!==e&&r!==s){const t=n[r].b*i.b+n[r].c*i.c+n[r].d*i.d;if(n[r].a>0&&t>n[r].a||n[r].a<0&&t<n[r].a)return!1}return i}var Z=class{constructor(t,e,s,n){this.a=t,this.b=e,this.c=s,this.d=n}mul(t){return new Z(this.a*t.a-this.b*t.b-this.c*t.c-this.d*t.d,this.a*t.b+this.b*t.a+this.c*t.d-this.d*t.c,this.a*t.c-this.b*t.d+this.c*t.a+this.d*t.b,this.a*t.d+this.b*t.c-this.c*t.b+this.d*t.a)}toString(){return`Q[${this.a},${this.b},${this.c},${this.d}]`}dist(t){return Math.hypot(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}len(){return Math.hypot(this.a,this.b,this.c,this.d)}cross(t){return new Z(0,this.c*t.d-this.d*t.c,this.d*t.b-this.b*t.d,this.b*t.c-this.c*t.b)}dot(t){return this.b*t.b+this.c*t.c+this.d*t.d}normalize(){const t=Math.sqrt(this.dot(this));return new Z(this.a/t,this.b/t,this.c/t,this.d/t)}makenormal(){return new Z(0,this.b,this.c,this.d).normalize()}normalizeplane(){const t=Math.hypot(this.b,this.c,this.d);return new Z(this.a/t,this.b/t,this.c/t,this.d/t)}smul(t){return new Z(this.a*t,this.b*t,this.c*t,this.d*t)}sum(t){return new Z(this.a+t.a,this.b+t.b,this.c+t.c,this.d+t.d)}sub(t){return new Z(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}angle(){return 2*Math.acos(this.a)}invrot(){return new Z(this.a,-this.b,-this.c,-this.d)}det3x3(t,e,s,n,i,r,o,a,h){return t*(i*h-r*a)+e*(r*o-n*h)+s*(n*a-i*o)}rotateplane(t){const e=t.mul(new Z(0,this.b,this.c,this.d)).mul(t.invrot());return e.a=this.a,e}orthogonal(){const t=Math.abs(this.b),e=Math.abs(this.c),s=Math.abs(this.d);return t<e&&t<s?this.cross(new Z(0,1,0,0)).normalize():e<t&&e<s?this.cross(new Z(0,0,1,0)).normalize():this.cross(new Z(0,0,0,1)).normalize()}pointrotation(t){const e=this.normalize();if(t=t.normalize(),e.sub(t).len()<K)return new Z(1,0,0,0);let s=e.sum(t);s=s.len()<K?s.orthogonal():s.normalize();const n=e.cross(s);return n.a=e.dot(s),n}unproject(t){return this.sum(t.smul(-this.dot(t)/(this.len()*t.len())))}rotatepoint(t){return t.mul(this).mul(t.invrot())}rotateface(t){return t.map((t=>t.rotatepoint(this)))}intersect3(t,e){const s=this.det3x3(this.b,this.c,this.d,t.b,t.c,t.d,e.b,e.c,e.d);return!(Math.abs(s)<K)&&new Z(0,this.det3x3(this.a,this.c,this.d,t.a,t.c,t.d,e.a,e.c,e.d)/s,this.det3x3(this.b,this.a,this.d,t.b,t.a,t.d,e.b,e.a,e.d)/s,this.det3x3(this.b,this.c,this.a,t.b,t.c,t.a,e.b,e.c,e.a)/s)}side(t){return t>K?1:t<-1e-9?-1:0}cutface(t){const e=this.a;let s=0,n=null;for(let n=0;n<t.length;n++)s|=1<<this.side(t[n].dot(this)-e)+1;if(5==(5&s)){n=[];const s=t.map((t=>this.side(t.dot(this)-e)));for(let i=-1;i<=1;i+=2){const r=[];for(let n=0;n<t.length;n++){s[n]!==i&&0!==s[n]||r.push(t[n]);const o=(n+1)%t.length;if(s[n]+s[o]===0&&0!==s[n]){const s=t[n].dot(this)-e,i=s/(s-(t[o].dot(this)-e)),a=t[n].smul(1-i).sum(t[o].smul(i));r.push(a)}}n.push(r)}}return n}cutfaces(t){const e=[];for(let s=0;s<t.length;s++){const n=t[s],i=this.cutface(n);i?(e.push(i[0]),e.push(i[1])):e.push(n)}return e}faceside(t){const e=this.a;for(let s=0;s<t.length;s++){const n=this.side(t[s].dot(this)-e);if(0!==n)return n}throw new Error("Could not determine side of plane in faceside")}sameplane(t){const e=this.normalize(),s=t.normalize();return e.dist(s)<K||e.dist(s.smul(-1))<K}makecut(t){return new Z(t,this.b,this.c,this.d)}},V=1e-9;function X(t,e){const s=[],n=[];for(let i=0;i<e.length;i++){const r=t.rotateplane(e[i]);let o=!1;for(let t=0;t<s.length;t++)if(r.dist(s[t])<V){o=!0;break}o||(s.push(r),n.push(e[i]))}return n}function Y(t){const e=[];for(let s=1;s<t.length;s++)for(let n=s+1;n<t.length;n++){const i=J(0,s,n,t);if(i){let t=!1;for(let s=0;s<e.length;s++)if(i.dist(e[s])<V){t=!0;break}t||e.push(i)}}for(;;){let s=!1;for(let n=0;n<e.length;n++){const i=(n+1)%e.length;if(t[0].dot(e[n].cross(e[i]))<0){const t=e[n];e[n]=e[i],e[i]=t,s=!0}}if(!s)break}return e}var tt=class{constructor(){this.mult=[]}multiply(t){for(let e=2;e*e<=t;e++)for(;t%e==0;)void 0!==this.mult[e]?this.mult[e]++:this.mult[e]=1,t/=e;t>1&&(void 0!==this.mult[t]?this.mult[t]++:this.mult[t]=1)}toString(){let t="";for(let e=0;e<this.mult.length;e++)void 0!==this.mult[e]&&(""!==t&&(t+="*"),t+=e,this.mult[e]>1&&(t+=`^${this.mult[e]}`));return t}};function et(t,e){const s=t[0].p.length,n=function(t){return new D(A(t))}(s);let i=[],r=[],o=[],a=[],h=[];function l(t,e,s){a[t].push(e),h[t].push(s);for(let n=0;n<i[t].length;n++)i[t][n]&&u(t,i[t][n].mul(e),s+o[t][n])}function u(t,e,s){const n=e.p[t];if(!i[t][n]){i[t][n]=e,r[t][n]=e.inv(),o[t][n]=s;for(let n=0;n<a[t].length;n++)u(t,e.mul(a[t][n]),s+h[t][n]);return}const c=e.mul(r[t][n]);(function(t){for(let e=t.p.length-1;e>=0;e--){const s=t.p[e];if(s!==e){if(!i[e][s])return!1;t=t.mul(r[e][s])}}return!0})(c)||l(t-1,c,s+o[t][n])}return function(){i=[],r=[],a=[],o=[],h=[];for(let t=0;t<s;t++)i.push([]),r.push([]),o.push([]),a.push([]),h.push([]),i[t][t]=n,r[t][t]=n,o[t][t]=0;let u=0,c=1;for(let n=0;n<t.length;n++){l(s-1,t[n],1),c=1;let r=0,h=0;const f=[],p=new tt;for(let t=0;t<s;t++){let e=0,n=0;for(let r=0;r<s;r++)i[t][r]&&(e++,n+=o[t][r],t!==r&&u++);r+=a[t].length,c*=e,e>1&&p.multiply(e);const l=n/e;f.push(l),h+=l}e(`${n}: sz ${c} T ${r} sol ${h} none ${u} mults ${p.toString()}`)}return c}()}var st=class{constructor(t){this.coords=new Array(3*t.length);for(let e=0;e<t.length;e++)this.coords[3*e]=t[e].b,this.coords[3*e+1]=t[e].c,this.coords[3*e+2]=t[e].d;this.length=t.length}get(t){return new Z(0,this.coords[3*t],this.coords[3*t+1],this.coords[3*t+2])}centermass(){let t=0,e=0,s=0;for(let n=0;n<this.length;n++)t+=this.coords[3*n],e+=this.coords[3*n+1],s+=this.coords[3*n+2];return new Z(0,t/this.length,e/this.length,s/this.length)}rotate(t){const e=[];for(let s=0;s<this.length;s++)e.push(this.get(s).rotatepoint(t));return new st(e)}rotateforward(){const t=[];for(let e=1;e<this.length;e++)t.push(this.get(e));return t.push(this.get(0)),new st(t)}},nt=class{constructor(t,e,s){this.face=t,this.left=e,this.right=s}split(t){const e=t.cutface(this.face);return null!==e&&(void 0===this.left?(this.left=new nt(e[0]),this.right=new nt(e[1])):(this.left=this.left?.split(t),this.right=this.right?.split(t))),this}collect(t,e){return void 0===this.left?t.push(new st(this.face)):e?(this.left?.collect(t,!1),this.right?.collect(t,!0)):(this.right?.collect(t,!1),this.left?.collect(t,!0)),t}};var it=1e-9;function rt(t,e){for(let s=0;s<t.length;s++)if(t[s][0].dist(e)<it)return s;throw new Error("Element not found")}function ot(){return j}function at(t){return j[t]}function ht(t){const e=t.split(/ /).filter(Boolean);if(e.length%2==0)return null;const s=e[0];if("o"!==s&&"c"!==s&&"i"!==s&&"d"!==s&&"t"!==s)return null;const n=[];for(let t=1;t<e.length;t+=2){if("f"!==e[t]&&"v"!==e[t]&&"e"!==e[t])return null;n.push({cutType:e[t],distance:parseFloat(e[t+1])})}return{shape:s,cuts:n}}function lt(t,e={}){const s=ht(t);if(null===s)throw new Error("Could not parse the puzzle description");const n=new dt(s,Object.assign({},{allMoves:!0},e));return n.allstickers(),n.genperms(),n}function ut(t,e){return lt(j[t],e)}function ct(t,e,s){let n=!1;s-e[1]<e[0]&&(t=[t[2],t[3],t[0],t[1]],e=[s-e[1],s-e[0]],n=!0);let i=t[0],r="";if(0===e[0]&&e[1]===s)i+="v";else if(e[0]===e[1])e[1]>0&&(r=String(e[1]+1));else{if(0!==e[0])throw`We only support slice and outer block moves right now. ${e}`;i=i.toLowerCase(),e[1]>1&&(r=String(e[1]+1))}return[r+i,n]}function ft(t,e){const s=[];let n=0;for(;n<t.length;){n>0&&n<t.length&&"_"===t[n]&&n++;let i="";for(const s of e)t.substr(n).startsWith(s[1])&&s[1].length>i.length&&(i=s[1]);if(""===i)throw new Error("Could not split "+t+" into face names.");s.push(i),n+=i.length}return s}function pt(t,e){return[t.b/e,-t.c/e,t.d/e]}function mt(t,e){const s=[],n=t.length;for(let i=0;i<n;i++){const r=pt(t.get(n-i-1),e);s[3*i]=r[0],s[3*i+1]=r[1],s[3*i+2]=r[2]}return s}var dt=class{constructor(t,e){this.puzzleDescription=t,this.cmovesbyslice=[],this.duplicatedFaces=[],this.duplicatedCubies=[],this.fixedCubie=-1,this.net=[],this.colors=[],this.faceorder=[],this.faceprecedence=[],this.notationMapper=new o,this.addNotationMapper="",this.setReidOrder=!1;this.options=new class{constructor(t={}){this.verbosity=0,this.allMoves=!1,this.vertexMoves=!1,this.addRotations=!1,this.moveList=null,this.fixedOrientation=!1,this.fixedPieceType=null,this.orientCenters=!1,this.includeCornerOrbits=!0,this.includeCenterOrbits=!0,this.includeEdgeOrbits=!0,this.excludeOrbits=[],this.optimizeOrbits=!1,this.grayCorners=!1,this.grayCenters=!1,this.grayEdges=!1,this.puzzleOrientation=null,this.puzzleOrientations=null,this.scrambleAmount=0,Object.assign(this,t)}}(e),this.options.verbosity>0&&console.log(this.header("# ")),this.create(t)}create(t){const{shape:e,cuts:s}=t;this.moveplanes=[],this.moveplanes2=[],this.faces=[],this.cubies=[];let n=null;switch(e){case"c":n=function(){const t=Math.sqrt(.5);return[new Z(t,t,0,0),new Z(t,0,t,0)]}();break;case"o":n=function(){const t=Math.sqrt(.5);return[new Z(.5,.5,.5,.5),new Z(t,0,0,t)]}();break;case"i":n=function(){let t=1/6+Math.sqrt(5)/6,e=2/3+Math.sqrt(5)/3;const s=Math.sqrt(t*t+e*e);t/=s,e/=s;const n=2*Math.PI/6;return[new Z(Math.cos(n),t*Math.sin(n),e*Math.sin(n),0),new Z(Math.cos(n),-t*Math.sin(n),e*Math.sin(n),0)]}();break;case"t":n=[new Z(.5,.5,.5,.5),new Z(.5,.5,.5,-.5)];break;case"d":n=function(){const t=2*Math.PI/10;let e=.5+.3*Math.sqrt(5),s=.5+.1*Math.sqrt(5);const n=Math.sqrt(e*e+s*s);return e/=n,s/=n,[new Z(Math.cos(t),e*Math.sin(t),s*Math.sin(t),0),new Z(.5,.5,.5,.5)]}();break;default:throw new Error("Bad shape argument: "+e)}this.rotations=function(t){const e=[new Z(1,0,0,0)];for(let s=0;s<e.length;s++)for(let n=0;n<t.length;n++){const i=t[n].mul(e[s]),r=i.smul(-1);let o=!1;for(let t=0;t<e.length;t++)if(i.dist(e[t])<V||r.dist(e[t])<V){o=!0;break}o||e.push(i)}return e}(n),this.options.verbosity&&console.log("# Rotations: "+this.rotations.length);const i=n[0];this.baseplanerot=X(i,this.rotations);const o=this.baseplanerot.map((t=>i.rotateplane(t)));this.baseplanes=o,this.baseFaceCount=o.length;const a={4:[["F","D","L","R"]],6:[["F","D","L","U","R"],["R","F","","B",""]],8:[["F","D","L","R"],["D","F","BR",""],["BR","D","","BB"],["BB","BR","U","BL"]],12:[["U","F","","","",""],["F","U","R","C","A","L"],["R","F","","","E",""],["E","R","","BF","",""],["BF","E","BR","BL","I","D"]],20:[["R","C","F","E"],["F","R","L","U"],["L","F","A",""],["E","R","G","I"],["I","E","S","H"],["S","I","J","B"],["B","S","K","D"],["K","B","M","O"],["O","K","P","N"],["P","O","Q",""]]}[o.length];this.net=a,this.colors={4:{F:"#00ff00",D:"#ffff00",L:"#ff0000",R:"#0000ff"},6:{U:"#ffffff",F:"#00ff00",R:"#ff0000",D:"#ffff00",B:"#0000ff",L:"#ff8000"},8:{U:"#ffffff",F:"#ff0000",R:"#00bb00",D:"#ffff00",BB:"#1122ff",L:"#9524c5",BL:"#ff8800",BR:"#aaaaaa"},12:{U:"#ffffff",F:"#006633",R:"#ff0000",C:"#ffffd0",A:"#3399ff",L:"#660099",E:"#ff66cc",BF:"#99ff00",BR:"#0000ff",BL:"#ffff00",I:"#ff6633",D:"#999999"},20:{R:"#db69f0",C:"#178fde",F:"#23238b",E:"#9cc726",L:"#2c212d",U:"#177fa7",A:"#e0de7f",G:"#2b57c0",I:"#41126b",S:"#4b8c28",H:"#7c098d",J:"#7fe7b4",B:"#85fb74",K:"#3f4bc3",D:"#0ff555",M:"#f1c2c8",O:"#58d340",P:"#c514f2",N:"#14494e",Q:"#8b1be1"}}[o.length],this.faceorder={4:["F","D","L","R"],6:["U","D","F","B","L","R"],8:["F","BB","D","U","BR","L","R","BL"],12:["L","E","F","BF","R","I","U","D","BR","A","BL","C"],20:["L","S","E","O","F","B","I","P","R","K","U","D","J","A","Q","H","G","N","M","C"]}[o.length],this.options.verbosity>0&&console.log("# Base planes: "+o.length);const l=Y(o),u=new Z(0,0,0,0);this.options.verbosity>0&&console.log("# Face vertices: "+l.length);const c=o[0].makenormal(),f=l[0].sum(l[1]).makenormal(),p=l[0].makenormal(),m=new Z(1,c.b,c.c,c.d);this.options.verbosity>0&&console.log("# Boundary is "+m);const d=Y(X(m,this.rotations).map((t=>m.rotateplane(t))));this.edgedistance=d[0].sum(d[1]).smul(.5).dist(u),this.vertexdistance=d[0].dist(u);const v=[],g=[];let w=!1,b=!1,_=!1;for(const t of s){let e=null,s=0;switch(t.cutType){case"f":e=c,s=1,w=!0;break;case"v":e=p,s=this.vertexdistance,_=!0;break;case"e":e=f,s=this.edgedistance,b=!0;break;default:throw new Error("Bad cut argument: "+t.cutType)}v.push(e.makecut(t.distance)),g.push(t.distance<s)}this.options.addRotations&&(w||v.push(c.makecut(10)),_||v.push(p.makecut(10)),b||v.push(f.makecut(10))),this.basefaces=[];for(const t of this.baseplanerot){const e=t.rotateface(d);this.basefaces.push(new st(e))}const x=[],y=[],M=[],L=[],z=d.length;function G(t,e,s){for(const n of t)if(n[0].dist(e)<it)return void n.push(s);t.push([e,s])}for(let t=0;t<this.baseplanerot.length;t++){const e=this.baseplanerot[t].rotateface(d);for(let s=0;s<e.length;s++){const n=(s+1)%e.length;G(L,e[s].sum(e[n]).smul(.5),t)}}const R=[];for(let t=0;t<this.baseplanerot.length;t++){const e=this.baseplanerot[t].rotateface(d),s=[];for(let n=0;n<e.length;n++){const i=(n+1)%e.length,r=L[rt(L,e[n].sum(e[i]).smul(.5))];if(t===r[1])s.push(r[2]);else{if(t!==r[2])throw new Error("Could not find edge");s.push(r[1])}}R.push(s)}const F={},E=[];E.push(a[0][0]),F[a[0][0]]=0,E[R[0][0]]=a[0][1],F[a[0][1]]=R[0][0];for(const t of a){const e=F[t[0]];if(void 0===e)throw new Error("Bad edge description; first edge not connected");let s=-1;for(let n=0;n<R[e].length;n++){const i=E[R[e][n]];if(void 0!==i&&i===t[1]){s=n;break}}if(s<0)throw new Error("First element of a net not known");for(let n=2;n<t.length;n++){if(""===t[n])continue;const i=R[e][(n+s-1)%z],r=E[i];if(void 0!==r&&r!==t[n])throw new Error("Face mismatch in net");E[i]=t[n],F[t[n]]=i}}for(let t=0;t<E.length;t++){let e=!1;for(let s=0;s<this.faceorder.length;s++)if(E[t]===this.faceorder[s]){this.faceprecedence[t]=s,e=!0;break}if(!e)throw new Error("Could not find face "+E[t]+" in face order list "+this.faceorder)}for(let t=0;t<this.baseplanerot.length;t++){const e=this.baseplanerot[t].rotateface(d),s=m.rotateplane(this.baseplanerot[t]),n=E[t];x.push([e,n]),y.push([s,n])}for(let t=0;t<this.baseplanerot.length;t++){const e=this.baseplanerot[t].rotateface(d),s=E[t];for(let t=0;t<e.length;t++){const n=(t+1)%e.length,i=e[t].sum(e[n]).smul(.5),r=(t+2)%e.length,o=e[n].sum(e[r]).smul(.5),a=rt(L,i),h=rt(L,o);G(M,e[n],[s,h,a])}}this.swizzler=new r(x.map((t=>t[1])));const S=this.swizzler.prefixFree?"":"_";for(let t=0;t<L.length;t++){if(3!==L[t].length)throw new Error("Bad length in edge names "+L[t]);let e=E[L[t][1]];const s=E[L[t][2]];e=this.faceprecedence[L[t][1]]<this.faceprecedence[L[t][2]]?e+S+s:s+S+e,L[t]=[L[t][0],e]}for(let t=0;t<M.length;t++){if(M[t].length<4)throw new Error("Bad length in vertex names");let e=1;for(let s=2;s<M[t].length;s++)this.faceprecedence[F[M[t][s][0]]]<this.faceprecedence[F[M[t][e][0]]]&&(e=s);let s="";for(let n=1;n<M[t].length;n++){s=1===n?M[t][e][0]:s+S+M[t][e][0];for(let s=1;s<M[t].length;s++)if(M[t][e][1]===M[t][s][2]){e=s;break}}M[t]=[M[t][0],s]}this.options.verbosity>1&&(console.log("# Face precedence list: "+this.faceorder.join(" ")),console.log("# Face names: "+x.map((t=>t[1])).join(" ")),console.log("# Edge names: "+L.map((t=>t[1])).join(" ")),console.log("# Vertex names: "+M.map((t=>t[1])).join(" ")));const k=[];for(const t of y)k.push([t[0].makenormal(),t[1],"f"]);for(const t of L)k.push([t[0].makenormal(),t[1],"e"]);for(const t of M)k.push([t[0].makenormal(),t[1],"v"]);this.facenames=x,this.faceplanes=y,this.edgenames=L,this.vertexnames=M,this.geonormals=k;const B=k.map((t=>t[1]));this.swizzler.setGripNames(B),this.options.verbosity>0&&console.log("# Distances: face 1 edge "+this.edgedistance+" vertex "+this.vertexdistance);for(let t=0;t<v.length;t++)for(const e of this.rotations){const s=v[t].rotateplane(e);let n=!1;for(const t of this.moveplanes)if(s.sameplane(t)){n=!0;break}n||(this.moveplanes.push(s),g[t]&&this.moveplanes2.push(s))}let A=new nt(d);const U=this.moveplanes2.slice();let D=31;for(let t=0;t<U.length;t++){const e=t+Math.floor((U.length-t)*(D/65536));A=A.split(U[e]),U[e]=U[t],D=(1657*D+101)%65536}const C=A.collect([],!0);this.faces=C,this.options.verbosity>0&&console.log("# Faces is now "+C.length),this.stickersperface=C.length;const I=[],N=H(d);for(const t of this.rotations){const e=t.rotateface(d);N.dist(H(e))<it&&I.push(t)}const O=new Array(C.length),T=[];for(let t=0;t<C.length;t++){const e=C[t].centermass();T.push([N.dist(e),e,t])}T.sort(((t,e)=>t[0]-e[0]));for(let t=0;t<C.length;t++){const e=T[t][2];if(!O[e]){O[e]=!0;for(const s of I){const n=C[e].rotate(s),i=n.centermass();for(let e=t+1;e<C.length&&!(T[e][0]-T[t][0]>it);e++){const t=T[e][2];if(!O[t]&&i.dist(T[e][1])<it){O[t]=!0,C[t]=n;break}}}}}this.shortedge=1e99;for(const t of C)for(let e=0;e<t.length;e++){const s=(e+1)%t.length,n=t.get(e).dist(t.get(s));n<this.shortedge&&(this.shortedge=n)}this.options.verbosity>0&&console.log("# Short edge is "+this.shortedge),"c"!==e||!w||b||_||(this.addNotationMapper="NxNxNCubeMapper",this.setReidOrder=!0),"c"!==e||!_||w||b||(this.addNotationMapper="SkewbMapper"),"t"!==e||!_&&!w||b||(this.addNotationMapper="PyraminxOrTetraminxMapper"),"o"===e&&w&&(this.notationMapper=new h(this.swizzler,new r(["F","D","L","BL","R","U","BR","B"])),b||_||(this.addNotationMapper="FTOMapper")),"d"===e&&w&&(this.addNotationMapper="MegaminxMapper",this.notationMapper=new h(this.swizzler,new r(["U","F","L","BL","BR","R","FR","FL","DL","B","DR","D"])))}keyface(t){return this.keyface2(t.centermass())}keyface2(t){let e="";const s=String.fromCharCode;for(const n of this.moveplanesets)if(n.length>0){const i=t.dot(n[0]);let r=0,o=1;for(;2*o<=n.length;)o*=2;for(;o>0;o>>=1)r+o<=n.length&&i>n[r+o-1].a&&(r+=o);if(r<47)e+=s(33+r);else if(r<2256)e=e+s(80+Math.floor(r/47)-1)+s(33+r%47);else{if(!(r<106079))throw Error("Too many slices for cubie encoding");e=e+s(80+Math.floor((r-47)/2209-1))+s(80+Math.floor((r-47)/47)%47)+s(33+r%47)}}return e}keyface3(t){const e=t.centermass(),s=[];for(const t of this.moveplanesets)if(t.length>0){const n=e.dot(t[0]);let i=0,r=1;for(;2*r<=t.length;)r*=2;for(;r>0;r>>=1)i+r<=t.length&&n>t[i+r-1].a&&(i+=r);s.push(i)}return s}findface(t){const e=this.keyface2(t),s=this.facelisthash.get(e);if(1===s.length)return s[0];for(let n=0;n+1<s.length;n++){const s=this.facelisthash.get(e)[n];if(Math.abs(t.dist(this.facecentermass[s]))<it)return s}return s[s.length-1]}project2d(t,e,s){const n=this.facenames[t][0],i=(e+1)%n.length,r=this.baseplanes[t];let o=n[i].sub(n[e]);const a=o.len();o=o.normalize();const h=o.cross(r).normalize();let l=s[1].sub(s[0]);const u=l.len()/a;l=l.normalize();const c=l.b,f=l.c,p=o.smul(c).sub(h.smul(f)).smul(u),m=h.smul(c).sum(o.smul(f)).smul(u),d=new Z(0,s[0].b-p.dot(n[e]),s[0].c-m.dot(n[e]),0);return[p,m,d]}allstickers(){this.faces=function(t,e){const s=[];for(const n of t)for(const t of e)s.push(t.rotate(n));return s}(this.baseplanerot,this.faces),this.options.verbosity>0&&console.log("# Total stickers is now "+this.faces.length),this.facecentermass=new Array(this.faces.length);for(let t=0;t<this.faces.length;t++)this.facecentermass[t]=this.faces[t].centermass();const t=[],e=[];for(const s of this.moveplanes){const n=s.makenormal();let i=!1;for(const t of e)n.sameplane(t.makenormal())&&(i=!0);i||(e.push(n),t.push([]))}for(const s of this.moveplanes2){const n=s.makenormal();for(let i=0;i<e.length;i++)if(n.sameplane(e[i])){t[i].push(s);break}}for(let s=0;s<t.length;s++){const n=t[s].map((t=>t.normalizeplane())),i=e[s];for(let t=0;t<n.length;t++)n[t].makenormal().dist(i)>it&&(n[t]=n[t].smul(-1));n.sort(((t,e)=>t.a-e.a)),t[s]=n}this.moveplanesets=t,this.moveplanenormals=e;const s=t.map((t=>t.length));this.options.verbosity>0&&console.log("# Move plane sets: "+s);const n=[];for(let e=0;e<t.length;e++)n.push([]);for(const s of this.rotations){if(Math.abs(Math.abs(s.a)-1)<it)continue;const i=s.makenormal();for(let r=0;r<t.length;r++)if(i.sameplane(e[r])){n[r].push(s);break}}this.moverotations=n;for(let t=0;t<n.length;t++){const s=n[t],i=s[0].makenormal();for(let t=0;t<s.length;t++)i.dist(s[t].makenormal())>it&&(s[t]=s[t].smul(-1));s.sort(((t,e)=>t.angle()-e.angle())),n[t][0].dot(e[t])<0&&s.reverse()}const i=n.map((t=>1+t.length));this.movesetorders=i;const r=[];let o="?";for(let s=0;s<t.length;s++){const n=e[s];let i=null,h=null;for(const t of this.geonormals){const e=n.dot(t[0]);Math.abs(e-1)<it?(h=[t[1],t[2]],o=t[2]):Math.abs(e+1)<it&&(i=[t[1],t[2]],o=t[2])}if(null===h||null===i)throw new Error("Saw positive or negative sides as null");r.push([h[0],h[1],i[0],i[1],1+t[s].length]),"NxNxNCubeMapper"===this.addNotationMapper&&"f"===o&&(this.notationMapper=new u(1+t[s].length),this.addNotationMapper=""),"SkewbMapper"===this.addNotationMapper&&1===t[0].length&&(this.notationMapper=new F(this.swizzler),this.addNotationMapper=""),"PyraminxOrTetraminxMapper"===this.addNotationMapper&&(2===t[0].length&&.333333333333333===t[0][0].a&&1.66666666666667===t[0][1].a?(this.notationMapper=new v(this.swizzler),this.addNotationMapper=""):(this.notationMapper=new g(this.swizzler),this.addNotationMapper="")),"MegaminxMapper"===this.addNotationMapper&&"f"===o&&(1+t[s].length===3&&(this.notationMapper=new l(this.notationMapper)),this.addNotationMapper=""),"FTOMapper"===this.addNotationMapper&&"f"===o&&(1+t[s].length===3&&(this.notationMapper=new a(this.notationMapper,this.swizzler)),this.addNotationMapper="")}this.movesetgeos=r;const h=new Map,c=this.faces;for(let t=0;t<c.length;t++){const e=c[t],s=this.keyface(e);if(h.get(s)){const e=h.get(s);if(e.push(t),e.length===this.baseFaceCount){this.options.verbosity>0&&console.log("# Splitting core.");for(let t=0;t<e.length;t++){const n=s+" "+t;h.set(n,[e[t]])}}}else h.set(s,[t])}this.facelisthash=h,this.options.verbosity>0&&console.log("# Cubies: "+h.size);const f=[],p=[],m=[];for(const t of h.values())if(t.length!==this.baseFaceCount){if(t.length>1){const e=t.map((t=>c[t].centermass())),s=H(e);for(let n=0;t.length>2;n++){let i=!1;for(let n=0;n<t.length;n++){const r=(n+1)%t.length;if(s.dot(e[n].cross(e[r]))<0){const s=e[n];e[n]=e[r],e[r]=s;const o=t[n];t[n]=t[r],t[r]=o,i=!0}}if(!i)break;if(n>1e3)throw new Error("Bad epsilon math; too close to border")}let n=0,i=t[n];for(let e=1;e<t.length;e++){const s=t[e];this.faceprecedence[this.getfaceindex(s)]<this.faceprecedence[this.getfaceindex(i)]&&(n=e,i=s)}if(0!==n){const e=t.slice();for(let s=0;s<t.length;s++)t[s]=e[(n+s)%t.length]}}for(let e=0;e<t.length;e++){const s=t[e];p[s]=f.length,m[s]=e}f.push(t)}this.cubies=f,this.facetocubie=p,this.facetoord=m;const d=["?","CENTERS","EDGES","CORNERS","C4RNER","C5RNER"],w=[],b=[0,0,0,0,0,0],_=[],x=[];let y=0;const M=[],L=[],z=[],G=[],R=t=>f[t].map((t=>this.getfaceindex(t))).join(" "),E=[];for(let t=0;t<f.length;t++){if(x[t])continue;const e=f[t];if(0===e.length)continue;const s={};let i=0;z.push(0),E.push([]);const r=e.length,o=b[r]++;let a=d[r];void 0!==a&&r!==this.baseFaceCount||(a="CORE"),a+=0===o?"":o+1,w[y]=a,_[y]=r;const h=[t];let l=0;for(x[t]=!0;l<h.length;){const t=h[l++],r=R(t);if((e.length>1||void 0===s[r])&&(s[r]=i++),G[t]=s[r],M[t]=y,E[y].push(t),L[t]=z[y]++,h.length<this.rotations.length){const e=this.facecentermass[f[t][0]];for(const t of n){const s=this.facetocubie[this.findface(e.rotatepoint(t[0]))];x[s]||(h.push(s),x[s]=!0)}}}y++}if(this.setReidOrder&&4<=this.stickersperface&&this.stickersperface<=9){const t=[["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],["UFR","URB","UBL","ULF","DRF","DFL","DLB","DBR"],["U","L","F","R","B","D"]],e={};for(const s of t)for(let t=0;t<s.length;t++){let n=0;for(let e=0;e<s[t].length;e++)n|=1<<s[t].charCodeAt(e)-65;e[n]=t}for(const t of E)for(const s of t){let t=0;for(const e of f[s])t|=1<<this.facenames[this.getfaceindex(e)][1].charCodeAt(0)-65;L[s]=e[t]}}if(this.cubiesetnums=M,this.cubieordnums=L,this.cubiesetnames=w,this.cubieords=z,this.orbitoris=_,this.cubievaluemap=G,this.cubiesetcubies=E,null!==this.options.fixedPieceType){for(let t=0;t<f.length;t++)if("v"===this.options.fixedPieceType&&f[t].length>2||"e"===this.options.fixedPieceType&&2===f[t].length||"f"===this.options.fixedPieceType&&1===f[t].length){this.fixedCubie=t;break}if(this.fixedCubie<0)throw new Error("Could not find a cubie of type "+this.options.fixedPieceType+" to fix.")}this.options.verbosity>0&&console.log("# Cubie orbit sizes "+z)}unswizzle(t){const e=this.notationMapper.notationToInternal(t);return null===e?"":this.swizzler.unswizzle(e.family)}stringToBlockMove(t){const e=RegExp("^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$"),s=t.match(e);if(null===s)throw new Error("Bad move passed "+t);const n=s[4];let r,o;if(void 0!==s[2]){if(void 0===s[3])throw new Error("Missing second number in range");r=parseInt(s[2],10)}void 0!==s[3]&&(o=parseInt(s[3],10));let a="1",h=1;return void 0!==s[5]&&(a=s[5],"'"===a[0]&&(a="-"+a.substring(1)),h=parseInt(a,10)),new i.Move(new i.QuantumMove(n,o,r),h)}parseMove(t){const e=this.notationMapper.notationToInternal(t);if(null===e)throw new Error("Bad move "+t.family);let s,n=(t=e).family,i=!1;if(n.endsWith("v")&&n[0]<="Z"){if(void 0!==t.innerLayer||void 0!==t.outerLayer)throw new Error("Cannot use a prefix with full cube rotations");n=n.slice(0,-1),i=!0}n.endsWith("w")&&n[0]<="Z"&&(n=n.slice(0,-1).toLowerCase());let r=-1;const o=this.swizzler.unswizzle(n);let a=!1;for(let t=0;t<this.movesetgeos.length;t++){const e=this.movesetgeos[t];o===e[0]&&(a=!0,s=e,r=t),o===e[2]&&(a=!1,s=e,r=t)}let h=1,l=1;if(n.toUpperCase()!==n&&(l=2),void 0===s)throw new Error("Bad grip in move "+t.family);if(void 0!==t.outerLayer&&(h=t.outerLayer),void 0!==t.innerLayer&&(void 0===t.outerLayer?(l=t.innerLayer,h=n<="Z"?l:1):l=t.innerLayer),h--,l--,i&&(h=0,l=this.moveplanesets[r].length),h<0||h>this.moveplanesets[r].length||l<0||l>this.moveplanesets[r].length)throw new Error("Bad slice spec "+h+" "+l+" vs "+this.moveplanesets[r].length);if(0===h&&l===this.moveplanesets[r].length&&!i)throw new Error("! full puzzle rotations must be specified with v suffix.");return[void 0,r,h,l,a,t.amount]}parsemove(t){const e=this.parseMove(this.stringToBlockMove(t));return e[0]=t,e}genperms(){if(this.cmovesbyslice.length>0)return;const t=[];if(this.options.orientCenters)for(let t=0;t<this.cubies.length;t++)if(1===this.cubies[t].length){const e=this.cubies[t][0],s=this.getfaceindex(e);if(this.basefaces[s].centermass().dist(this.facecentermass[e])<it){const n=this.basefaces[s].length;for(let e=1;e<n;e++)this.cubies[t].push(this.cubies[t][e-1]);this.duplicatedFaces[e]=n,this.duplicatedCubies[t]=n,this.orbitoris[this.cubiesetnums[t]]=n}}for(let e=0;e<this.moveplanesets.length;e++){const s=this.moveplanesets[e],n=[],i=[s.length+1,0];let r=1;for(;2*r<=s.length;)r*=2;for(let t=0;t<this.faces.length;t++){let e=0;if(s.length>0){const n=this.facecentermass[t].dot(s[0]);for(let t=r;t>0;t>>=1)e+t<=s.length&&n>s[e+t-1].a&&(e+=t);e=s.length-e}for(n.push(e);i.length<=e;)i.push(0);i[e]++}const o=new Array(i.length);for(let t=0;t<i.length;t++)o[t]=[];const a=[];for(let t=0;t<this.faces.length;t++){if(n[t]<0)continue;const s=[this.facetocubie[t],this.facetoord[t]];let i=this.facecentermass[t];const r=i;let h=t;const l=n[h];for(;;){n[h]=-1;const t=i.rotatepoint(this.moverotations[e][0]);if(t.dist(r)<it)break;h=this.findface(t),s.push(this.facetocubie[h],this.facetoord[h]),i=t}if(s.length>2&&this.options.orientCenters&&(1===this.cubies[s[0]].length||this.duplicatedCubies[s[0]]>1)&&this.facecentermass[t].dist(this.basefaces[this.getfaceindex(t)].centermass())<it){let t=this.faces[this.cubies[s[0]][0]];for(let n=0;n<s.length;n+=2){const i=this.faces[this.cubies[s[n]][0]];let r=-1;for(let e=0;e<t.length;e++)if(i.get(e).dist(t.get(0))<it){r=e;break}if(r<0)throw new Error("Couldn't find rotation of center faces; ignoring for now.");s[n+1]=r,t=t.rotate(this.moverotations[e][0])}}if(2===s.length&&this.options.orientCenters)for(let t=1;t<this.movesetorders[e];t++)0===l?s.push(s[0],t):s.push(s[0],(this.movesetorders[e]-t)%this.movesetorders[e]);if(s.length>2&&!a[s[0]]){if(s.length!==2*this.movesetorders[e])throw new Error("Bad length in perm gen");for(const t of s)o[l].push(t)}for(let t=0;t<s.length;t+=2)a[s[t]]=!0}for(let t=0;t<o.length;t++)o[t]=o[t].slice();t.push(o)}if(this.cmovesbyslice=t,this.options.moveList){const t=[];for(const e of this.options.moveList)t.push(this.parsemove(e));this.parsedmovelist=t}this.facelisthash.clear(),this.facecentermass=[]}getboundarygeometry(){return{baseplanes:this.baseplanes,facenames:this.facenames,faceplanes:this.faceplanes,vertexnames:this.vertexnames,edgenames:this.edgenames,geonormals:this.geonormals}}getmovesets(t){const e=this.moveplanesets[t].length;let s=[];if(void 0!==this.parsedmovelist)for(const n of this.parsedmovelist)n[1]===t&&(n[4]?s.push([n[2],n[3]]):s.push([e-n[3],e-n[2]]),s.push(n[5]));else if(this.options.vertexMoves&&!this.options.allMoves){const n=this.movesetgeos[t];if(n[1]!==n[3])for(let t=0;t<e;t++)"v"!==n[1]?(this.options.outerBlockMoves?s.push([t+1,e]):s.push([t+1]),s.push(1)):(this.options.outerBlockMoves?s.push([0,t]):s.push([t,t]),s.push(1))}else for(let t=0;t<=e;t++)(this.options.allMoves||t+t!==e)&&(this.options.outerBlockMoves?t+t>e?s.push([t,e]):s.push([0,t]):s.push([t,t]),s.push(1));if(this.fixedCubie>=0){const n=this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[t],i=[];for(let t=0;t<s.length;t+=2){let r=s[t];if(n>=r[0]&&n<=r[1])if(0===r[0])r=[r[1]+1,e];else{if(e!==r[1])throw Error("fixed cubie option would disconnect move");r=[0,r[0]-1]}let o=!1;for(let e=0;e<i.length;e+=2)if(i[e][0]===r[0]&&i[e][1]===r[1]&&i[e+1]===s[t+1]){o=!0;break}o||(i.push(r),i.push(s[t+1]))}s=i}return s}graybyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),1===e&&(this.options.grayCenters||!this.options.includeCenterOrbits)||2===e&&(this.options.grayEdges||!this.options.includeEdgeOrbits)||e>2&&(this.options.grayCorners||!this.options.includeCornerOrbits)}skipbyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),1===e&&!this.options.includeCenterOrbits||2===e&&!this.options.includeEdgeOrbits||e>2&&!this.options.includeCornerOrbits}skipcubie(t){return this.skipbyori(t)}header(t){return t+"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\n"+t+"\n"}writegap(){const t=this.getOrbitsDef(!1),e=[],s=[];for(let n=0;n<t.moveops.length;n++){let i="M_"+N(this.notationMapper,t.movenames[n]),r=!1;"'"===i[i.length-1]&&(i=i.substring(0,i.length-1),r=!0),s.push(i),r?e.push(i+":="+t.moveops[n].toPerm().inv().toGap()+";"):e.push(i+":="+t.moveops[n].toPerm().toGap()+";")}e.push("Gen:=["),e.push(s.join(",")),e.push("];");const n=t.solved.identicalPieces();return e.push("ip:=["+n.map((t=>"["+t.map((t=>t+1)).join(",")+"]")).join(",")+"];"),e.push("# Size(Group(Gen));"),e.push("# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));"),e.push(""),this.header("# ")+e.join("\n")}writeksolve(t="PuzzleGeometryPuzzle"){const e=this.getOrbitsDef(!1);return this.header("# ")+e.toKsolve(t,this.notationMapper).join("\n")}getKPuzzleDefinition(t=!0,e=!0){const s=this.getOrbitsDef(t,e).toKPuzzleDefinition(e);if(s.experimentalPuzzleDescription=this.puzzleDescription,!s)throw new Error("Missing definition!");return s}getMoveFromBits(t,e,s,n,i,r){const o=[],a=[],h=[];for(const t of this.cubieords)a.push(A(t)),h.push(B(t));for(let e=t[0];e<=t[1];e++){const t=n[e];for(let e=0;e<t.length;e+=2*r){const n=t.slice(e,e+2*r),i=this.cubiesetnums[n[0]];for(let t=0;t<n.length;t+=2)n[t]=this.cubieordnums[n[t]];let o=2,l=3;s&&(o=n.length-2,l=n.length-1),a[i]===A(this.cubieords[i])&&(a[i]=a[i].slice(),this.orbitoris[i]>1&&!this.options.fixedOrientation&&(h[i]=h[i].slice()));for(let t=0;t<n.length;t+=2)a[i][n[(t+o)%n.length]]=n[t],this.orbitoris[i]>1&&!this.options.fixedOrientation&&(h[i][n[t]]=(n[(t+l)%n.length]-n[(t+1)%n.length]+2*this.orbitoris[i])%this.orbitoris[i])}}let l=new P(A(24),B(24),1);for(let t=0;t<this.cubiesetnames.length;t++)if(!i||i[t])if(1===this.orbitoris[t]||this.options.fixedOrientation)a[t]===A(l.perm.length)?(a[t]!==l.perm&&(l=new P(a[t],h[t],1)),o.push(l)):o.push(new P(a[t],h[t],1));else{const e=new Array(h[t].length);for(let s=0;s<a[t].length;s++)e[s]=h[t][a[t][s]];o.push(new P(a[t],e,this.orbitoris[t]))}let u=new Q(o);return 1!==e&&(u=u.mulScalar(e)),u}omitSet(t){for(const e of this.options.excludeOrbits)if(e===t)return!0;return!1}diffmvsets(t,e,s,n){for(let i=0;i<t.length;i+=2){let r=!1;for(let o=0;!r&&o<e.length;o+=2)n?t[i][0]+e[o][1]===s&&t[i][1]+e[o][0]===s&&t[i+1]===e[o+1]&&(r=!0):t[i][0]===e[o][0]&&t[i][1]===e[o][1]&&t[i+1]===e[o+1]&&(r=!0);if(!r)return!0}return!1}getOrbitsDef(t,e=!0){const s=[];if(t)for(let t=0;t<this.cubiesetnames.length;t++)s.push(1);const n=[],i=[],r=[],o=[];for(let t=0;t<this.moveplanesets.length;t++){const e=this.getmovesets(t);r.push(e),this.options.addRotations?o.push(1):o.push(0)}if(this.options.moveList&&this.options.addRotations){for(let t=0;t<this.moverotations.length;t++)o[t]=0;for(let t=0;t<this.moveplanesets.length;t++)for(let e=0;e<this.moverotations.length;e++){let s=this.moveplanenormals[t];for(let n=1;2*n<=this.movesetorders[e];n++){if(s=s.rotatepoint(this.moverotations[e][0]),o[e]&n)continue;let i=-1,a=!1;for(let t=0;t<this.moveplanenormals.length;t++){if(s.dist(this.moveplanenormals[t])<it){i=t;break}if(s.dist(this.moveplanenormals[t].smul(-1))<it){i=t,a=!0;break}}if(i<0)throw new Error("Could not find rotation");const h=r[i];(h.length!==r[t].length||this.moveplanesets[t].length!==this.moveplanesets[i].length||this.diffmvsets(h,r[t],this.moveplanesets[i].length,a))&&(o[e]|=n)}}for(let t=0;t<this.moverotations.length;t++)if(0===o[t])o[t]=1;else if(1===o[t])this.movesetorders[t]>3?o[t]=2:o[t]=0;else{if(3!==o[t])throw new Error("Impossible addrot val");o[t]=0}}for(let t=0;t<this.moveplanesets.length;t++)0!==o[t]&&(r[t].push([0,this.moveplanesets[t].length]),r[t].push(o[t]));for(let t=0;t<this.moveplanesets.length;t++){const e=r[t],n=this.movesetorders[t];for(let t=0;t<e.length;t+=2)for(let s=0;s<t;s+=2)if(e[t]===e[s]&&e[t+1]===e[s+1])throw new Error("Redundant moves in moveset.");const i=[];for(let t=0;t<e.length;t+=2)for(let s=e[t][0];s<=e[t][1];s++)i[s]=1;const o=this.cmovesbyslice[t];for(let t=0;t<o.length;t++){if(1!==i[t])continue;const e=o[t];for(let t=0;t<e.length;t+=2*n){if(this.skipcubie(e[t]))continue;s[this.cubiesetnums[e[t]]]=1}}}for(let t=0;t<this.cubiesetnames.length;t++)s[t]&&(this.omitSet(this.cubiesetnames[t])?s[t]=0:(n.push(this.cubiesetnames[t]),i.push(new C(this.cubieords[t],this.options.fixedOrientation?1:this.orbitoris[t]))));const a=[];for(let e=0;e<this.cubiesetnames.length;e++){if(!s[e])continue;if(this.omitSet(this.cubiesetnames[e]))continue;const n=[],i=[];for(let s=0;s<this.cubieords[e];s++){if(t)n.push(s);else{const t=this.cubiesetcubies[e][s];n.push(this.cubievaluemap[t])}i.push(0)}a.push(new P(n,i,this.options.fixedOrientation?1:this.orbitoris[e]))}const h=[],l=[];if(e)for(let t=0;t<this.moveplanesets.length;t++){const e=this.moveplanesets[t].length,n=r[t],i=this.movesetgeos[t];for(let r=0;r<n.length;r+=2){const o=n[r],a=ct(i,o,e),u=a[0],c=a[1];1===n[r+1]?h.push(u):h.push(u+n[r+1]);const f=this.getMoveFromBits(o,n[r+1],c,this.cmovesbyslice[t],s,this.movesetorders[t]);l.push(f)}}let u=new O(n,i,new $(a),h,l);return this.options.optimizeOrbits&&(u=u.optimize()),0!==this.options.scrambleAmount&&u.scramble(this.options.scrambleAmount),u}getScramble(t=0){const e=this.getOrbitsDef(!1);return e.transformToKTransformationData(e.getScrambleTransformation(t))}getMovesAsPerms(){return this.getOrbitsDef(!1).moveops.map((t=>t.toPerm()))}showcanon(t){!function(t,e){const s=t.moveops.length;if(s>30)throw new Error("Canon info too big for bitmask");const n=[],i=[];for(let e=0;e<s;e++){const r=t.moveops[e];n.push(r.order());let o=0;for(let n=0;n<s;n++){if(n===e)continue;const s=t.moveops[n];r.mul(s).equal(s.mul(r))&&(o|=1<<n)}i.push(o)}let r={0:1};for(let t=0;t<100;t++){let s=0;const o={};let a=0;for(const t in r){const e=+t,h=r[e];s+=h,a++;for(let t=0;t<n.length;t++)if(0==(e>>t&1)&&0==(e&i[t]&(1<<t)-1)){const s=e&i[t]|1<<t;void 0===o[s]&&(o[s]=0),o[s]+=(n[t]-1)*h}}e(`${t}: canonseq ${s} states ${a}`),r=o}}(this.getOrbitsDef(!1),t)}getsolved(){const t=[];for(let e=0;e<this.baseFaceCount;e++)for(let s=0;s<this.stickersperface;s++)t.push(e);return new D(t)}getOrientationRotation(t){const[e,[s,n,i]]=t[0],r=new Z(0,s,-n,i),[o,[a,h,l]]=t[1],u=new Z(0,a,-h,l);let c=null,f=null;const p=this.swizzler.unswizzle(e),m=this.swizzler.unswizzle(o);for(const t of this.geonormals)p===t[1]&&(c=t[0]),m===t[1]&&(f=t[0]);if(!c)throw new Error("Could not find feature "+e);if(!f)throw new Error("Could not find feature "+o);const d=c.pointrotation(r);return f.rotatepoint(d).unproject(r).pointrotation(u.unproject(r)).mul(d)}getInitial3DRotation(){const t=this.baseFaceCount;let e=null;if(this.options.puzzleOrientation?e=this.options.puzzleOrientation:this.options.puzzleOrientations&&(e=this.options.puzzleOrientations[t]),e||(e={4:[["FLR",[0,1,0]],["F",[0,0,1]]],6:[["U",[0,1,0]],["F",[0,0,1]]],8:[["U",[0,1,0]],["F",[0,0,1]]],12:[["U",[0,1,0]],["F",[0,0,1]]],20:[["GUQMJ",[0,1,0]],["F",[0,0,1]]]}[t]),!e)throw new Error("No default orientation?");return this.getOrientationRotation(e)}generate2dmapping(t=800,e=500,s=10,n=!1,i=.92){function r(t,e){let s=t[1][0]-t[0][0],n=t[1][1]-t[0][1];const i=2*Math.PI/e,r=Math.cos(i),o=Math.sin(i);for(let i=2;i<e;i++){const e=s*r+n*o;n=n*r-s*o,s=e,t.push([t[i-1][0]+s,t[i-1][1]+n])}}t-=2*s,e-=2*s,this.genperms();const o=this.getboundarygeometry().facenames[0][0].length,a=this.net;if(null===a)throw new Error("No net?");const h={};let l=0,u=0,c=1,f=0;h[a[0][0]]=[[1,0],[0,0]],r(h[a[0][0]],o);for(const t of a){const e=t[0];if(!h[e])throw new Error("Bad edge description; first edge not connected.");for(let s=1;s<t.length;s++){const n=t[s];""===n||h[n]||(h[n]=[h[e][s%o],h[e][(s+o-1)%o]],r(h[n],o))}}for(const t in h){const e=h[t];for(const t of e)l=Math.min(l,t[0]),c=Math.max(c,t[0]),u=Math.min(u,t[1]),f=Math.max(f,t[1])}const p=Math.min(t/(c-l),e/(f-u)),m=.5*(t-p*(c+l)),d=.5*(e-p*(f+u)),v={},g=this.getboundarygeometry(),w={},b=[[p+m,d],[m,d]];w[a[0][0]]=b,r(w[a[0][0]],o),v[this.facenames[0][1]]=this.project2d(0,0,[new Z(0,b[0][0],b[0][1],0),new Z(0,b[1][0],b[1][1],0)]);const _=[];_[0]=0;for(const t of a){const e=t[0];if(!w[e])throw new Error("Bad edge description; first edge not connected.");let s=-1;for(let t=0;t<g.facenames.length;t++)if(e===g.facenames[t][1]){s=t;break}if(s<0)throw new Error("Could not find first face name "+e);const n=g.facenames[s][0];for(let i=1;i<t.length;i++){const a=t[i];if(""===a||w[a])continue;w[a]=[w[e][i%o],w[e][(i+o-1)%o]],r(w[a],o);const h=_[s],l=n[(h+i)%o].sum(n[(h+i+o-1)%o]).smul(.5),u=rt(g.edgenames,l),c=ft(g.edgenames[u][1],this.facenames),f=c[e===c[0]?1:0];let p=-1;for(let t=0;t<g.facenames.length;t++)if(f===g.facenames[t][1]){p=t;break}if(p<0)throw new Error("Could not find second face name");const m=g.facenames[p][0];for(let t=0;t<m.length;t++){if(m[t].sum(m[(t+1)%o]).smul(.5).dist(l)<=it){const s=w[e][(i+o-1)%o],n=w[e][i%o];_[p]=t,v[f]=this.project2d(p,t,[new Z(0,n[0],n[1],0),new Z(0,s[0],s[1],0)]);break}}}}let x=0,y=0;const M=this.getInitial3DRotation();for(let t of this.faces){n&&(t=t.rotate(M));for(let e=0;e<t.length;e++)x=Math.max(x,Math.abs(t.get(e).b)),y=Math.max(y,Math.abs(t.get(e).c))}const L=Math.min(e/y/2,(t-s)/x/4);return(r,o)=>{if(n){o=o.rotatepoint(M);const n=.5*s+.25*t,i=this.baseplanes[r].rotateplane(M).d<0?1:-1;return[s+.5*t+i*(n-o.b*L),s+.5*e+o.c*L]}{const t=v[this.facenames[r][1]];return[s+i*o.dot(t[0])+t[2].b,s+e-i*o.dot(t[1])-t[2].c]}}}generatesvg(t=800,e=500,s=10,n=!1){const i=this.generate2dmapping(t,e,s,n);function r(t,e,s){return'<polygon id="'+t+'" class="sticker" style="fill: '+s+'" points="'+e.map((t=>t[0]+" "+t[1])).join(" ")+'"/>\n'}const o=this.getsolved(),a=[],h=[];for(let t=0;t<this.baseFaceCount;t++)a[t]=this.colors[this.facenames[t][1]];for(let t=0;t<this.faces.length;t++){const e=this.faces[t],s=Math.floor(t/this.stickersperface),n=[];for(let t=0;t<e.length;t++)n.push(i(s,e.get(t)));h.push(n)}const l=[];for(let t=0;t<this.baseFaceCount;t++){l.push("<g>"),l.push("<title>"+this.facenames[t][1]+"</title>\n");for(let e=0;e<this.stickersperface;e++){const s=t*this.stickersperface+e,n=this.facetocubie[s],i=this.facetoord[s],u=this.cubiesetnums[n],c=this.cubieordnums[n],f=this.graybyori(n)?"#808080":a[o.p[s]];let p=this.cubiesetnames[u]+"-l"+c+"-o"+i;if(l.push(r(p,h[s],f)),this.duplicatedFaces[s])for(let t=1;t<this.duplicatedFaces[s];t++)p=this.cubiesetnames[u]+"-l"+c+"-o"+t,l.push(r(p,h[s],f))}l.push("</g>")}return'<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">\n<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\n'+l.join("")+"</svg>"}get3d(t){const e=[],s=this.getInitial3DRotation(),n=[],r=.52*this.basefaces[0].get(0).len();for(let t=0;t<this.basefaces.length;t++){const e=this.basefaces[t].rotate(s),i=this.facenames[t][1];n.push({coords:mt(e,r),name:i})}for(let n=0;n<this.faces.length;n++){const i=Math.floor(n/this.stickersperface),o=this.facetocubie[n],a=this.facetoord[n],h=this.cubiesetnums[o],l=this.cubieordnums[o];let u=this.graybyori(o)?"#808080":this.colors[this.facenames[i][1]];t?.stickerColors&&(u=t.stickerColors[n]);const c=this.faces[n].rotate(s);e.push({coords:mt(c,r),color:u,orbit:this.cubiesetnames[h],ord:l,ori:a,face:i});let f=c;if(this.duplicatedFaces[n]){const t=f.length/this.duplicatedFaces[n];for(let s=1;s<this.duplicatedFaces[n];s++){for(let e=0;e<t;e++)f=f.rotateforward();e.push({coords:mt(f,r),color:u,orbit:this.cubiesetnames[h],ord:l,ori:s,face:i,isDup:!0})}}}const o=[];for(let t=0;t<this.movesetgeos.length;t++){const e=this.movesetgeos[t],n=this.movesetorders[t];for(const t of this.geonormals)e[0]===t[1]&&e[1]===t[2]&&(o.push({coordinates:pt(t[0].rotatepoint(s),1),quantumMove:new i.Move(e[0]),order:n}),o.push({coordinates:pt(t[0].rotatepoint(s).smul(-1),1),quantumMove:new i.Move(e[2]),order:n}))}const a=this.generate2dmapping(2880,2160,0,!1,1),h=function(){const t=s.invrot();return function(e,s){let n=new Z(0,s[0]*r,-s[1]*r,s[2]*r);n=n.rotatepoint(t);const i=a(e,n);return i[0]/=2880,i[1]=1-i[1]/2160,i}}().bind(this);return{stickers:e,faces:n,axis:o,unswizzle:this.unswizzle.bind(this),notationMapper:this.notationMapper,textureMapper:{getuv:h}}}getGeoNormal(t){const e=this.getInitial3DRotation(),s=this.swizzler.unswizzle(t);for(const t of this.geonormals)if(s===t[1]){const s=pt(t[0].rotatepoint(e),1);return Math.abs(s[0])<it&&Math.abs(s[2])<it&&(s[0]=0,s[2]=1e-6),s}}getfaceindex(t){const e=this.stickersperface;return Math.floor(t/e)}textForTwizzleExplorer(){return`Faces ${this.baseplanerot.length}\nStickers per face ${this.stickersperface}\nShort edge ${this.shortedge}\nCubies ${this.cubies.length}\nEdge distance ${this.edgedistance}\nVertex distance ${this.vertexdistance}`}writeSchreierSims(t){const e=this.getOrbitsDef(!1).reassemblySize();t(`Reassembly size is ${e}`);t(`Ratio is ${e/et(this.getMovesAsPerms(),t)}`)}},vt=class{constructor(t,e){this.pg=t,this.orbitNames=e.orbitnames}lookupMove(t){const e=this.pg.parseMove(t);if(this.pg.parsedmovelist){let t=!1;for(const s of this.pg.parsedmovelist)s[1]===e[1]&&s[2]===e[2]&&s[3]===e[3]&&s[4]===e[4]&&(t=!0);if(!t)return null}let s=[e[2],e[3]];if(!e[4]){const t=this.pg.moveplanesets[e[1]].length;s=[t-e[3],t-e[2]]}const n=this.pg.getMoveFromBits(s,e[5],!e[4],this.pg.cmovesbyslice[e[1]],void 0,this.pg.movesetorders[e[1]]);return O.transformToKTransformationData(this.orbitNames,n)}}})),e.register("98KNc",(function(s,n){t(s.exports,"IterationDirection",(()=>i)),t(s.exports,"direct",(()=>l)),t(s.exports,"directedGenerator",(()=>u)),t(s.exports,"AlgBuilder",(()=>d)),t(s.exports,"Alg",(()=>dt)),t(s.exports,"Conjugate",(()=>y)),t(s.exports,"Move",(()=>J)),t(s.exports,"QuantumMove",(()=>K)),t(s.exports,"Grouping",(()=>Y)),t(s.exports,"TraversalDownUp",(()=>rt)),t(s.exports,"TraversalUp",(()=>ot)),t(s.exports,"experimentalAppendMove",(()=>gt));var i,r,o=e("cks0r"),a=class{is(t){return this instanceof t}as(t){return this instanceof t?this:null}},h=class extends a{constructor(){super()}get log(){return console.log.bind(console,this,this.toString())}};function l(t,e){return-1===e?Array.from(t).reverse():t}function*u(t,e){-1===e?yield*function*(t){for(const e of Array.from(t).reverse())yield e}(t):yield*t}(r=i||(i={}))[r.Forwards=1]="Forwards",r[r.Backwards=-1]="Backwards";var c,f,p,m=2147483647,d=class{constructor(){o.__privateAdd(this,c,[])}push(t){o.__privateGet(this,c).push(t)}experimentalPushAlg(t){for(const e of t.units())this.push(e)}experimentalNumUnits(){return o.__privateGet(this,c).length}toAlg(){return new dt(o.__privateGet(this,c))}reset(){o.__privateSet(this,c,[])}};c=new WeakMap;var v,g,w=class extends h{constructor(t,e){super(),o.__privateAdd(this,f,void 0),o.__privateAdd(this,p,void 0),o.__privateSet(this,f,pt(t)),o.__privateSet(this,p,pt(e))}get A(){return o.__privateGet(this,f)}get B(){return o.__privateGet(this,p)}isIdentical(t){const e=t.as(w);return!(!e?.A.isIdentical(this.A)||!e?.B.isIdentical(this.B))}invert(){return new w(o.__privateGet(this,p),o.__privateGet(this,f))}*experimentalExpand(t=i.Forwards,e){e??(e=1/0),0===e?yield t===i.Forwards?this:this.invert():t===i.Forwards?(yield*this.A.experimentalExpand(i.Forwards,e-1),yield*this.B.experimentalExpand(i.Forwards,e-1),yield*this.A.experimentalExpand(i.Backwards,e-1),yield*this.B.experimentalExpand(i.Backwards,e-1)):(yield*this.B.experimentalExpand(i.Forwards,e-1),yield*this.A.experimentalExpand(i.Forwards,e-1),yield*this.B.experimentalExpand(i.Backwards,e-1),yield*this.A.experimentalExpand(i.Backwards,e-1))}toString(){return`[${o.__privateGet(this,f).toString()}, ${o.__privateGet(this,p).toString()}]`}},b=w;f=new WeakMap,p=new WeakMap;var _,x=class extends h{constructor(t,e){super(),o.__privateAdd(this,v,void 0),o.__privateAdd(this,g,void 0),o.__privateSet(this,v,pt(t)),o.__privateSet(this,g,pt(e))}get A(){return o.__privateGet(this,v)}get B(){return o.__privateGet(this,g)}isIdentical(t){const e=t.as(x);return!(!e?.A.isIdentical(this.A)||!e?.B.isIdentical(this.B))}invert(){return new x(o.__privateGet(this,v),o.__privateGet(this,g).invert())}*experimentalExpand(t,e){e??(e=1/0),0===e?yield t===i.Forwards?this:this.invert():(yield*this.A.experimentalExpand(i.Forwards,e-1),yield*this.B.experimentalExpand(t,e-1),yield*this.A.experimentalExpand(i.Backwards,e-1))}toString(){return`[${this.A}: ${this.B}]`}},y=x;v=new WeakMap,g=new WeakMap;var M=class extends h{constructor(t){if(super(),o.__privateAdd(this,_,void 0),t.includes("\n")||t.includes("\r"))throw new Error("LineComment cannot contain newline");o.__privateSet(this,_,t)}get text(){return o.__privateGet(this,_)}isIdentical(t){const e=t;return t.is(M)&&o.__privateGet(this,_)===o.__privateGet(e,_)}invert(){return this}*experimentalExpand(t=i.Forwards,e=1/0){yield this}toString(){return`//${o.__privateGet(this,_)}`}},L=M;_=new WeakMap;var z=class extends h{toString(){return"\n"}isIdentical(t){return t.is(z)}invert(){return this}*experimentalExpand(t=i.Forwards,e=1/0){yield this}},G=class extends h{toString(){return"."}isIdentical(t){return t.is(G)}invert(){return this}*experimentalExpand(t=i.Forwards,e=1/0){yield this}};function R(t,e){return t?parseInt(t):e}var F,E,S=/^(\d+)?('?)/,k=/^[_\dA-Za-z]/,B=/^((([1-9]\d*)-)?([1-9]\d*))?([_A-Za-z]+)?/,A=/^[^\n]*/,U=/^(-?\d+), ?/,D=/^(-?\d+)\)/;function C(t){return(new N).parseAlg(t)}function I(t,e,s){const n=t;return n.startCharIndex=e,n.endCharIndex=s,n}var N=class{constructor(){o.__privateAdd(this,F,""),o.__privateAdd(this,E,0)}parseAlg(t){o.__privateSet(this,F,t),o.__privateSet(this,E,0);const e=this.parseAlgWithStopping([]);return this.mustBeAtEndOfInput(),e}parseMove(t){o.__privateSet(this,F,t),o.__privateSet(this,E,0);const e=this.parseMoveImpl();return this.mustBeAtEndOfInput(),e}parseQuantumMove(t){o.__privateSet(this,F,t),o.__privateSet(this,E,0);const e=this.parseQuantumMoveImpl();return this.mustBeAtEndOfInput(),e}mustBeAtEndOfInput(){if(o.__privateGet(this,E)!==o.__privateGet(this,F).length)throw new Error("parsing unexpectedly ended early")}parseAlgWithStopping(t){let e=o.__privateGet(this,E),s=o.__privateGet(this,E);const n=new d;let i=!1;const r=t=>{if(i)throw new Error(`Unexpected character at index ${t}. Are you missing a space?`)};t:for(;o.__privateGet(this,E)<o.__privateGet(this,F).length;){const a=o.__privateGet(this,E);if(t.includes(o.__privateGet(this,F)[o.__privateGet(this,E)]))return I(n.toAlg(),e,s);if(this.tryConsumeNext(" "))i=!1,0===n.experimentalNumUnits()&&(e=o.__privateGet(this,E));else if(k.test(o.__privateGet(this,F)[o.__privateGet(this,E)])){r(a);const t=this.parseMoveImpl();n.push(t),i=!0,s=o.__privateGet(this,E)}else{if(this.tryConsumeNext("(")){r(a);const t=this.tryRegex(U);if(t){const e=t[1],r=o.__privateGet(this,E),h=this.parseRegex(D),l=I(new J(new K("U_SQ_"),parseInt(e)),a+1,a+1+e.length),u=I(new J(new K("D_SQ_"),parseInt(h[1])),r,o.__privateGet(this,E)-1),c=I(new dt([l,u]),a+1,o.__privateGet(this,E)-1);n.push(I(new Y(c),a,o.__privateGet(this,E))),i=!0,s=o.__privateGet(this,E);continue t}{const t=this.parseAlgWithStopping([")"]);this.mustConsumeNext(")");const e=this.parseAmount();n.push(I(new Y(t,e),a,o.__privateGet(this,E))),i=!0,s=o.__privateGet(this,E);continue t}}if(!this.tryConsumeNext("[")){if(this.tryConsumeNext("\n")){n.push(I(new z,a,o.__privateGet(this,E))),i=!1,s=o.__privateGet(this,E);continue t}if(this.tryConsumeNext("/")){if(this.tryConsumeNext("/")){r(a);const[t]=this.parseRegex(A);n.push(I(new L(t),a,o.__privateGet(this,E))),i=!1,s=o.__privateGet(this,E);continue t}n.push(I(new J("_SLASH_"),a,o.__privateGet(this,E))),i=!0,s=o.__privateGet(this,E);continue t}if(this.tryConsumeNext(".")){r(a),n.push(I(new G,a,o.__privateGet(this,E))),i=!0,s=o.__privateGet(this,E);continue t}throw new Error(`Unexpected character: ${this.popNext()}`)}{r(a);const t=this.parseAlgWithStopping([",",":"]),e=this.popNext(),h=this.parseAlgWithStopping(["]"]);switch(this.mustConsumeNext("]"),e){case":":n.push(I(new y(t,h),a,o.__privateGet(this,E))),i=!0,s=o.__privateGet(this,E);continue t;case",":n.push(I(new b(t,h),a,o.__privateGet(this,E))),i=!0,s=o.__privateGet(this,E);continue t;default:throw"unexpected parsing error"}}}}if(o.__privateGet(this,E)!==o.__privateGet(this,F).length)throw new Error("did not finish parsing?");if(t.length>0)throw new Error("expected stopping");return I(n.toAlg(),e,s)}parseQuantumMoveImpl(){const[,,,t,e,s]=this.parseRegex(B);return new K(s,R(e,void 0),R(t,void 0))}parseMoveImpl(){const t=o.__privateGet(this,E);if(this.tryConsumeNext("/"))return I(new J("_SLASH_"),t,o.__privateGet(this,E));let e=this.parseQuantumMoveImpl(),[s,n]=this.parseAmountAndTrackEmptyAbsAmount();const i=this.parseMoveSuffix();if(i){if(s<0)throw new Error("uh-oh");if(("++"===i||"--"===i)&&1!==s)throw new Error("Pochmann ++ or -- moves cannot have an amount other than 1.");if(("++"===i||"--"===i)&&!n)throw new Error("Pochmann ++ or -- moves cannot have an amount written as a number.");if(("+"===i||"-"===i)&&n)throw new Error("Clock dial moves must have an amount written as a natural number followed by + or -.");i.startsWith("+")&&(e=e.modified({family:`${e.family}_${"+"===i?"PLUS":"PLUSPLUS"}_`})),i.startsWith("-")&&(e=e.modified({family:`${e.family}_${"-"===i?"PLUS":"PLUSPLUS"}_`}),s*=-1)}return I(new J(e,s),t,o.__privateGet(this,E))}parseMoveSuffix(){return this.tryConsumeNext("+")?this.tryConsumeNext("+")?"++":"+":this.tryConsumeNext("-")?this.tryConsumeNext("-")?"--":"-":null}parseAmountAndTrackEmptyAbsAmount(){const t=o.__privateGet(this,E),[,e,s]=this.parseRegex(S);if(e?.startsWith("0")&&"0"!==e)throw new Error(`Error at char index ${t}: An amount can only start with 0 if it's exactly the digit 0.`);return[R(e,1)*("'"===s?-1:1),!e]}parseAmount(){const t=o.__privateGet(this,E),[,e,s]=this.parseRegex(S);if(e?.startsWith("0")&&"0"!==e)throw new Error(`Error at char index ${t}: An amount number can only start with 0 if it's exactly the digit 0.`);return R(e,1)*("'"===s?-1:1)}parseRegex(t){const e=t.exec(this.remaining());if(null===e)throw new Error("internal parsing error");return o.__privateSet(this,E,o.__privateGet(this,E)+e[0].length),e}tryRegex(t){const e=t.exec(this.remaining());return null===e?null:(o.__privateSet(this,E,o.__privateGet(this,E)+e[0].length),e)}remaining(){return o.__privateGet(this,F).slice(o.__privateGet(this,E))}popNext(){const t=o.__privateGet(this,F)[o.__privateGet(this,E)];return o.__privateWrapper(this,E)._++,t}tryConsumeNext(t){return o.__privateGet(this,F)[o.__privateGet(this,E)]===t&&(o.__privateWrapper(this,E)._++,!0)}mustConsumeNext(t){const e=this.popNext();if(e!==t)throw new Error(`expected \`${t}\` while parsing, encountered ${e}`);return e}};F=new WeakMap,E=new WeakMap;var O=new Set;function T(t){O.has(t)||(console.warn(t),O.add(t))}var P,q,Q,$,W=class{constructor(t,e=1){if(this.quantum=t,this.amount=e,!Number.isInteger(this.amount)||this.amount<-2147483648||this.amount>m)throw new Error("Unit amount absolute value must be a non-negative integer from 2^31 - 1 to 2^31 - 1.")}suffix(){let t="";const e=Math.abs(this.amount);return 1!==e&&(t+=e),this.amount<0&&(t+="'"),t}isIdentical(t){return this.quantum.isIdentical(t.quantum)&&this.amount===t.amount}*experimentalExpand(t,e){const s=Math.abs(this.amount),n=function(t,e=!0){if(!e)return t;switch(t){case 1:return-1;case-1:return 1}}(t,this.amount<0);for(let t=0;t<s;t++)yield*this.quantum.experimentalExpand(n,e)}},j=class extends a{constructor(t,e,s){if(super(),o.__privateAdd(this,P,void 0),o.__privateAdd(this,q,void 0),o.__privateAdd(this,Q,void 0),o.__privateSet(this,P,t),o.__privateSet(this,q,e??null),o.__privateSet(this,Q,s??null),Object.freeze(this),null!==o.__privateGet(this,q)&&(!Number.isInteger(o.__privateGet(this,q))||o.__privateGet(this,q)<1||o.__privateGet(this,q)>m))throw new Error("QuantumMove inner layer must be a positive integer below 2^31 - 1.");if(null!==o.__privateGet(this,Q)&&(!Number.isInteger(o.__privateGet(this,Q))||o.__privateGet(this,Q)<1||o.__privateGet(this,Q)>m))throw new Error("QuantumMove outer layer must be a positive integer below 2^31 - 1.");if(null!==o.__privateGet(this,Q)&&null!==o.__privateGet(this,q)&&o.__privateGet(this,q)<=o.__privateGet(this,Q))throw new Error("QuantumMove outer layer must be smaller than inner layer.");if(null!==o.__privateGet(this,Q)&&null===o.__privateGet(this,q))throw new Error("QuantumMove with an outer layer must have an inner layer")}static fromString(t){return function(t){return(new N).parseQuantumMove(t)}(t)}modified(t){return new j(t.family??o.__privateGet(this,P),t.innerLayer??o.__privateGet(this,q),t.outerLayer??o.__privateGet(this,Q))}isIdentical(t){const e=t;return t.is(j)&&o.__privateGet(this,P)===o.__privateGet(e,P)&&o.__privateGet(this,q)===o.__privateGet(e,q)&&o.__privateGet(this,Q)===o.__privateGet(e,Q)}get family(){return o.__privateGet(this,P)}get outerLayer(){return o.__privateGet(this,Q)}get innerLayer(){return o.__privateGet(this,q)}experimentalExpand(){throw new Error("experimentalExpand() cannot be called on a `QuantumMove` directly.")}toString(){let t=o.__privateGet(this,P);return null!==o.__privateGet(this,q)&&(t=String(o.__privateGet(this,q))+t,null!==o.__privateGet(this,Q)&&(t=String(o.__privateGet(this,Q))+"-"+t)),t}},K=j;P=new WeakMap,q=new WeakMap,Q=new WeakMap;var H=class extends h{constructor(...t){if(super(),o.__privateAdd(this,$,void 0),"string"==typeof t[0])return t[1]?void o.__privateSet(this,$,new W(K.fromString(t[0]),t[1])):H.fromString(t[0]);o.__privateSet(this,$,new W(t[0],t[1]))}isIdentical(t){const e=t.as(H);return!!e&&o.__privateGet(this,$).isIdentical(o.__privateGet(e,$))}invert(){return t=this,e=new H(o.__privateGet(this,$).quantum,-this.amount),"startCharIndex"in t&&(e.startCharIndex=t.startCharIndex),"endCharIndex"in t&&(e.endCharIndex=t.endCharIndex),e;var t,e}*experimentalExpand(t=i.Forwards){t===i.Forwards?yield this:yield this.modified({amount:-this.amount})}get quantum(){return o.__privateGet(this,$).quantum}modified(t){return new H(o.__privateGet(this,$).quantum.modified(t),t.amount??this.amount)}static fromString(t){return function(t){return(new N).parseMove(t)}(t)}get amount(){return o.__privateGet(this,$).amount}get type(){return T("deprecated: type"),"blockMove"}get family(){return o.__privateGet(this,$).quantum.family??void 0}get outerLayer(){return o.__privateGet(this,$).quantum.outerLayer??void 0}get innerLayer(){return o.__privateGet(this,$).quantum.innerLayer??void 0}toString(){if("_SLASH_"===this.family)return"/";if(this.family.endsWith("_PLUS_"))return o.__privateGet(this,$).quantum.toString().slice(0,-6)+Math.abs(this.amount)+(this.amount<0?"-":"+");if(this.family.endsWith("_PLUSPLUS_")){const t=Math.abs(this.amount);return o.__privateGet(this,$).quantum.toString().slice(0,-10)+(1===t?"":t)+(this.amount<0?"--":"++")}return o.__privateGet(this,$).quantum.toString()+o.__privateGet(this,$).suffix()}},J=H;$=new WeakMap;var Z,V=new class{constructor(){this.quantumU_SQ_=null,this.quantumD_SQ_=null}format(t){const e=this.tuple(t);return e?`(${e.map((t=>t.amount)).join(", ")})`:null}tuple(t){this.quantumU_SQ_||(this.quantumU_SQ_=new K("U_SQ_")),this.quantumD_SQ_||(this.quantumD_SQ_=new K("D_SQ_"));const e=t.alg;if(2===e.experimentalNumUnits()){const[s,n]=e.units();if(s.as(J)?.quantum.isIdentical(this.quantumU_SQ_)&&n.as(J)?.quantum.isIdentical(this.quantumD_SQ_)){if(1!==t.amount)throw new Error("Square-1 tuples cannot have an amount other than 1.");return[s,n]}}return null}},X=class extends h{constructor(t,e){super(),o.__privateAdd(this,Z,void 0);const s=pt(t);o.__privateSet(this,Z,new W(s,e))}isIdentical(t){const e=t;return t.is(X)&&o.__privateGet(this,Z).isIdentical(o.__privateGet(e,Z))}get alg(){return o.__privateGet(this,Z).quantum}get amount(){return o.__privateGet(this,Z).amount}get experimentalRepetitionSuffix(){return o.__privateGet(this,Z).suffix()}invert(){return new X(o.__privateGet(this,Z).quantum,-o.__privateGet(this,Z).amount)}*experimentalExpand(t=i.Forwards,e){e??(e=1/0),0===e?yield t===i.Forwards?this:this.invert():yield*o.__privateGet(this,Z).experimentalExpand(t,e-1)}static fromString(){throw new Error("unimplemented")}toString(){return V.format(this)??`(${o.__privateGet(this,Z).quantum.toString()})${o.__privateGet(this,Z).suffix()}`}experimentalAsSquare1Tuple(){return V.tuple(this)}},Y=X;function tt(t,e){return t instanceof e}function et(t,e,s){if(e.is(Y))return t.traverseGrouping(e,s);if(e.is(J))return t.traverseMove(e,s);if(e.is(b))return t.traverseCommutator(e,s);if(e.is(y))return t.traverseConjugate(e,s);if(e.is(G))return t.traversePause(e,s);if(e.is(z))return t.traverseNewline(e,s);if(e.is(L))return t.traverseLineComment(e,s);throw new Error("unknown unit")}function st(t){if(t.is(Y)||t.is(J)||t.is(b)||t.is(y)||t.is(G)||t.is(z)||t.is(L))return t;throw"internal error: expected unit"}Z=new WeakMap;var nt,it,rt=class{traverseUnit(t,e){return et(this,t,e)}traverseIntoUnit(t,e){return st(this.traverseUnit(t,e))}},ot=class extends rt{traverseUnit(t){return et(this,t,void 0)}traverseIntoUnit(t){return st(this.traverseUnit(t))}},at=class extends rt{*traverseAlg(t,e){if(0===e.depth)return void(yield*t.units());const s=[];let n=null;const i=e?.collapseMoves??!0;function r(t,i){var r;const a=o.__privateMethod(r=at,nt,it).call(r,t,i,e);if(0===a)return!1;const h=new J(t.quantum,a);return s.push(h),n=h,!0}const a={depth:e.depth?e.depth-1:null};for(const e of t.units())for(const t of this.traverseUnit(e,a))h=t,i&&n?.is(J)&&h.is(J)&&n.quantum.isIdentical(h.quantum)?(s.pop(),r(n,h.amount)||(n=s.slice(-1)[0])):h.is(J)?r(h,0):(s.push(h),n=h);var h;for(const t of s)yield t}*traverseGrouping(t,e){if(0===e.depth)return void(yield t);const s={depth:e.depth?e.depth-1:null};yield new Y(this.traverseAlg(t.alg,s))}*traverseMove(t,e){yield t}*traverseCommutator(t,e){if(0===e.depth)return void(yield t);const s={depth:e.depth?e.depth-1:null};yield new b(this.traverseAlg(t.A,s),this.traverseAlg(t.B,s))}*traverseConjugate(t,e){if(0===e.depth)return void(yield t);const s={depth:e.depth?e.depth-1:null};yield new y(this.traverseAlg(t.A,s),this.traverseAlg(t.B,s))}*traversePause(t,e){yield t}*traverseNewline(t,e){yield t}*traverseLineComment(t,e){yield t}},ht=at;nt=new WeakSet,it=function(t,e,s){let n=t.amount+e;if(s?.quantumMoveOrder){const e=s.quantumMoveOrder(t.quantum),i=Math.floor(e/2)+1-e;n=(n%e+e-i)%e+i}return n},o.__privateAdd(ht,nt);var lt,ut=new ht,ct=ut.traverseAlg.bind(ut);function ft(t){if(!t)return[];if(tt(t,dt))return t.units();if("string"==typeof t)return C(t).units();const e=t;if("function"==typeof e[Symbol.iterator])return e;throw"Invalid unit"}function pt(t){return tt(t,dt)?t:new dt(t)}var mt=class extends h{constructor(t){super(),o.__privateAdd(this,lt,void 0),o.__privateSet(this,lt,Array.from(ft(t)));for(const t of o.__privateGet(this,lt))if(!(tt(e=t,Y)||tt(e,L)||tt(e,b)||tt(e,y)||tt(e,J)||tt(e,z)||tt(e,G)))throw new Error("An alg can only contain units.");var e}isIdentical(t){const e=t;if(!t.is(mt))return!1;const s=Array.from(o.__privateGet(this,lt)),n=Array.from(o.__privateGet(e,lt));if(s.length!==n.length)return!1;for(let t=0;t<s.length;t++)if(!s[t].isIdentical(n[t]))return!1;return!0}invert(){return new mt((t=Array.from(o.__privateGet(this,lt)).map((t=>t.invert())),Array.from(t).reverse()));var t}*experimentalExpand(t=i.Forwards,e){e??(e=1/0);for(const s of l(o.__privateGet(this,lt),t))yield*s.experimentalExpand(t,e)}expand(t){return new mt(this.experimentalExpand(i.Forwards,t?.depth??1/0))}*experimentalLeafMoves(){for(const t of this.experimentalExpand())t.is(J)&&(yield t)}concat(t){return new mt(Array.from(o.__privateGet(this,lt)).concat(Array.from(ft(t))))}experimentalIsEmpty(){for(const t of o.__privateGet(this,lt))return!1;return!0}static fromString(t){return C(t)}*units(){for(const t of o.__privateGet(this,lt))yield t}experimentalNumUnits(){return Array.from(o.__privateGet(this,lt)).length}get type(){return T("deprecated: type"),"sequence"}toString(){let t="",e=null;for(const s of o.__privateGet(this,lt))e&&(t+=vt(e,s)),t+=s.toString(),e=s;return t}simplify(t){return new mt(ct(this,t??{}))}},dt=mt;function vt(t,e){return t.is(z)||e.is(z)?"":t.is(L)&&!e.is(z)?"\n":" "}lt=new WeakMap;new dt([new J("R",1),new J("U",1),new J("R",-1),new J("U",1),new J("R",1),new J("U",-2),new J("R",-1)]),new dt([new J("R",1),new J("U",2),new J("R",-1),new J("U",-1),new J("R",1),new J("U",-1),new J("R",-1)]),new dt([new b(new dt([new J("R",1),new J("U",1),new J("R",-2)]),new dt([new y(new dt([new J("R",1)]),new dt([new J("U",1)]))]))]),new dt([new J("R",1),new J("U",-1),new J("L",-1),new J("U",1),new J("R",-1),new J("U",-1),new J("L",1),new J("U",1)]),new dt([new J("x",-1),new b(new dt([new y(new dt([new J("R",1)]),new dt([new J("U",-1)]))]),new dt([new J("D",1)])),new b(new dt([new y(new dt([new J("R",1)]),new dt([new J("U",1)]))]),new dt([new J("D",1)])),new J("x",1)]),new dt([new y(new dt([new J("F",1)]),new dt([new b(new dt([new J("U",1)]),new dt([new J("R",1)]))]))]),new dt([new y(new dt([new J("R",2)]),new dt([new b(new dt([new J("F",2)]),new dt([new J("R",-1),new J("B",-1),new J("R",1)]))]))]),new dt([new J("F",1),new J("U",1),new J("R",1),new J("U",-1),new J("R",-1),new J("F",-1)]),new dt([new J("R",1),new J("U",1),new J("R",-1),new J("U",-1),new J("R",-1),new J("F",1),new J("R",2),new J("U",-1),new J("R",-1),new J("U",-1),new J("R",1),new J("U",1),new J("R",-1),new J("F",-1)]),new dt([new y(new dt([new J("F",1)]),new dt([new Y(new dt([new b(new dt([new J("R",1)]),new dt([new J("U",1)]))]),3)]))]),new dt([new G,new G,new G]),new J("R"),new J("R'"),new J("B"),new J("B'"),new J("D"),new J("D'"),new J("L"),new J("L'"),new J("U"),new J("U'"),new J("F"),new J("F'"),new J("x'"),new J("l"),new J("l'"),new J("r"),new J("r'"),new J("d"),new J("d'"),new J("x"),new J("x"),new J("x'"),new J("y"),new J("y"),new J("y'"),new J("z"),new J("z'"),new J("M'"),new J("M'");function gt(t,e,s){const n=Array.from(t.units()),i=n[n.length-1];if(s?.coalesce&&i&&i.quantum&&i.quantum.isIdentical(e.quantum)){const t=n.slice(0,n.length-1);let r=i.amount+e.amount;const o=s?.mod;return o&&(r=(r%o+o)%o,2*r>o&&(r-=o)),0!==r&&t.push(i.modified({amount:r})),new dt(t)}return new dt([...n,e])}})),e.register("cks0r",(function(e,s){t(e.exports,"__privateGet",(()=>i)),t(e.exports,"__privateAdd",(()=>r)),t(e.exports,"__privateSet",(()=>o)),t(e.exports,"__privateWrapper",(()=>a)),t(e.exports,"__privateMethod",(()=>h));var n=(t,e,s)=>{if(!e.has(t))throw TypeError("Cannot "+s)},i=(t,e,s)=>(n(t,e,"read from private field"),s?s.call(t):e.get(t)),r=(t,e,s)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,s)},o=(t,e,s,i)=>(n(t,e,"write to private field"),i?i.call(t,s):e.set(t,s),s),a=(t,e,s,n)=>({set _(n){o(t,e,n,s)},get _(){return i(t,e,n)}}),h=(t,e,s)=>(n(t,e,"access private method"),s)}));
//# sourceMappingURL=puzzle-geometry.0190f2b3.js.map
