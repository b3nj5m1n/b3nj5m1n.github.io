{"mappings":"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","sources":["node_modules/@parcel/runtime-js/lib/runtime-76faaa07628a4d45.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/cubing/src/cubing/puzzles/customPGPuzzleLoader.ts","node_modules/cubing/src/cubing/puzzles/events.ts","node_modules/cubing/src/cubing/puzzles/stickerings/appearance.ts","node_modules/cubing/src/cubing/puzzles/async/async-pg3d.ts","node_modules/cubing/src/cubing/puzzles/stickerings/global-custom-stickering-hack.ts","node_modules/cubing/src/cubing/puzzles/stickerings/cube-stickerings.ts","node_modules/cubing/src/cubing/puzzles/async/lazy-cached.ts","node_modules/cubing/src/cubing/puzzles/implementations/2x2x2/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/3x3x3/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/clock/index.ts","node_modules/cubing/src/cubing/puzzles/stickerings/fto-stickerings.ts","node_modules/cubing/src/cubing/puzzles/implementations/fto/index.ts","node_modules/cubing/src/cubing/puzzles/stickerings/megaminx-stickerings.ts","node_modules/cubing/src/cubing/puzzles/implementations/megaminx/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/pyraminx/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/square1/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/kilominx/index.ts","node_modules/cubing/src/cubing/puzzles/implementations/redi-cube/index.ts","node_modules/cubing/src/cubing/puzzles/index.ts","node_modules/cubing/src/cubing/kpuzzle/combine.ts","node_modules/cubing/src/cubing/kpuzzle/construct.ts","node_modules/cubing/src/cubing/kpuzzle/KState.ts","node_modules/cubing/src/cubing/kpuzzle/KTransformation.ts","node_modules/cubing/src/cubing/kpuzzle/calculate.ts","node_modules/cubing/src/cubing/kpuzzle/KPuzzle.ts","node_modules/cubing/src/cubing/kpuzzle/3x3x3/3x3x3.kpuzzle.json.ts","node_modules/cubing/src/cubing/kpuzzle/index.ts","node_modules/cubing/src/cubing/alg/iteration.ts","node_modules/cubing/src/cubing/alg/common.ts","node_modules/cubing/src/cubing/alg/limits.ts","node_modules/cubing/src/cubing/alg/AlgBuilder.ts","node_modules/cubing/src/cubing/alg/units/containers/Commutator.ts","node_modules/cubing/src/cubing/alg/units/containers/Conjugate.ts","node_modules/cubing/src/cubing/alg/units/leaves/LineComment.ts","node_modules/cubing/src/cubing/alg/units/leaves/Newline.ts","node_modules/cubing/src/cubing/alg/units/leaves/Pause.ts","node_modules/cubing/src/cubing/alg/parse.ts","node_modules/cubing/src/cubing/alg/warnOnce.ts","node_modules/cubing/src/cubing/alg/units/QuantumWithAmount.ts","node_modules/cubing/src/cubing/alg/units/leaves/Move.ts","node_modules/cubing/src/cubing/alg/units/containers/Grouping.ts","node_modules/cubing/src/cubing/alg/is.ts","node_modules/cubing/src/cubing/alg/traversal.ts","node_modules/cubing/src/cubing/alg/Alg.ts","node_modules/cubing/src/cubing/alg/example.ts","node_modules/cubing/src/cubing/alg/keyboard.ts","node_modules/cubing/src/cubing/alg/operation.ts","node_modules/@parcel/runtime-js/lib/runtime-95336ed10e06c134.js","node_modules/@parcel/runtime-js/lib/runtime-9d70d73b4c404af0.js","node_modules/@parcel/runtime-js/lib/runtime-8189ad590015eff4.js","node_modules/@parcel/runtime-js/lib/runtime-844f72f9f153fce9.js","node_modules/@parcel/runtime-js/lib/runtime-7e2a90e89ce306b5.js","node_modules/@parcel/runtime-js/lib/runtime-22fc0a68ca9a88d7.js","node_modules/@parcel/runtime-js/lib/runtime-6404e6150069d7ee.js","node_modules/@parcel/runtime-js/lib/runtime-3e8d1ec258c9f20b.js","node_modules/@parcel/runtime-js/lib/runtime-045a461a07541b51.js","node_modules/@parcel/runtime-js/lib/runtime-40f9e750df9f46a6.js","node_modules/@parcel/runtime-js/lib/runtime-d6c74d4090356695.js","node_modules/@parcel/runtime-js/lib/runtime-78cf35c5ebeef31f.js","node_modules/@parcel/runtime-js/lib/runtime-aab4796b50a16f72.js"],"sourcesContent":["require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"adU6T\\\":\\\"index.b9099a78.js\\\",\\\"gW5g5\\\":\\\"puzzle-geometry.898d008f.js\\\",\\\"hPxUV\\\":\\\"puzzle-geometry.0190f2b3.js\\\",\\\"iak3L\\\":\\\"2x2x2.kpuzzle.json-RUB44MJV.e7103f97.js\\\",\\\"3tHIy\\\":\\\"2x2x2.kpuzzle.svg-CQF2FTV7.d5ab3729.js\\\",\\\"lfz5Q\\\":\\\"3x3x3.kpuzzle.svg-ERSSH66P.82ea6213.js\\\",\\\"4UNjE\\\":\\\"3x3x3-ll.kpuzzle.svg-53CBPG5O.f5b1df4a.js\\\",\\\"91rD7\\\":\\\"clock.kpuzzle.json-BQKNKV3G.2800adbf.js\\\",\\\"lMvhS\\\":\\\"clock.kpuzzle.svg-B7TMN3SY.46e945ea.js\\\",\\\"dRtyN\\\":\\\"pyraminx.kpuzzle.svg-QBBMZVDY.0739ed16.js\\\",\\\"kziDj\\\":\\\"sq1-hyperorbit.kpuzzle.json-4XS5YACO.a9e96e56.js\\\",\\\"1uf7V\\\":\\\"sq1-hyperorbit.kpuzzle.svg-ID57EER7.9830c057.js\\\",\\\"aGyuS\\\":\\\"kilominx.kpuzzle.svg-7XJBOKFU.5d33195d.js\\\",\\\"2tl92\\\":\\\"redi_cube.kpuzzle.json-EPBKWOMV.d2a51100.js\\\",\\\"gyTEh\\\":\\\"redi_cube.kpuzzle.svg-BSHCMC2Z.db9de252.js\\\"}\"));","\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","import { KPuzzle, KPuzzleDefinition } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { PuzzleDescriptionString } from \"../puzzle-geometry/PGPuzzles\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function descAsyncGetPuzzleGeometry(\n  desc: PuzzleDescriptionString,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: dedup with `cubing/puzzles`\nexport async function asyncGetKPuzzle(\n  desc: PuzzleDescriptionString,\n): Promise<KPuzzle> {\n  const pg = await descAsyncGetPuzzleGeometry(desc);\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = `description: ${desc}`;\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\n// TODO: Can we avoid relying on IDs to deduplicate work at higher levels?\nlet nextCustomID = 1;\n\nexport function customPGPuzzleLoader(\n  desc: PuzzleDescriptionString,\n  info?: {\n    fullName?: string;\n    inventedBy?: string[];\n    inventionYear?: number;\n  },\n): PuzzleLoader {\n  const customID = nextCustomID++;\n  let cachedKPuzzle: Promise<KPuzzle> | null = null;\n  const puzzleLoader: PuzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: async () => {\n      return (cachedKPuzzle ??= asyncGetKPuzzle(desc));\n    },\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    },\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n","import type { PuzzleID } from \"../twisty\";\n\ninterface EventInfo {\n  puzzleID: PuzzleID;\n  eventName: string;\n}\n\nconst wcaEvents: Record<string, EventInfo> = {\n  \"333\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Cube\" },\n  \"222\": { puzzleID: \"2x2x2\", eventName: \"2x2x2 Cube\" },\n  \"444\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Cube\" },\n  \"555\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Cube\" },\n  \"666\": { puzzleID: \"6x6x6\", eventName: \"6x6x6 Cube\" },\n  \"777\": { puzzleID: \"7x7x7\", eventName: \"7x7x7 Cube\" },\n  \"333bf\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Blindfolded\" },\n  \"333fm\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Fewest Moves\" },\n  \"333oh\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 One-Handed\" },\n  \"clock\": { puzzleID: \"clock\", eventName: \"Clock\" },\n  \"minx\": { puzzleID: \"megaminx\", eventName: \"Megaminx\" },\n  \"pyram\": { puzzleID: \"pyraminx\", eventName: \"Pyraminx\" },\n  \"skewb\": { puzzleID: \"skewb\", eventName: \"Skewb\" },\n  \"sq1\": { puzzleID: \"square1\", eventName: \"Square-1\" },\n  \"444bf\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Blindfolded\" },\n  \"555bf\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Blindfolded\" },\n  \"333mb\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Multi-Blind\" },\n};\n\nexport function wcaEventInfo(event: string): EventInfo | null {\n  return wcaEvents[event] ?? null;\n}\n\nconst events: Record<string, EventInfo> = {\n  ...wcaEvents,\n  fto: { puzzleID: \"fto\", eventName: \"Face-Turning Octahedron\" },\n  master_tetraminx: {\n    puzzleID: \"master_tetraminx\",\n    eventName: \"Master Tetraminx\",\n  },\n  kilominx: {\n    puzzleID: \"kilominx\",\n    eventName: \"Kilominx\",\n  },\n  redi_cube: {\n    puzzleID: \"redi_cube\",\n    eventName: \"Redi Cube\",\n  },\n};\n\nexport function eventInfo(event: string): EventInfo | null {\n  return events[event] ?? null;\n}\n","// TODO: figure out where to house this permanently.\n\nimport type { Move } from \"../../alg\";\nimport type { KPuzzle } from \"../../kpuzzle\";\n\nexport type FaceletMeshAppearance =\n  | \"regular\"\n  | \"dim\"\n  | \"oriented\"\n  | \"ignored\"\n  | \"invisible\";\n\nexport type FaceletAppearance = {\n  appearance: FaceletMeshAppearance;\n  hintAppearance?: FaceletMeshAppearance;\n};\n\nexport type PieceAppearance = {\n  // TODO: foundation?\n  facelets: (FaceletMeshAppearance | FaceletAppearance | null)[];\n};\n\nexport type OrbitAppearance = {\n  pieces: (PieceAppearance | null)[];\n};\n\nexport type PuzzleAppearance = {\n  name?: string; // TODO\n  orbits: Record<string, OrbitAppearance>;\n};\n\nexport function getFaceletAppearance(\n  appearance: PuzzleAppearance,\n  orbitName: string,\n  pieceIdx: number,\n  faceletIdx: number,\n  hint: boolean,\n): FaceletMeshAppearance {\n  const orbitAppearance = appearance.orbits[orbitName];\n  const pieceAppearance: PieceAppearance | null =\n    orbitAppearance.pieces[pieceIdx];\n  if (pieceAppearance === null) {\n    return regular;\n  }\n  const faceletAppearance: FaceletMeshAppearance | FaceletAppearance | null =\n    pieceAppearance.facelets[faceletIdx];\n  if (faceletAppearance === null) {\n    return regular;\n  }\n  if (typeof faceletAppearance === \"string\") {\n    return faceletAppearance;\n  }\n  if (hint) {\n    return faceletAppearance.hintAppearance ?? faceletAppearance.appearance;\n  }\n  return faceletAppearance.appearance;\n}\n\n// TODO: Revert this to a normal enum, or write a standard to codify the names?\nexport enum PieceStickering {\n  Regular = \"Regular\",\n  Dim = \"Dim\",\n  Ignored = \"Ignored\",\n  OrientationStickers = \"OrientationStickers\",\n  Invisible = \"Invisible\",\n  Ignoriented = \"Ignoriented\",\n  IgnoreNonPrimary = \"IgnoreNonPrimary\",\n  PermuteNonPrimary = \"PermuteNonPrimary\",\n  OrientationWithoutPermutation = \"OrientationWithoutPermutation\",\n}\n\nexport class PieceAnnotation<T> {\n  stickerings: Map<string, T[]> = new Map();\n  constructor(kpuzzle: KPuzzle, defaultValue: T) {\n    for (const [orbitName, orbitDef] of Object.entries(\n      kpuzzle.definition.orbits,\n    )) {\n      this.stickerings.set(\n        orbitName,\n        new Array(orbitDef.numPieces).fill(defaultValue),\n      );\n    }\n  }\n}\n\nconst regular = \"regular\";\nconst ignored = \"ignored\";\nconst oriented = \"oriented\";\nconst invisible = \"invisible\";\nconst dim = \"dim\";\n\n// regular\nconst r: PieceAppearance = {\n  facelets: [regular, regular, regular, regular, regular],\n};\n\n// ignored\nconst i: PieceAppearance = {\n  facelets: [ignored, ignored, ignored, ignored, ignored],\n};\n\n// oriented stickers\nconst o: PieceAppearance = {\n  facelets: [oriented, oriented, oriented, oriented, oriented],\n};\n\n// invisible\nconst invisiblePiece: PieceAppearance = {\n  facelets: [invisible, invisible, invisible, invisible], // TODO: 4th entry is for void cube. Should be handled properly for all stickerings.\n};\n\n// \"OLL\"\nconst riiii: PieceAppearance = {\n  facelets: [regular, ignored, ignored, ignored, ignored],\n};\n\n// \"PLL\"\nconst drrrr: PieceAppearance = {\n  facelets: [dim, regular, regular, regular, regular],\n};\n\n// ignored\nconst d: PieceAppearance = {\n  facelets: [dim, dim, dim, dim, dim],\n};\n\n// \"OLL\"\nconst diiii: PieceAppearance = {\n  facelets: [dim, ignored, ignored, ignored, ignored],\n};\n\n// oriented\nconst oiiii: PieceAppearance = {\n  facelets: [oriented, ignored, ignored, ignored, ignored],\n};\n\nexport function getPieceAppearance(\n  pieceStickering: PieceStickering,\n): PieceAppearance {\n  switch (pieceStickering) {\n    case PieceStickering.Regular:\n      return r;\n    case PieceStickering.Dim:\n      return d;\n    case PieceStickering.Ignored:\n      return i;\n    case PieceStickering.OrientationStickers: // TODO: Hack for centers. This shouldn't be needed.\n      return o;\n    case PieceStickering.Invisible: // TODO: Hack for centers. This shouldn't be needed.\n      return invisiblePiece;\n    case PieceStickering.IgnoreNonPrimary:\n      return riiii;\n    case PieceStickering.PermuteNonPrimary:\n      return drrrr;\n    case PieceStickering.Ignoriented:\n      return diiii;\n    case PieceStickering.OrientationWithoutPermutation:\n      return oiiii;\n  }\n}\n\nexport class PuzzleStickering extends PieceAnnotation<PieceStickering> {\n  constructor(kpuzzle: KPuzzle) {\n    super(kpuzzle, PieceStickering.Regular);\n  }\n\n  set(pieceSet: PieceSet, pieceStickering: PieceStickering): PuzzleStickering {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i = 0; i < pieces.length; i++) {\n        if (pieceSet.stickerings.get(orbitName)![i]) {\n          pieces[i] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n\n  toAppearance(): PuzzleAppearance {\n    const appearance: PuzzleAppearance = { orbits: {} };\n    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {\n      const pieces: PieceAppearance[] = [];\n      const orbitAppearance: OrbitAppearance = {\n        pieces,\n      };\n      appearance.orbits[orbitName] = orbitAppearance;\n      for (const pieceStickering of pieceStickerings) {\n        pieces.push(getPieceAppearance(pieceStickering));\n      }\n    }\n    return appearance;\n  }\n}\n\nexport type PieceSet = PieceAnnotation<boolean>;\n\nexport class StickeringManager {\n  constructor(private kpuzzle: KPuzzle) {}\n\n  and(pieceSets: PieceSet[]): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = true;\n        for (const pieceSet of pieceSets) {\n          if (!pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = false;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  or(pieceSets: PieceSet[]): PieceSet {\n    // TODO: unify impl with and?\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = false;\n        for (const pieceSet of pieceSets) {\n          if (pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = true;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  not(pieceSet: PieceSet): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] =\n          !pieceSet.stickerings.get(orbitName)![i];\n      }\n    }\n    return newPieceSet;\n  }\n\n  all(): PieceSet {\n    return this.and(this.moves([])); // TODO: are the degenerate cases for and/or the wrong way around\n  }\n\n  move(moveSource: Move | string): PieceSet {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        if (\n          transformation.transformationData[orbitName].permutation[i] !== i ||\n          transformation.transformationData[orbitName].orientation[i] !== 0\n        ) {\n          newPieceSet.stickerings.get(orbitName)![i] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  moves(moveSources: (Move | string)[]): PieceSet[] {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n\n  // orbits(orbitNames: string[]): PieceSet {\n  //   const pieceSet = new PieceAnnotation<boolean>(this.def, false);\n  //   for (const orbitName of orbitNames) {\n  //     pieceSet.stickerings.get(orbitName)!.fill(true);\n  //   }\n  //   return pieceSet;\n  // }\n\n  // trueCounts(pieceSet: PieceSet): Record<string, number> {\n  //   const counts: Record<string, number> = {};\n  //   for (const [orbitName, orbitDef] of Object.entries(this.def.orbits)) {\n  //     let count = 0;\n  //     for (let i = 0; i < orbitDef.numPieces; i++) {\n  //       if (pieceSet.stickerings.get(orbitName)![i]) {\n  //         count++;\n  //       }\n  //     }\n  //     counts[orbitName] = count;\n  //   }\n  //   return counts;\n  // }\n}\n","import { KPuzzle, KPuzzleDefinition } from \"../../kpuzzle\";\nimport type { PuzzleGeometry } from \"../../puzzle-geometry\";\nimport type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"../stickerings/appearance\";\nimport {\n  cubeAppearance,\n  cubeStickerings,\n} from \"../stickerings/cube-stickerings\";\nimport { getCached } from \"./lazy-cached\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function asyncGetPuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: can we cache the puzzleGeometry to avoid duplicate calls, without\n// wasting memory? Maybe just save the latest one for successive calls about the\n// same puzzle?\nexport async function asyncGetKPuzzle(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): Promise<KPuzzle> {\n  const pg = await pgPromise;\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\nexport function asyncLazyKPuzzleGetter(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): () => Promise<KPuzzle> {\n  return getCached(() => asyncGetKPuzzle(pgPromise, puzzleName));\n}\n\ntype PuzzleLoaderConstructorArgs = {\n  pgID?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n};\n\nexport class PGPuzzleLoader implements PuzzleLoader {\n  pgId?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  constructor(info: PuzzleLoaderConstructorArgs) {\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n  }\n\n  #cachedPG: Promise<PuzzleGeometry> | undefined;\n  pg(): Promise<PuzzleGeometry> {\n    return (this.#cachedPG ??= asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n\n  #cachedKPuzzle: Promise<KPuzzle> | undefined;\n  kpuzzle(): Promise<KPuzzle> {\n    return (this.#cachedKPuzzle ??= asyncGetKPuzzle(this.pg(), this.id));\n  }\n\n  #cachedSVG: Promise<string> | undefined;\n  svg(): Promise<string> {\n    return (this.#cachedSVG ??= (async () =>\n      (await this.pg()).generatesvg())());\n  }\n}\n\nexport class CubePGPuzzleLoader extends PGPuzzleLoader {\n  appearance(stickering: ExperimentalStickering): Promise<PuzzleAppearance> {\n    return cubeAppearance(this, stickering);\n  }\n  stickerings = cubeStickerings;\n}\n","import type { TwistyPlayer } from \"../../twisty\";\nimport {\n  PieceStickering,\n  PuzzleStickering,\n  StickeringManager,\n} from \"./appearance\";\n\ntype Stickerer = (\n  puzzleStickering: PuzzleStickering,\n  m: StickeringManager,\n) => void;\n\nlet globalCustomStickerer: Stickerer = () => {};\n\nfunction setGlobalCustomStickerer(stickerer: Stickerer): void {\n  (async () => {\n    globalCustomStickerer = stickerer;\n\n    const players: TwistyPlayer[] = Array.from(\n      document.body.querySelectorAll(\"twisty-player\"),\n    );\n    console.log(`Setting the custom stickering for ${players.length} players!`);\n    const successPromises = [];\n    for (const player of players) {\n      successPromises.push(\n        (async () => {\n          const stickering = await player.experimentalModel.stickering.get();\n          player.experimentalStickering =\n            stickering === \"experimental-global-custom-1\"\n              ? \"experimental-global-custom-2\"\n              : \"experimental-global-custom-1\";\n        })(),\n      );\n    }\n    await Promise.all(successPromises);\n    console.log(\"Success!\");\n  })();\n}\n\nexport function useGlobalCustomStickerer(\n  puzzleStickering: PuzzleStickering,\n  m: StickeringManager,\n): void {\n  globalCustomStickerer(puzzleStickering, m);\n}\n\nif (\n  globalThis.location &&\n  new URL(location.href).searchParams.get(\"global-custom-stickerer\") === \"true\"\n) {\n  (window as any).setGlobalCustomStickerer = setGlobalCustomStickerer;\n  (window as any).PieceStickering = PieceStickering;\n  console.log(\n    \"Global custom stickerer enabled! (using: global-custom-stickerer=true)\",\n  );\n  console.log(\n    \"Look here for inspiration:\",\n    \"https://github.com/cubing/cubing.js/blob/81b5cab3e27d8defb39dd1e0a10bc9e8ba894d26/src/cubing/puzzles/stickerings/cube-stickerings.ts#L67\",\n  );\n}\n","import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  PuzzleAppearance,\n  PuzzleStickering,\n  StickeringManager,\n  PieceSet,\n  PieceStickering,\n} from \"./appearance\";\nimport { useGlobalCustomStickerer } from \"./global-custom-stickering-hack\";\n\n// TODO: cache calculations?\nexport async function cubeAppearance(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<PuzzleAppearance> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const LL = (): PieceSet => m.move(\"U\");\n  const orUD = (): PieceSet => m.or(m.moves([\"U\", \"D\"]));\n  const E = (): PieceSet => m.not(orUD());\n  const orLR = (): PieceSet => m.or(m.moves([\"L\", \"R\"]));\n  const M = (): PieceSet => m.not(orLR());\n  const orFB = (): PieceSet => m.or(m.moves([\"F\", \"B\"]));\n  const S = (): PieceSet => m.not(orFB());\n\n  const F2L = (): PieceSet => m.not(LL());\n\n  const centerU = (): PieceSet => m.and([LL(), M(), S()]);\n\n  const edgeFR = (): PieceSet =>\n    m.and([m.and(m.moves([\"F\", \"R\"])), m.not(orUD())]);\n  const cornerDFR = (): PieceSet => m.and(m.moves([\"D\", \"R\", \"F\"]));\n  const slotFR = (): PieceSet => m.or([cornerDFR(), edgeFR()]);\n\n  const CENTERS = (): PieceSet =>\n    m.or([m.and([M(), E()]), m.and([M(), S()]), m.and([E(), S()])]);\n  const EDGES = (): PieceSet =>\n    m.or([\n      m.and([M(), orUD(), orFB()]),\n      m.and([E(), orLR(), orFB()]),\n      m.and([S(), orUD(), orLR()]),\n    ]);\n  const CORNERS = (): PieceSet => m.not(m.or([CENTERS(), EDGES()]));\n  const L6E = (): PieceSet => m.or([M(), m.and([LL(), EDGES()])]);\n\n  function dimF2L(): void {\n    puzzleStickering.set(F2L(), PieceStickering.Dim);\n  }\n\n  function setPLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n    puzzleStickering.set(centerU(), PieceStickering.Dim); // TODO: why is this needed?\n  }\n\n  function setOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.IgnoreNonPrimary);\n    puzzleStickering.set(centerU(), PieceStickering.Regular); // TODO: why is this needed?\n  }\n\n  function dimOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n    puzzleStickering.set(centerU(), PieceStickering.Dim); // TODO: why is this needed?\n  }\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\":\n      dimF2L();\n      setPLL();\n      break;\n    case \"CLS\":\n      dimF2L();\n      puzzleStickering.set(\n        m.and(m.moves([\"D\", \"R\", \"F\"])),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), M(), S()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    case \"OLL\":\n      dimF2L();\n      setOLL();\n      break;\n    case \"COLL\":\n      dimF2L();\n      setPLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    case \"OCLL\":\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    case \"CLL\":\n      dimF2L();\n      puzzleStickering.set(\n        m.not(m.and([CORNERS(), LL()])),\n        PieceStickering.Dim,\n      );\n      break;\n    case \"ELL\":\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Regular);\n      break;\n    case \"ELS\":\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      puzzleStickering.set(edgeFR(), PieceStickering.Regular);\n      puzzleStickering.set(cornerDFR(), PieceStickering.Ignored);\n      break;\n    case \"LL\":\n      dimF2L();\n      break;\n    case \"F2L\":\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      break;\n    case \"ZBLL\":\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n      puzzleStickering.set(centerU(), PieceStickering.Dim); // why is this needed?\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    case \"ZBLS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    case \"WVLS\":\n    // fallthrough\n    case \"VLS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      break;\n    case \"LS\":\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      puzzleStickering.set(centerU(), PieceStickering.Dim);\n      break;\n    case \"EO\":\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      break;\n    case \"EOline\":\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), PieceStickering.Regular);\n      break;\n    case \"EOcross\":\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.move(\"D\"), PieceStickering.Regular);\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      break;\n    case \"CMLL\":\n      puzzleStickering.set(F2L(), PieceStickering.Dim);\n      puzzleStickering.set(L6E(), PieceStickering.Ignored);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    case \"L6E\":\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      break;\n    case \"L6EO\":\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(\n        L6E(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(\n        m.and([CENTERS(), orUD()]),\n        PieceStickering.OrientationStickers,\n      ); // TODO: why is this needed?\n      break;\n    case \"Daisy\":\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"U\"), EDGES()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    case \"Cross\":\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), EDGES()]),\n        PieceStickering.Regular,\n      );\n      break;\n    case \"2x2x2\":\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      break;\n    case \"2x2x3\":\n      puzzleStickering.set(m.all(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]),\n        PieceStickering.Regular,\n      );\n      break;\n    case \"Void Cube\":\n      puzzleStickering.set(CENTERS(), PieceStickering.Invisible);\n      break;\n    case \"picture\":\n    // fallthrough\n    case \"invisible\":\n      puzzleStickering.set(m.all(), PieceStickering.Invisible);\n      break;\n    case \"centers-only\":\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    case \"experimental-global-custom-1\":\n    // fallthrough\n    case \"experimental-global-custom-2\":\n      useGlobalCustomStickerer(puzzleStickering, m);\n      break;\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toAppearance();\n}\n\nexport async function cubeStickerings(): Promise<ExperimentalStickering[]> {\n  return [\n    \"full\",\n    \"PLL\",\n    \"CLS\",\n    \"OLL\",\n    \"COLL\",\n    \"OCLL\",\n    \"ELL\",\n    \"ELS\",\n    \"LL\",\n    \"F2L\",\n    \"ZBLL\",\n    \"ZBLS\",\n    \"WVLS\",\n    \"VLS\",\n    \"LS\",\n    \"EO\",\n    \"EOline\",\n    \"EOcross\",\n    \"CMLL\",\n    \"L6E\",\n    \"L6EO\",\n    \"Daisy\",\n    \"Cross\",\n    \"2x2x2\",\n    \"2x2x3\",\n    \"Void Cube\",\n    \"picture\",\n    \"invisible\",\n    \"centers-only\",\n  ];\n}\n","export function getCached<T>(getValue: () => Promise<T>): () => Promise<T> {\n  let cachedPromise: Promise<T> | null = null;\n  return (): Promise<T> => {\n    return (cachedPromise ??= getValue());\n  };\n}\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  cubeAppearance,\n  cubeStickerings,\n} from \"../../stickerings/cube-stickerings\";\n\nexport const cube2x2x2: PuzzleLoader = {\n  id: \"2x2x2\",\n  fullName: \"222 Cube\",\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"./2x2x2.kpuzzle.json\")).cube2x2x2KPuzzleDefinition,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"./2x2x2.kpuzzle.svg\")).default;\n  },\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"2x2x2\");\n  }),\n  appearance: (stickering: ExperimentalStickering): Promise<PuzzleAppearance> =>\n    cubeAppearance(cube2x2x2, stickering),\n  stickerings: cubeStickerings,\n};\n","// Include 3x3x3 in the main bundle for better performance.\nimport { experimental3x3x3KPuzzle } from \"../../../kpuzzle\";\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  cubeAppearance,\n  cubeStickerings,\n} from \"../../stickerings/cube-stickerings\";\n\nexport const cube3x3x3: PuzzleLoader = {\n  id: \"3x3x3\",\n  fullName: \"333 Cube\",\n  inventedBy: [\"Ern Rubik\"],\n  inventionYear: 1974, // https://en.wikipedia.org/wiki/Rubik%27s_Cube#Conception_and_development\n  kpuzzle: getCached(async () => {\n    return experimental3x3x3KPuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"./3x3x3.kpuzzle.svg\")).default;\n  }),\n  llSVG: getCached(async () => {\n    return (await import(\"./3x3x3-ll.kpuzzle.svg\")).default;\n  }),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"3x3x3\");\n  }),\n  appearance: (stickering: ExperimentalStickering): Promise<PuzzleAppearance> =>\n    cubeAppearance(cube3x3x3, stickering),\n  stickerings: cubeStickerings,\n};\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const clock: PuzzleLoader = {\n  id: \"clock\",\n  fullName: \"Clock\",\n  inventedBy: [\"Christopher C. Wiggs\", \"Christopher J. Taylor\"],\n  inventionYear: 1988, // Patent application year: https://www.jaapsch.net/puzzles/patents/us4869506.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"./clock.kpuzzle.json\")).clockKPuzzleDefinition,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"./clock.kpuzzle.svg\")).default;\n  }),\n};\n","import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  PuzzleAppearance,\n  PuzzleStickering,\n  StickeringManager,\n  PieceSet,\n  PieceStickering,\n} from \"./appearance\";\n\nexport async function ftoStickering(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<PuzzleAppearance> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const experimentalFTO_FC = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.or(m.moves([\"F\", \"BL\", \"BR\"])))]);\n  const experimentalFTO_F2T = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.move(\"F\"))]);\n  const experimentalFTO_SC = (): PieceSet =>\n    m.or([\n      experimentalFTO_F2T(),\n      m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"BL\", \"BR\"])))]),\n    ]);\n  const experimentalFTO_L2C = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"U\"), m.move(\"F\")]),\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n  const experimentalFTO_LBT = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"experimental-fto-fc\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_FC()),\n        PieceStickering.Ignored,\n      );\n      break;\n    case \"experimental-fto-f2t\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_F2T()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_FC(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-sc\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_SC()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_F2T(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-l2c\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_L2C()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_SC(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-lbt\":\n      puzzleStickering.set(\n        m.not(experimentalFTO_LBT()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_L2C(), PieceStickering.Dim);\n      break;\n    case \"experimental-fto-l3t\":\n      puzzleStickering.set(experimentalFTO_LBT(), PieceStickering.Dim);\n      break;\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toAppearance();\n}\n\nexport async function ftoStickerings(): Promise<ExperimentalStickering[]> {\n  return [\n    \"full\",\n    \"experimental-fto-fc\",\n    \"experimental-fto-f2t\",\n    \"experimental-fto-sc\",\n    \"experimental-fto-l2c\",\n    \"experimental-fto-lbt\",\n    \"experimental-fto-l3t\",\n  ];\n}\n","import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  ftoStickering,\n  ftoStickerings,\n} from \"../../stickerings/fto-stickerings\";\n\nclass FTOPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      pgID: \"FTO\",\n      id: \"fto\",\n      fullName: \"Face-Turning Octahedron\",\n      inventedBy: [\"Karl Rohrbach\", \"David Pitcher\"], // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n      inventionYear: 1983, // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n    });\n  }\n  appearance(stickering: ExperimentalStickering): Promise<PuzzleAppearance> {\n    return ftoStickering(this, stickering);\n  }\n  stickerings = ftoStickerings;\n}\n\nexport const fto = new FTOPuzzleLoader();\n","import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { PuzzleAppearance } from \"./appearance\";\nimport { cubeAppearance } from \"./cube-stickerings\";\n\n// TODO: cache calculations?\nexport async function megaminxAppearance(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<PuzzleAppearance> {\n  switch (stickering) {\n    case \"full\":\n    case \"F2L\":\n    case \"LL\":\n      return cubeAppearance(puzzleLoader, stickering);\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n  }\n  return cubeAppearance(puzzleLoader, \"full\");\n}\n\nexport async function megaminxStickerings(): Promise<ExperimentalStickering[]> {\n  return [\"full\", \"F2L\", \"LL\"];\n}\n","import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport type { PuzzleAppearance } from \"../../stickerings/appearance\";\nimport {\n  megaminxAppearance,\n  megaminxStickerings,\n} from \"../../stickerings/megaminx-stickerings\";\n\nclass MegaminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"megaminx\",\n      fullName: \"Megaminx\",\n      // Too many simultaneous inventors to name.\n      inventionYear: 1981, // Earliest date from https://www.jaapsch.net/puzzles/megaminx.htm\n    });\n  }\n  appearance(stickering: ExperimentalStickering): Promise<PuzzleAppearance> {\n    return megaminxAppearance(this, stickering);\n  }\n  stickerings = megaminxStickerings;\n}\n\nexport const megaminx = new MegaminxPuzzleLoader();\n","import { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\nclass PyraminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"pyraminx\",\n      fullName: \"Pyraminx\",\n      inventedBy: [\"Uwe Meffert\"],\n    });\n  }\n  svg = getCached(async () => {\n    return (await import(\"./pyraminx.kpuzzle.svg\")).default;\n  });\n}\n\nexport const pyraminx = new PyraminxPuzzleLoader();\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const square1: PuzzleLoader = {\n  id: \"square1\",\n  fullName: \"Square-1\",\n  inventedBy: [\"Karel Hrel\", \"Vojtech Kopsk\"],\n  inventionYear: 1990, // Czech patent application year: http://spisy.upv.cz/Patents/FullDocuments/277/277266.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (\n          await import(\"./sq1-hyperorbit.kpuzzle.json\")\n        ).sq1HyperOrbitKPuzzleDefinition,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"./sq1-hyperorbit.kpuzzle.svg\")).default;\n  }),\n};\n","import type { PuzzleLoader } from \"../..\";\nimport type { Move } from \"../../../alg\";\nimport { KPuzzle, KTransformationData } from \"../../../kpuzzle\";\nimport type { ExperimentalPGNotation } from \"../../../puzzle-geometry\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\n// TODO: Make this consistent with Megaminx corners\nexport const kilominx: PuzzleLoader = {\n  id: \"kilominx\",\n  fullName: \"Kilominx\",\n  kpuzzle: getCached(async () => {\n    const pg = await asyncGetPuzzleGeometry(\"megaminx + chopasaurus\");\n    const kpuzzleDefinition = JSON.parse(\n      JSON.stringify(pg.getKPuzzleDefinition(true)),\n    );\n    delete kpuzzleDefinition.orbits.CENTERS;\n    delete kpuzzleDefinition.orbits.CENTERS2;\n    delete kpuzzleDefinition.startStateData.CENTERS;\n    delete kpuzzleDefinition.startStateData.CENTERS2;\n    for (const moveDefinition of Object.values(kpuzzleDefinition.moves)) {\n      delete (moveDefinition as any).CENTERS;\n      delete (moveDefinition as any).CENTERS2;\n    }\n    kpuzzleDefinition.name = \"kilominx\";\n    delete kpuzzleDefinition.experimentalPuzzleDescription;\n    const puzzleGeometry = await import(\"../../../puzzle-geometry\");\n    const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n      pg,\n      pg.getOrbitsDef(true),\n    );\n    const kpuzzle = new KPuzzle(kpuzzleDefinition, {\n      experimentalPGNotation: {\n        lookupMove: (move: Move): KTransformationData | null => {\n          if (move.toString() === \"x2\" || move.toString() === \"x2'\") {\n            return x2Transformation.transformationData;\n          }\n          return pgNotation.lookupMove(move);\n        },\n      } as ExperimentalPGNotation,\n    });\n    const x2Transformation = kpuzzle.algToTransformation(\"Rv2 Fv Uv'\");\n    kpuzzleDefinition.moves[\"x2\"] = x2Transformation;\n    return kpuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"./kilominx.kpuzzle.svg\")).kilominxSVG;\n  }),\n};\n","import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const rediCube: PuzzleLoader = {\n  id: \"redi_cube\",\n  fullName: \"Redi Cube\",\n  // Announced 2009-07-21: https://www.youtube.com/watch?v=cjfMzA1u3vM\n  // https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1520\n  inventedBy: [\"Oskar van Deventer\"],\n  inventionYear: 2009,\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"./redi_cube.kpuzzle.json\")).rediCubeKPuzzleDefinition,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"./redi_cube.kpuzzle.svg\")).rediCubeSVG;\n  },\n};\n","export { experimental3x3x3KPuzzle } from \"../kpuzzle\";\nexport { customPGPuzzleLoader as experimentalCustomPGPuzzleLoader } from \"./customPGPuzzleLoader\";\nexport { eventInfo, wcaEventInfo } from \"./events\";\nexport { getFaceletAppearance as experimentalGetFaceletAppearance } from \"./stickerings/appearance\";\nexport type {\n  FaceletMeshAppearance as ExperimentalFaceletMeshAppearance,\n  PuzzleAppearance as ExperimentalPuzzleAppearance,\n} from \"./stickerings/appearance\";\nexport { cubeAppearance as experimentalCubeAppearance } from \"./stickerings/cube-stickerings\";\nexport type { PuzzleLoader };\nexport { cube2x2x2, cube3x3x3 };\n\nimport { CubePGPuzzleLoader, PGPuzzleLoader } from \"./async/async-pg3d\";\nimport { cube2x2x2 } from \"./implementations/2x2x2\";\nimport { cube3x3x3 } from \"./implementations/3x3x3\";\nimport { clock } from \"./implementations/clock\";\nimport { fto } from \"./implementations/fto\";\nimport { megaminx } from \"./implementations/megaminx\";\nimport { pyraminx } from \"./implementations/pyraminx\";\nimport { square1 } from \"./implementations/square1\";\nimport { kilominx } from \"./implementations/kilominx\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\nimport { rediCube } from \"./implementations/redi-cube\";\n\nexport const puzzles: Record<string, PuzzleLoader> = {\n  /******** Start of WCA Puzzles *******/\n  \"3x3x3\": cube3x3x3,\n  \"2x2x2\": cube2x2x2,\n  \"4x4x4\": new CubePGPuzzleLoader({ id: \"4x4x4\", fullName: \"444 Cube\" }),\n  \"5x5x5\": new CubePGPuzzleLoader({ id: \"5x5x5\", fullName: \"555 Cube\" }),\n  \"6x6x6\": new CubePGPuzzleLoader({ id: \"6x6x6\", fullName: \"666 Cube\" }),\n  \"7x7x7\": new CubePGPuzzleLoader({ id: \"7x7x7\", fullName: \"777 Cube\" }),\n  \"40x40x40\": new CubePGPuzzleLoader({\n    id: \"40x40x40\",\n    fullName: \"404040 Cube\",\n  }),\n  // 3x3x3 Blindfolded\n  // 3x3x3 Fewest Moves\n  // 3x3x3 One-Handed\n  clock,\n  \"megaminx\": megaminx,\n  pyraminx,\n  \"skewb\": new PGPuzzleLoader({\n    id: \"skewb\",\n    fullName: \"Skewb\",\n    inventedBy: [\"Tony Durham\"], // https://www.jaapsch.net/puzzles/skewb.htm\n    // inventionYear: 1982, // 1982 is actually the year of Hofstadter's column.\n  }),\n  square1,\n  // 4x4x4 Blindfolded\n  // 5x5x5 Blindfolded\n  /******** End of WCA puzzles ********/\n  \"fto\": fto,\n  \"gigaminx\": new PGPuzzleLoader({\n    id: \"gigaminx\",\n    fullName: \"Gigaminx\",\n    inventedBy: [\"Tyler Fox\"],\n    inventionYear: 2006, // Earliest date from https://www.twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1475\n  }),\n  \"master_tetraminx\": new PGPuzzleLoader({\n    pgID: \"master tetraminx\",\n    id: \"master_tetraminx\",\n    fullName: \"Master Tetraminx\",\n    inventedBy: [\"Katsuhiko Okamoto\"], // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n    inventionYear: 2002, // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n  }),\n  kilominx,\n  \"redi_cube\": rediCube,\n};\n","import { isOrbitTransformationDataIdentityUncached } from \"./calculate\";\nimport type {\n  KPuzzleDefinition,\n  KStateData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\n\nexport function combineTransformationData(\n  definition: KPuzzleDefinition,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): KTransformationData {\n  const newTransformationData = {} as KTransformationData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = transformationData1[orbitName];\n    const orbit2 = transformationData2[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newTransformationData[orbitName] = orbit1;\n    } else if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit1,\n      )\n    ) {\n      newTransformationData[orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\n\nexport function applyTransformationDataToStateData(\n  definition: KPuzzleDefinition,\n  stateData: KStateData,\n  transformationData: KTransformationData,\n): KStateData {\n  const newStateData = {} as KStateData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = stateData[orbitName];\n    const orbit2 = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newStateData[orbitName] = orbit1;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newStateData;\n}\n","import type { Move } from \"../alg\";\nimport { repeatTransformationUncached } from \"./calculate\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\n\nconst FREEZE: boolean = false;\n\nconst identityOrbitCache = new Map<number, KTransformationOrbitData>();\nfunction constructIdentityOrbitTransformation(\n  numPieces: number,\n): KTransformationOrbitData {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientation: newOrientation,\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation); // TODO\n    Object.freeze(newOrientation); // TODO\n    Object.freeze(orbitTransformation); // TODO\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\n\nexport function constructIdentityTransformationDataUncached(\n  definition: KPuzzleDefinition,\n): KTransformationData {\n  const transformation = {} as KTransformationData;\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    definition.orbits,\n  )) {\n    transformation[orbitName] = constructIdentityOrbitTransformation(\n      orbitDefinition.numPieces,\n    );\n  }\n  if (FREEZE) {\n    Object.freeze(transformation); // TODO\n  }\n  return transformation;\n}\n\nexport function moveToTransformationUncached(\n  kpuzzle: KPuzzle,\n  move: Move,\n): KTransformationData {\n  const quantumKey = move.quantum.toString();\n  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey] as\n    | KTransformationData\n    | undefined;\n\n  if (!quantumMoveDefinition) {\n    const derivedFrom =\n      kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];\n\n    if (derivedFrom) {\n      // TODO: avoid the round trip?\n      quantumMoveDefinition =\n        kpuzzle.algToTransformation(derivedFrom).transformationData;\n    }\n  }\n\n  if (quantumMoveDefinition) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      quantumMoveDefinition,\n      move.amount,\n    );\n  }\n\n  // Handle e.g. `y2` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const moveDefinition = kpuzzle.definition.moves[move.toString()];\n  if (moveDefinition) {\n    return moveDefinition;\n  }\n\n  // Handle e.g. `y2'` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const inverseMoveDefinition =\n    kpuzzle.definition.moves[move.invert().toString()];\n  if (inverseMoveDefinition) {\n    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);\n  }\n\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n","import type { KPuzzle, KTransformationData } from \".\";\nimport type { Alg, Move } from \"../alg\";\nimport { applyTransformationDataToStateData } from \"./combine\";\nimport type { KTransformationSource } from \"./KPuzzle\";\nimport type { KStateData, KTransformationOrbitData } from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport class KState {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly stateData: KStateData,\n  ) {}\n\n  static fromTransformation(transformation: KTransformation): KState {\n    const newStateData = applyTransformationDataToStateData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.startStateData,\n      transformation.transformationData,\n    );\n    return new KState(transformation.kpuzzle, newStateData);\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KState {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(transformation: KTransformation): KState {\n    if (transformation.isIdentityTransformation()) {\n      return new KState(this.kpuzzle, this.stateData);\n    }\n    const newStateData = applyTransformationDataToStateData(\n      this.kpuzzle.definition,\n      this.stateData,\n      transformation.transformationData,\n    );\n    return new KState(this.kpuzzle, newStateData);\n  }\n\n  applyMove(move: Move | string): KState {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KState {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  /** @deprecated */\n  experimentalToTransformation(): KTransformation | null {\n    if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData: KTransformationData = {};\n    for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {\n      const transformationOrbit: KTransformationOrbitData = {\n        permutation: stateOrbitData.pieces,\n        orientation: stateOrbitData.orientation,\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n}\n","import type { Alg, Move } from \"../alg\";\nimport {\n  invertTransformation,\n  isTransformationDataIdentical,\n  repeatTransformationUncached,\n  transformationRepetitionOrder,\n} from \"./calculate\";\nimport { combineTransformationData } from \"./combine\";\nimport { constructIdentityTransformationDataUncached } from \"./construct\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type { KTransformationData } from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\n\nexport class KTransformation {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly transformationData: KTransformationData,\n  ) {}\n\n  invert(): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData),\n    );\n  }\n\n  // For optimizations, we want to make it cheap to rely on optimizations when a\n  // transformation is an identity. Here, we try to make it cheaper by:\n  // - only calculating when needed, and\n  // - caching the result.\n  #cachedIsIdentity: boolean | undefined; // TODO: is `null` worse here?\n  isIdentityTransformation(): boolean {\n    return (this.#cachedIsIdentity ??= this.isIdentical(\n      this.kpuzzle.identityTransformation(),\n    ));\n  }\n\n  /** @deprecated */\n  static experimentalConstructIdentity(kpuzzle: KPuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition),\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n\n  isIdentical(t2: KTransformation): boolean {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData,\n    );\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KTransformation {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(t2: KTransformation): KTransformation {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`,\n      );\n    }\n\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData,\n      ),\n    );\n  }\n\n  applyMove(move: Move | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  // Convenience. Useful for chaining.\n  toKState(): KState {\n    return KState.fromTransformation(this);\n  }\n\n  repetitionOrder(): number {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n\n  selfMultiply(amount: number): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount,\n      ),\n    );\n  }\n}\n","import type { KPuzzleDefinition } from \".\";\nimport {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalDownUp,\n} from \"../alg\";\nimport { combineTransformationData } from \"./combine\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KOrbitDefinition,\n  KTransformationOrbitData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport function isOrbitTransformationDataIdentityUncached(\n  numOrientations: number,\n  orbitTransformationData: KTransformationOrbitData,\n): boolean {\n  // TODO\n  // if (o === lasto) {\n  //   return true;\n  // }\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  // lasto = o; // TODO\n  return true;\n}\n\nexport function isOrbitTransformationDataIdentical(\n  orbitDefinition: KOrbitDefinition,\n  orbitTransformationData1: KTransformationOrbitData,\n  orbitTransformationData2: KTransformationOrbitData,\n  options: {\n    ignoreOrientation?: boolean;\n    ignorePermutation?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignoreOrientation &&\n      orbitTransformationData1.orientation[idx] !==\n        orbitTransformationData2.orientation[idx]\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePermutation &&\n      orbitTransformationData1.permutation[idx] !==\n        orbitTransformationData2.permutation[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransformationDataIdentical(\n  kpuzzle: KPuzzle,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    kpuzzle.definition.orbits,\n  )) {\n    if (\n      !isOrbitTransformationDataIdentical(\n        orbitDefinition,\n        transformationData1[orbitName],\n        transformationData2[orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function invertTransformation(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n): KTransformationData {\n  const newTransformationData: KTransformationData = {};\n  for (const orbitName in kpuzzle.definition.orbits) {\n    const orbitDefinition: KOrbitDefinition =\n      kpuzzle.definition.orbits[orbitName];\n    const orbitTransformationData = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbitTransformationData,\n      )\n    ) {\n      newTransformationData[orbitName] = orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: orbitTransformationData.orientation,\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] =\n          (orbitDefinition.numOrientations -\n            orbitTransformationData.orientation[idx] +\n            orbitDefinition.numOrientations) %\n          orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: newOri,\n      };\n    }\n  }\n  return newTransformationData;\n}\n\nexport function repeatTransformationUncached(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n  amount: number,\n): KTransformationData {\n  // This is used for move construction, so we optimize for the quantum move case.\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount,\n    );\n  }\n  if (amount === 0) {\n    // TODO\n    const { transformationData } = kpuzzle.identityTransformation();\n    return transformationData;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2),\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish,\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish,\n    );\n  }\n}\n\nclass AlgToTransformationTraversal extends TraversalDownUp<\n  KPuzzle,\n  KTransformation\n> {\n  traverseAlg(alg: Alg, kpuzzle: KPuzzle): KTransformation {\n    let transformation: KTransformation | null = null;\n    for (const unit of alg.units()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseUnit(unit, kpuzzle),\n        );\n      } else {\n        transformation = this.traverseUnit(unit, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping: Grouping, kpuzzle: KPuzzle): KTransformation {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount,\n      ),\n    );\n  }\n  traverseMove(move: Move, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(\n    commutator: Commutator,\n    kpuzzle: KPuzzle,\n  ): KTransformation {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert())\n      .applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate: Conjugate, kpuzzle: KPuzzle): KTransformation {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert());\n  }\n  traversePause(_: Pause, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_: Newline, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_: LineComment, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n}\n\nconst algToTransformationInstance = new AlgToTransformationTraversal();\nexport const algToTransformation = algToTransformationInstance.traverseAlg.bind(\n  algToTransformationInstance,\n) as (alg: Alg, kpuzzle: KPuzzle) => KTransformation;\n\nexport function canConvertStateToUniqueTransformationUncached(\n  definition: KPuzzleDefinition,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(definition)) {\n    const pieces = new Array(orbitDefinition.numPieces).fill(false);\n    for (const piece of this.definition.startStateData[orbitName].pieces) {\n      pieces[piece] = true;\n    }\n    for (const piece of pieces) {\n      if (!piece) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n\n/* calculate the order of a particular transformation. */\nexport function transformationRepetitionOrder(\n  definition: KPuzzleDefinition,\n  transformation: KTransformation,\n): number {\n  let order: number = 1;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const transformationOrbit = transformation.transformationData[orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (;;) {\n          orbitPieces[currentIdx] = true;\n          orientationSum =\n            orientationSum + transformationOrbit.orientation[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength =\n            (cycleLength * orbitDefinition.numOrientations) /\n            gcd(orbitDefinition.numOrientations, orientationSum);\n        }\n        order = (order * cycleLength) / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n","import { Alg, Move } from \"../alg\";\nimport type { PGNotation } from \"../puzzle-geometry/PuzzleGeometry\";\nimport { algToTransformation } from \"./calculate\";\nimport { moveToTransformationUncached } from \"./construct\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport type KTransformationSource = Alg | Move | string | KTransformation;\n\nexport class KPuzzle {\n  private experimentalPGNotation: PGNotation | undefined;\n  constructor(\n    public readonly definition: KPuzzleDefinition,\n    options?: {\n      experimentalPGNotation?: PGNotation;\n    },\n  ) {\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n\n  name(): string {\n    return this.definition.name; // TODO\n  }\n\n  identityTransformation(): KTransformation {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n\n  #moveToTransformationDataCache = new Map<string, KTransformationData>();\n  moveToTransformation(move: Move | string): KTransformation {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData: KTransformationData | undefined =\n      this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n\n    if (this.experimentalPGNotation) {\n      const transformationData = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n      return new KTransformation(this, transformationData);\n    }\n\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n\n  algToTransformation(alg: Alg | string): KTransformation {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n\n  /** @deprecated */\n  toTransformation(source: KTransformationSource): KTransformation {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if ((source as Alg | null)?.is?.(Alg)) {\n      return this.algToTransformation(source as Alg);\n    } else if ((source as Move | null)?.is?.(Move)) {\n      return this.moveToTransformation(source as Move);\n    } else {\n      return source as KTransformation;\n    }\n  }\n\n  startState(): KState {\n    return new KState(this, this.definition.startStateData);\n  }\n\n  #cachedCanConvertStateToUniqueTransformation: boolean | undefined;\n  // TODO: Handle incomplete start state data\n  canConvertStateToUniqueTransformation(): boolean {\n    return (this.#cachedCanConvertStateToUniqueTransformation ??=\n      ((): boolean => {\n        for (const [orbitName, orbitDefinition] of Object.entries(\n          this.definition.orbits,\n        )) {\n          const pieces = new Array(orbitDefinition.numPieces).fill(false);\n          for (const piece of this.definition.startStateData[orbitName]\n            .pieces) {\n            pieces[piece] = true;\n          }\n          for (const piece of pieces) {\n            if (!piece) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })());\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  get state(): never {\n    throw new Error(\"KPuzzle is now a different (stateless) class.\");\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  reset(): never {\n    throw new Error(\"KPuzzle is now a different (stateless) class.\");\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  applyMove(_move: Move): never {\n    throw new Error(\n      \"KPuzzle is now a different class. Try `.moveToTransformation()` to get the transformation for a move.\",\n    );\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  applyAlg(_alg: Alg): never {\n    throw new Error(\n      \"KPuzzle is now a different class. Try `.algToTransformation()` to get the transformation for an alg.\",\n    );\n  }\n}\n","// TODO: This file is here to avoid dependency loops, but it should eventually\n// move back into `cubing/puzzles`. We currently have a few functions that are\n// hardcoded to require synchronous access to this definition, and we need to\n// find a better way to do that.\n\nimport type { KPuzzleDefinition } from \"../KPuzzleDefinition\";\n\nexport const cube3x3x3KPuzzleDefinition: KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: {\n    EDGES: { numPieces: 12, numOrientations: 2 },\n    CORNERS: { numPieces: 8, numOrientations: 3 },\n    CENTERS: { numPieces: 6, numOrientations: 4 },\n  },\n  startStateData: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0],\n    },\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 3],\n      },\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientation: [2, 1, 2, 1, 1, 2, 1, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 3, 0, 1, 2, 2],\n      },\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 1, 0, 0, 0, 0],\n      },\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 1, 0, 0, 0],\n      },\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 1, 0, 0],\n      },\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 1, 0],\n      },\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientation: [1, 2, 1, 2, 2, 1, 2, 1],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 3, 1],\n      },\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 0, 0, 0, 2, 0],\n      },\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 0],\n      },\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 0, 1, 0, 1],\n      },\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 1, 0, 0, 2, 0],\n      },\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 0, 1],\n      },\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 0, 0, 1, 2, 2],\n      },\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientation: [3, 3, 0, 3, 1, 3],\n      },\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n  },\n};\n\ncube3x3x3KPuzzleDefinition.moves[\"Uw\"] = cube3x3x3KPuzzleDefinition.moves[\"u\"];\ncube3x3x3KPuzzleDefinition.moves[\"Lw\"] = cube3x3x3KPuzzleDefinition.moves[\"l\"];\ncube3x3x3KPuzzleDefinition.moves[\"Fw\"] = cube3x3x3KPuzzleDefinition.moves[\"f\"];\ncube3x3x3KPuzzleDefinition.moves[\"Rw\"] = cube3x3x3KPuzzleDefinition.moves[\"r\"];\ncube3x3x3KPuzzleDefinition.moves[\"Bw\"] = cube3x3x3KPuzzleDefinition.moves[\"b\"];\ncube3x3x3KPuzzleDefinition.moves[\"Dw\"] = cube3x3x3KPuzzleDefinition.moves[\"d\"];\n\ncube3x3x3KPuzzleDefinition.moves[\"Rv\"] = cube3x3x3KPuzzleDefinition.moves[\"x\"];\ncube3x3x3KPuzzleDefinition.moves[\"Uv\"] = cube3x3x3KPuzzleDefinition.moves[\"y\"];\ncube3x3x3KPuzzleDefinition.moves[\"Fv\"] = cube3x3x3KPuzzleDefinition.moves[\"z\"];\ncube3x3x3KPuzzleDefinition.moves[\"Lv\"] = {\n  EDGES: {\n    permutation: [2, 10, 6, 11, 0, 8, 4, 9, 1, 3, 5, 7],\n    orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n  },\n  CORNERS: {\n    permutation: [1, 7, 6, 2, 0, 3, 5, 4],\n    orientation: [2, 1, 2, 1, 1, 2, 1, 2],\n  },\n  CENTERS: {\n    permutation: [4, 1, 0, 3, 5, 2],\n    orientation: [2, 1, 0, 3, 2, 0],\n  },\n};\ncube3x3x3KPuzzleDefinition.moves[\"Dv\"] = {\n  EDGES: {\n    permutation: [3, 0, 1, 2, 7, 4, 5, 6, 9, 11, 8, 10],\n    orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n  },\n  CORNERS: {\n    permutation: [3, 0, 1, 2, 5, 6, 7, 4],\n    orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n  },\n  CENTERS: {\n    permutation: [0, 4, 1, 2, 3, 5],\n    orientation: [3, 0, 0, 0, 0, 1],\n  },\n};\ncube3x3x3KPuzzleDefinition.moves[\"Bv\"] = {\n  EDGES: {\n    permutation: [8, 5, 10, 1, 9, 7, 11, 3, 4, 0, 6, 2],\n    orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  },\n  CORNERS: {\n    permutation: [4, 7, 1, 0, 5, 3, 2, 6],\n    orientation: [1, 2, 1, 2, 2, 1, 2, 1],\n  },\n  CENTERS: {\n    permutation: [3, 0, 2, 5, 4, 1],\n    orientation: [3, 3, 3, 3, 1, 3],\n  },\n};\n","export { KPuzzle } from \"./KPuzzle\";\nexport type {\n  KPuzzleDefinition,\n  KStateData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nexport { KState } from \"./KState\";\nexport { KTransformation } from \"./KTransformation\";\n\nimport { cube3x3x3KPuzzleDefinition } from \"./3x3x3/3x3x3.kpuzzle.json\";\nimport { KPuzzle } from \"./KPuzzle\";\nexport const experimental3x3x3KPuzzle = new KPuzzle(cube3x3x3KPuzzleDefinition);\n","export enum IterationDirection {\n  Forwards = 1,\n  Backwards = -1,\n}\n\nexport function toggleDirection(\n  iterationDirection: IterationDirection,\n  flip: boolean = true,\n): IterationDirection {\n  if (!flip) {\n    return iterationDirection;\n  }\n  switch (iterationDirection) {\n    case IterationDirection.Forwards:\n      return IterationDirection.Backwards;\n    case IterationDirection.Backwards:\n      return IterationDirection.Forwards;\n  }\n}\n\nexport function direct<T>(\n  g: Iterable<T>,\n  iterDir: IterationDirection,\n): Iterable<T> {\n  return iterDir === IterationDirection.Backwards ? Array.from(g).reverse() : g;\n}\n\nexport function reverse<T>(g: Iterable<T>): Iterable<T> {\n  return Array.from(g).reverse();\n}\n\nexport function* directedGenerator<T>(\n  g: Generator<T>,\n  direction: IterationDirection,\n): Generator<T> {\n  direction === IterationDirection.Backwards\n    ? yield* reverseGenerator(g)\n    : yield* g;\n}\n\nexport function* reverseGenerator<T>(g: Generator<T>): Generator<T> {\n  for (const t of Array.from(g).reverse()) {\n    yield t;\n  }\n}\n","import type { Alg } from \"./Alg\";\nimport type { IterationDirection } from \"./iteration\";\nimport type { LeafUnit, Unit } from \"./units/Unit\";\n\nlet writeAlgDebugField = false;\nexport function setAlgDebugField(debug: boolean): void {\n  writeAlgDebugField = debug;\n}\n\nexport abstract class Comparable {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  is(c: any): boolean {\n    return this instanceof c;\n  }\n\n  as<T>(c: new (...args: any) => T): T | null {\n    return this instanceof c ? this : null;\n  }\n\n  abstract isIdentical(other: Comparable): boolean;\n}\n\nexport interface Repeatable extends Comparable {\n  experimentalExpand(\n    iterDir?: IterationDirection,\n    depth?: number,\n  ): Generator<LeafUnit>;\n}\n\n// Common to algs or units\nexport abstract class AlgCommon<T extends Alg | Unit>\n  extends Comparable\n  implements Repeatable\n{\n  constructor() {\n    super();\n    if (writeAlgDebugField) {\n      Object.defineProperty(this, \"_debugStr\", {\n        get: () => {\n          return this.toString();\n        },\n      });\n    }\n  }\n\n  get log(): (message?: any) => void {\n    // By returning a (bound) version of `console.log`, we ensure that DevTools\n    // logs the call site instead of this function.\n    return console.log.bind(console, this, this.toString()) as (\n      message?: any,\n    ) => void;\n  }\n\n  abstract toString(): string;\n\n  abstract invert(): T;\n\n  abstract experimentalExpand(iterDir: IterationDirection): Generator<LeafUnit>;\n}\n","export const MAX_INT = 0x7fffffff; // 2^32-1, the max value for signed 32-bit ints.\nexport const MAX_INT_DESCRIPTION = \"2^31 - 1\";\nexport const MIN_INT = -0x80000000;\nexport const MINT_INT_DESCRIPTION = \"-2^31\";\n","import { Alg } from \"./Alg\";\nimport type { Unit } from \"./units/Unit\";\n\nexport class AlgBuilder {\n  #units: Unit[] = [];\n\n  push(u: Unit): void {\n    this.#units.push(u);\n  }\n\n  // TODO: Allow FlexibleAlgSource?\n  /** @deprecated */\n  experimentalPushAlg(alg: Alg): void {\n    // TODO: Optimize?\n    for (const u of alg.units()) {\n      this.push(u);\n    }\n  }\n\n  // TODO: can we guarantee this to be fast in the permanent API?\n  experimentalNumUnits(): number {\n    return this.#units.length;\n  }\n\n  // can be called multiple times, even if you push units inbetween.\n  toAlg(): Alg {\n    return new Alg(this.#units);\n  }\n\n  reset(): void {\n    this.#units = [];\n  }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\nexport class Commutator extends AlgCommon<Commutator> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsCommutator = other.as(Commutator);\n    return !!(\n      otherAsCommutator?.A.isIdentical(this.A) &&\n      otherAsCommutator?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Commutator {\n    return new Commutator(this.#B, this.#A);\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      if (iterDir === IterationDirection.Forwards) {\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      } else {\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      }\n    }\n  }\n\n  toString(): string {\n    return `[${this.#A.toString()}, ${this.#B.toString()}]`;\n  }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\nexport class Conjugate extends AlgCommon<Conjugate> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsConjugate = other.as(Conjugate);\n    return !!(\n      otherAsConjugate?.A.isIdentical(this.A) &&\n      otherAsConjugate?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Conjugate {\n    return new Conjugate(this.#A, this.#B.invert());\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.A.experimentalExpand(IterationDirection.Forwards, depth - 1);\n      yield* this.B.experimentalExpand(iterDir, depth - 1);\n      yield* this.A.experimentalExpand(IterationDirection.Backwards, depth - 1);\n    }\n  }\n\n  toString(): string {\n    return `[${this.A}: ${this.B}]`;\n  }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\n// TODO: hash\n// TODO: this conflicts with the HTML `LineComment` class\nexport class LineComment extends AlgCommon<LineComment> {\n  readonly #text: string;\n\n  constructor(commentText: string) {\n    super();\n    if (commentText.includes(\"\\n\") || commentText.includes(\"\\r\")) {\n      throw new Error(\"LineComment cannot contain newline\");\n    }\n    this.#text = commentText;\n  }\n\n  get text(): string {\n    return this.#text;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsLineComment = other as LineComment;\n    return other.is(LineComment) && this.#text === otherAsLineComment.#text;\n  }\n\n  invert(): LineComment {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<LeafUnit> {\n    yield this;\n  }\n\n  toString(): string {\n    return `//${this.#text}`;\n  }\n\n  // toJSON(): LineCommentJSON {\n  //   return {\n  //     type: \"comment\",\n  //     text: this.#text,\n  //   };\n  // }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\nexport class Newline extends AlgCommon<Newline> {\n  toString(): string {\n    return `\\n`;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Newline);\n  }\n\n  invert(): Newline {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<LeafUnit> {\n    yield this;\n  }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { LeafUnit } from \"../Unit\";\n\nexport class Pause extends AlgCommon<Pause> {\n  toString(): string {\n    return `.`;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Pause);\n  }\n\n  invert(): Pause {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<LeafUnit> {\n    yield this;\n  }\n}\n","import { Alg } from \"./Alg\";\nimport { AlgBuilder } from \"./AlgBuilder\";\nimport type { Unit } from \"./units\";\nimport { Commutator } from \"./units/containers/Commutator\";\nimport { Conjugate } from \"./units/containers/Conjugate\";\nimport { Grouping } from \"./units/containers/Grouping\";\nimport { LineComment } from \"./units/leaves/LineComment\";\nimport { Move, QuantumMove } from \"./units/leaves/Move\";\nimport { Newline } from \"./units/leaves/Newline\";\nimport { Pause } from \"./units/leaves/Pause\";\n\ntype StoppingChar = \",\" | \":\" | \"]\" | \")\";\n\nfunction parseIntWithEmptyFallback<T>(n: string, emptyFallback: T): number | T {\n  return n ? parseInt(n) : emptyFallback;\n}\n\nconst amountRegex = /^(\\d+)?('?)/;\nconst moveStartRegex = /^[_\\dA-Za-z]/; // TODO: Handle slash\nconst quantumMoveRegex = /^((([1-9]\\d*)-)?([1-9]\\d*))?([_A-Za-z]+)?/;\nconst commentTextRegex = /^[^\\n]*/;\nconst square1PairStart = /^(-?\\d+), ?/; // TODO: match up with other whitespace handling?\nconst square1PairEnd = /^(-?\\d+)\\)/; // TODO: match up with other whitespace handling?\n\nexport function parseAlg(s: string): Alg {\n  return new AlgParser().parseAlg(s);\n}\n\nexport function parseMove(s: string): Move {\n  return new AlgParser().parseMove(s);\n}\n\nexport function parseQuantumMove(s: string): QuantumMove {\n  return new AlgParser().parseQuantumMove(s);\n}\n\nexport interface ParserIndexed {\n  startCharIndex: number;\n  endCharIndex: number;\n}\n\nexport type Parsed<T extends Alg | Unit> = T & ParserIndexed;\n\n// TODO: attach to parser so the end char index can default to `this.#idx`?\nfunction addCharIndices<T extends Alg | Unit>(\n  t: T,\n  startCharIndex: number,\n  endCharIndex: number,\n): Parsed<T> {\n  const parsedT = t as ParserIndexed & T;\n  parsedT.startCharIndex = startCharIndex;\n  parsedT.endCharIndex = endCharIndex;\n  return parsedT;\n}\n\nexport function transferCharIndex<T extends Alg | Unit>(from: T, to: T): T {\n  if (\"startCharIndex\" in from) {\n    (to as Parsed<T>).startCharIndex = (from as Parsed<T>).startCharIndex;\n  }\n  if (\"endCharIndex\" in from) {\n    (to as Parsed<T>).endCharIndex = (from as Parsed<T>).endCharIndex;\n  }\n  return to;\n}\n\ntype MoveSuffix = \"+\" | \"++\" | \"-\" | \"--\";\n\n// TODO: support recording string locations for moves.\nclass AlgParser {\n  #input: string = \"\";\n  #idx: number = 0;\n\n  parseAlg(input: string): Parsed<Alg> {\n    this.#input = input;\n    this.#idx = 0;\n    const alg = this.parseAlgWithStopping([]);\n    this.mustBeAtEndOfInput();\n    return alg;\n  }\n\n  parseMove(input: string): Parsed<Move> {\n    this.#input = input;\n    this.#idx = 0;\n    const move = this.parseMoveImpl();\n    this.mustBeAtEndOfInput();\n    return move;\n  }\n\n  parseQuantumMove(input: string): QuantumMove {\n    this.#input = input;\n    this.#idx = 0;\n    const quantumMove = this.parseQuantumMoveImpl();\n    this.mustBeAtEndOfInput();\n    return quantumMove;\n  }\n\n  private mustBeAtEndOfInput() {\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"parsing unexpectedly ended early\");\n    }\n  }\n\n  private parseAlgWithStopping(stopBefore: StoppingChar[]): Parsed<Alg> {\n    let algStartIdx = this.#idx;\n    let algEndIdx = this.#idx;\n    const algBuilder = new AlgBuilder();\n\n    // We're \"crowded\" if there was not a space or newline since the last unit.\n    let crowded = false;\n\n    const mustNotBeCrowded = (idx: number): void => {\n      if (crowded) {\n        throw new Error(\n          `Unexpected character at index ${idx}. Are you missing a space?`,\n        ); // TODO better error message\n      }\n    };\n\n    mainLoop: while (this.#idx < this.#input.length) {\n      const savedCharIndex = this.#idx;\n      if ((stopBefore as string[]).includes(this.#input[this.#idx])) {\n        return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n      }\n      if (this.tryConsumeNext(\" \")) {\n        crowded = false;\n        if (algBuilder.experimentalNumUnits() === 0) {\n          algStartIdx = this.#idx;\n        }\n        continue mainLoop;\n      } else if (moveStartRegex.test(this.#input[this.#idx])) {\n        mustNotBeCrowded(savedCharIndex);\n        const move = this.parseMoveImpl();\n        algBuilder.push(move);\n        crowded = true;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"(\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const sq1PairStartMatch = this.tryRegex(square1PairStart);\n        if (sq1PairStartMatch) {\n          const topAmountString = sq1PairStartMatch[1];\n          const savedCharIndexD = this.#idx;\n          const sq1PairEndMatch = this.parseRegex(square1PairEnd);\n          const uMove = addCharIndices(\n            new Move(new QuantumMove(\"U_SQ_\"), parseInt(topAmountString)),\n            savedCharIndex + 1,\n            savedCharIndex + 1 + topAmountString.length,\n          );\n          const dMove = addCharIndices(\n            new Move(new QuantumMove(\"D_SQ_\"), parseInt(sq1PairEndMatch[1])),\n            savedCharIndexD,\n            this.#idx - 1,\n          );\n          const alg = addCharIndices(\n            new Alg([uMove, dMove]),\n            savedCharIndex + 1,\n            this.#idx - 1,\n          );\n          algBuilder.push(\n            addCharIndices(new Grouping(alg), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        } else {\n          const alg = this.parseAlgWithStopping([\")\"]);\n          this.mustConsumeNext(\")\");\n          const amount = this.parseAmount();\n          algBuilder.push(\n            addCharIndices(\n              new Grouping(alg, amount),\n              savedCharIndex,\n              this.#idx,\n            ),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\"[\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const A = this.parseAlgWithStopping([\",\", \":\"]);\n        const separator = this.popNext();\n        const B = this.parseAlgWithStopping([\"]\"]);\n        this.mustConsumeNext(\"]\");\n        switch (separator) {\n          case \":\":\n            algBuilder.push(\n              addCharIndices(new Conjugate(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          case \",\":\n            algBuilder.push(\n              addCharIndices(new Commutator(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          default:\n            throw \"unexpected parsing error\";\n        }\n      } else if (this.tryConsumeNext(\"\\n\")) {\n        algBuilder.push(\n          addCharIndices(new Newline(), savedCharIndex, this.#idx),\n        );\n        crowded = false;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"/\")) {\n        if (this.tryConsumeNext(\"/\")) {\n          mustNotBeCrowded(savedCharIndex);\n          const [text] = this.parseRegex(commentTextRegex);\n          algBuilder.push(\n            addCharIndices(new LineComment(text), savedCharIndex, this.#idx),\n          );\n          crowded = false;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        } else {\n          // We allow crowding here to account for csTimer scrambles, which don't have a space between a Square-1 tuple and the following slash.\n          algBuilder.push(\n            addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\".\")) {\n        mustNotBeCrowded(savedCharIndex);\n        algBuilder.push(addCharIndices(new Pause(), savedCharIndex, this.#idx));\n        crowded = true;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else {\n        throw new Error(`Unexpected character: ${this.popNext()}`);\n      }\n    }\n\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"did not finish parsing?\");\n    }\n    if (stopBefore.length > 0) {\n      throw new Error(\"expected stopping\");\n    }\n    return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n  }\n\n  private parseQuantumMoveImpl(): QuantumMove {\n    const [, , , outerLayerStr, innerLayerStr, family] =\n      this.parseRegex(quantumMoveRegex);\n\n    return new QuantumMove(\n      family,\n      parseIntWithEmptyFallback(innerLayerStr, undefined),\n      parseIntWithEmptyFallback(outerLayerStr, undefined),\n    );\n  }\n\n  private parseMoveImpl(): Parsed<Move> {\n    const savedCharIndex = this.#idx;\n\n    if (this.tryConsumeNext(\"/\")) {\n      return addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx);\n    }\n\n    let quantumMove = this.parseQuantumMoveImpl();\n    // Only `hadEmptyAbsAmount` is `const`.\n    // eslint-disable-next-line prefer-const\n    let [amount, hadEmptyAbsAmount] = this.parseAmountAndTrackEmptyAbsAmount();\n    const suffix = this.parseMoveSuffix();\n\n    if (suffix) {\n      if (amount < 0) {\n        throw new Error(\"uh-oh\");\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && amount !== 1) {\n        // TODO: Handle 1 vs. null\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount other than 1.\",\n        );\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && !hadEmptyAbsAmount) {\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount written as a number.\",\n        );\n      }\n      if ((suffix === \"+\" || suffix === \"-\") && hadEmptyAbsAmount) {\n        throw new Error(\n          \"Clock dial moves must have an amount written as a natural number followed by + or -.\",\n        );\n      }\n      if (suffix.startsWith(\"+\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"+\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n      }\n      if (suffix.startsWith(\"-\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"-\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n        amount *= -1;\n      }\n    }\n\n    const move = addCharIndices(\n      new Move(quantumMove, amount),\n      savedCharIndex,\n      this.#idx,\n    );\n    return move;\n  }\n\n  private parseMoveSuffix(): MoveSuffix | null {\n    if (this.tryConsumeNext(\"+\")) {\n      if (this.tryConsumeNext(\"+\")) {\n        return \"++\";\n      }\n      return \"+\";\n    }\n    if (this.tryConsumeNext(\"-\")) {\n      if (this.tryConsumeNext(\"-\")) {\n        return \"--\";\n      }\n      return \"-\";\n    }\n    return null;\n  }\n\n  private parseAmountAndTrackEmptyAbsAmount(): [number, boolean] {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(amountRegex);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return [\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1),\n      !absAmountStr,\n    ];\n  }\n\n  private parseAmount(): number {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(amountRegex);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount number can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return (\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1)\n    );\n  }\n\n  private parseRegex(regex: RegExp): RegExpExecArray {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      throw new Error(\"internal parsing error\"); // TODO\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  // TOD: can we avoid this?\n  private tryRegex(regex: RegExp): RegExpExecArray | null {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      return null;\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  private remaining(): string {\n    return this.#input.slice(this.#idx);\n  }\n\n  private popNext(): string {\n    const next = this.#input[this.#idx];\n    this.#idx++;\n    return next;\n  }\n\n  private tryConsumeNext(expected: string): boolean {\n    if (this.#input[this.#idx] === expected) {\n      this.#idx++;\n      return true;\n    }\n    return false;\n  }\n\n  private mustConsumeNext(expected: string): string {\n    const next = this.popNext();\n    if (next !== expected) {\n      throw new Error(\n        `expected \\`${expected}\\` while parsing, encountered ${next}`,\n      ); // TODO: be more helpful\n    }\n    return next;\n  }\n}\n","const warned = new Set<string>();\nexport function warnOnce(s: string): void {\n  if (!warned.has(s)) {\n    console.warn(s);\n    warned.add(s);\n  }\n}\n","import type { Repeatable } from \"../common\";\nimport { IterationDirection, toggleDirection } from \"../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION, MIN_INT } from \"../limits\";\nimport type { LeafUnit } from \"./Unit\";\n\nexport class QuantumWithAmount<Q extends Repeatable> {\n  readonly quantum: Q;\n  readonly amount: number;\n\n  constructor(quantum: Q, amount: number = 1) {\n    this.quantum = quantum;\n    this.amount = amount;\n\n    if (\n      !Number.isInteger(this.amount) ||\n      this.amount < MIN_INT ||\n      this.amount > MAX_INT\n    ) {\n      throw new Error(\n        `Unit amount absolute value must be a non-negative integer from ${MAX_INT_DESCRIPTION} to ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n  }\n\n  suffix(): string {\n    let s: string = \"\";\n    // TODO\n    const absAmount = Math.abs(this.amount);\n    if (absAmount !== 1) {\n      s += absAmount;\n    }\n    if (this.amount < 0) {\n      s += \"'\";\n    }\n    return s;\n  }\n\n  isIdentical(other: QuantumWithAmount<Q>): boolean {\n    return (\n      this.quantum.isIdentical(other.quantum) && this.amount === other.amount\n    );\n  }\n\n  // TODO: `Conjugate` and `Commutator` decrement `depth` inside the quantum, `Grouping` has to do it outside the quantum.\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth: number,\n  ): Generator<LeafUnit> {\n    const absAmount = Math.abs(this.amount);\n    const newIterDir = toggleDirection(iterDir, this.amount < 0);\n    for (let i = 0; i < absAmount; i++) {\n      yield* this.quantum.experimentalExpand(newIterDir, depth);\n    }\n  }\n}\n","import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION } from \"../../limits\";\nimport { parseMove, parseQuantumMove, transferCharIndex } from \"../../parse\";\nimport { warnOnce } from \"../../warnOnce\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { LeafUnit } from \"../Unit\";\n\ninterface QuantumMoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n}\n\nexport class QuantumMove extends Comparable {\n  readonly #family: string;\n  readonly #innerLayer: number | null;\n  readonly #outerLayer: number | null;\n\n  constructor(\n    family: string,\n    innerLayer?: number | null,\n    outerLayer?: number | null,\n  ) {\n    super();\n    this.#family = family;\n    this.#innerLayer = innerLayer ?? null;\n    this.#outerLayer = outerLayer ?? null;\n    Object.freeze(this);\n\n    if (\n      this.#innerLayer !== null &&\n      (!Number.isInteger(this.#innerLayer) ||\n        this.#innerLayer < 1 ||\n        this.#innerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove inner layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      (!Number.isInteger(this.#outerLayer) ||\n        this.#outerLayer < 1 ||\n        this.#outerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove outer layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      this.#innerLayer !== null &&\n      this.#innerLayer <= this.#outerLayer\n    ) {\n      throw new Error(\n        \"QuantumMove outer layer must be smaller than inner layer.\",\n      );\n    }\n\n    if (this.#outerLayer !== null && this.#innerLayer === null) {\n      throw new Error(\n        \"QuantumMove with an outer layer must have an inner layer\",\n      ); // TODO: test\n    }\n  }\n\n  static fromString(s: string): QuantumMove {\n    return parseQuantumMove(s);\n  }\n\n  // TODO: `modify`?\n  modified(modifications: QuantumMoveModifications): QuantumMove {\n    return new QuantumMove(\n      modifications.family ?? this.#family,\n      modifications.innerLayer ?? this.#innerLayer,\n      modifications.outerLayer ?? this.#outerLayer,\n    );\n  }\n\n  isIdentical(other: QuantumMove): boolean {\n    const otherAsQuantumMove = other;\n    return (\n      other.is(QuantumMove) &&\n      this.#family === otherAsQuantumMove.#family &&\n      this.#innerLayer === otherAsQuantumMove.#innerLayer &&\n      this.#outerLayer === otherAsQuantumMove.#outerLayer\n    );\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get family(): string {\n    return this.#family;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get outerLayer(): number | null {\n    return this.#outerLayer;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get innerLayer(): number | null {\n    return this.#innerLayer;\n  }\n\n  experimentalExpand(): Generator<LeafUnit> {\n    throw new Error(\n      \"experimentalExpand() cannot be called on a `QuantumMove` directly.\",\n    );\n  }\n\n  toString(): string {\n    let s = this.#family;\n    if (this.#innerLayer !== null) {\n      s = String(this.#innerLayer) + s;\n      if (this.#outerLayer !== null) {\n        s = String(this.#outerLayer) + \"-\" + s;\n      }\n    }\n    return s;\n  }\n}\n\nexport interface MoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n  amount?: number;\n}\n\nexport class Move extends AlgCommon<Move> {\n  readonly #quantumWithAmount: QuantumWithAmount<QuantumMove>;\n\n  constructor(\n    ...args: [QuantumMove] | [QuantumMove, number] | [string] | [string, number]\n  ) {\n    super();\n    if (typeof args[0] === \"string\") {\n      if (args[1] ?? null) {\n        this.#quantumWithAmount = new QuantumWithAmount(\n          QuantumMove.fromString(args[0]),\n          args[1],\n        );\n        return;\n      } else {\n        return Move.fromString(args[0]); // TODO: can we return here?\n      }\n    }\n    this.#quantumWithAmount = new QuantumWithAmount<QuantumMove>(\n      args[0],\n      args[1],\n    );\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsMove = other.as(Move);\n    return (\n      !!otherAsMove &&\n      this.#quantumWithAmount.isIdentical(otherAsMove.#quantumWithAmount)\n    );\n  }\n\n  invert(): Move {\n    // TODO: handle char indices more consistently among units.\n    return transferCharIndex(\n      this,\n      new Move(this.#quantumWithAmount.quantum, -this.amount),\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n  ): Generator<LeafUnit> {\n    if (iterDir === IterationDirection.Forwards) {\n      yield this;\n    } else {\n      yield this.modified({\n        amount: -this.amount,\n      });\n    }\n  }\n\n  get quantum(): QuantumMove {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  // TODO: `modify`?\n  modified(modifications: MoveModifications): Move {\n    // TODO: Avoid creating a new quantum move\n    return new Move(\n      this.#quantumWithAmount.quantum.modified(modifications),\n      modifications.amount ?? this.amount,\n    );\n  }\n\n  static fromString(s: string): Move {\n    return parseMove(s);\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"blockMove\";\n  }\n\n  /** @deprecated */\n  get family(): string {\n    return this.#quantumWithAmount.quantum.family ?? undefined;\n  }\n\n  /** @deprecated */\n  get outerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.outerLayer ?? undefined;\n  }\n\n  /** @deprecated */\n  get innerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.innerLayer ?? undefined;\n  }\n\n  toString(): string {\n    if (this.family === \"_SLASH_\") {\n      return \"/\"; // TODO: validate no amount\n    }\n    if (this.family.endsWith(\"_PLUS_\")) {\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -6) +\n        Math.abs(this.amount) +\n        (this.amount < 0 ? \"-\" : \"+\")\n      ); // TODO\n    }\n    if (this.family.endsWith(\"_PLUSPLUS_\")) {\n      const absAmount = Math.abs(this.amount);\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -10) +\n        (absAmount === 1 ? \"\" : absAmount) +\n        (this.amount < 0 ? \"--\" : \"++\")\n      ); // TODO\n    }\n\n    return (\n      this.#quantumWithAmount.quantum.toString() +\n      this.#quantumWithAmount.suffix()\n    );\n  }\n\n  // // TODO: Serialize as a string?\n  // toJSON(): MoveJSON {\n  //   return {\n  //     type: \"move\",\n  //     family: this.family,\n  //     innerLayer: this.innerLayer,\n  //     outerLayer: this.outerLayer,\n  //   };\n  // }\n}\n","import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { Move, QuantumMove } from \"../leaves/Move\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { LeafUnit } from \"../Unit\";\n\n// This is a workaround for `jest`, which doesn't handle cycles of imports inside `cubing/alg`.\n// We need to lazy-initialize the reusable quantum moves for Square-1, so we create this wrapper for it.\nclass Square1TupleFormatter {\n  quantumU_SQ_: QuantumMove | null = null;\n  quantumD_SQ_: QuantumMove | null = null;\n\n  format(grouping: Grouping): string | null {\n    const amounts = this.tuple(grouping);\n    if (!amounts) {\n      return null;\n    }\n    return `(${amounts.map((move) => move.amount).join(\", \")})`;\n  }\n\n  tuple(grouping: Grouping): [moveU: Move, moveD: Move] | null {\n    this.quantumU_SQ_ ||= new QuantumMove(\"U_SQ_\");\n    this.quantumD_SQ_ ||= new QuantumMove(\"D_SQ_\");\n\n    const quantumAlg = grouping.alg;\n    if (quantumAlg.experimentalNumUnits() === 2) {\n      const [U, D] = quantumAlg.units();\n      if (\n        U.as(Move)?.quantum.isIdentical(this.quantumU_SQ_) &&\n        D.as(Move)?.quantum.isIdentical(this.quantumD_SQ_)\n      ) {\n        if (grouping.amount !== 1) {\n          throw new Error(\n            \"Square-1 tuples cannot have an amount other than 1.\",\n          );\n        }\n        return [U as Move, D as Move]; // TODO: can we reuse the casting from above?\n      }\n    }\n    return null;\n  }\n}\nconst square1TupleFormatterInstance = new Square1TupleFormatter();\n\nexport class Grouping extends AlgCommon<Grouping> {\n  readonly #quantumWithAmount: QuantumWithAmount<Alg>;\n\n  constructor(algSource: FlexibleAlgSource, amount?: number) {\n    super();\n    const alg = experimentalEnsureAlg(algSource);\n    this.#quantumWithAmount = new QuantumWithAmount(alg, amount);\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsGrouping = other as Grouping;\n    return (\n      other.is(Grouping) &&\n      this.#quantumWithAmount.isIdentical(otherAsGrouping.#quantumWithAmount)\n    );\n  }\n\n  get alg(): Alg {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get experimentalRepetitionSuffix(): string {\n    return this.#quantumWithAmount.suffix();\n  }\n\n  invert(): Grouping {\n    return new Grouping(\n      this.#quantumWithAmount.quantum,\n      -this.#quantumWithAmount.amount,\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.#quantumWithAmount.experimentalExpand(iterDir, depth - 1);\n    }\n  }\n\n  static fromString(): Grouping {\n    throw new Error(\"unimplemented\");\n  }\n\n  toString(): string {\n    return (\n      square1TupleFormatterInstance.format(this) ??\n      `(${this.#quantumWithAmount.quantum.toString()})${this.#quantumWithAmount.suffix()}`\n    );\n  }\n\n  experimentalAsSquare1Tuple(): [moveU: Move, moveD: Move] | null {\n    return square1TupleFormatterInstance.tuple(this);\n  }\n\n  // toJSON(): GroupingJSON {\n  //   return {\n  //     type: \"grouping\",\n  //     alg: this.#quanta.quantum.toJSON(),\n  //   };\n  // }\n}\n","import type { Alg } from \"./Alg\";\nimport {\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n} from \"./units\";\n\nexport function experimentalIs(\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  v: any,\n  c:\n    | typeof Alg\n    | typeof Grouping\n    | typeof LineComment\n    | typeof Commutator\n    | typeof Conjugate\n    | typeof Move\n    | typeof Newline\n    | typeof Pause,\n): boolean {\n  return v instanceof c;\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function experimentalIsUnit(v: any): boolean {\n  return (\n    experimentalIs(v, Grouping) ||\n    experimentalIs(v, LineComment) ||\n    experimentalIs(v, Commutator) ||\n    experimentalIs(v, Conjugate) ||\n    experimentalIs(v, Move) ||\n    experimentalIs(v, Newline) ||\n    experimentalIs(v, Pause)\n  );\n}\n","import type { Alg } from \"./Alg\";\nimport { Grouping } from \"./units/containers/Grouping\";\nimport type { Comparable } from \"./common\";\nimport { Commutator } from \"./units/containers/Commutator\";\nimport { Move, QuantumMove } from \"./units/leaves/Move\";\nimport { Newline } from \"./units/leaves/Newline\";\nimport { Pause } from \"./units/leaves/Pause\";\nimport { Conjugate } from \"./units/containers/Conjugate\";\nimport { LineComment } from \"./units/leaves/LineComment\";\nimport type { Unit } from \"./units/Unit\";\n\nfunction dispatch<DataDown, DataAlgUp, DataUnitUp>(\n  t: TraversalDownUp<DataDown, DataAlgUp, DataUnitUp>,\n  unit: Unit,\n  dataDown: DataDown,\n): DataUnitUp {\n  // TODO: Can we turn this back into a `switch` or something more efficiently?\n  if (unit.is(Grouping)) {\n    return t.traverseGrouping(unit as Grouping, dataDown);\n  }\n  if (unit.is(Move)) {\n    return t.traverseMove(unit as Move, dataDown);\n  }\n  if (unit.is(Commutator)) {\n    return t.traverseCommutator(unit as Commutator, dataDown);\n  }\n  if (unit.is(Conjugate)) {\n    return t.traverseConjugate(unit as Conjugate, dataDown);\n  }\n  if (unit.is(Pause)) {\n    return t.traversePause(unit as Pause, dataDown);\n  }\n  if (unit.is(Newline)) {\n    return t.traverseNewline(unit as Newline, dataDown);\n  }\n  if (unit.is(LineComment)) {\n    return t.traverseLineComment(unit as LineComment, dataDown);\n  }\n  throw new Error(`unknown unit`);\n}\n\nfunction assertIsUnit(t: Comparable): Unit {\n  if (\n    t.is(Grouping) ||\n    t.is(Move) ||\n    t.is(Commutator) ||\n    t.is(Conjugate) ||\n    t.is(Pause) ||\n    t.is(Newline) ||\n    t.is(LineComment)\n  ) {\n    return t as Unit;\n  }\n  throw \"internal error: expected unit\"; // TODO: Make more helpful, add tests\n}\n\nexport abstract class TraversalDownUp<\n  DataDown,\n  DataAlgUp,\n  DataUnitUp = DataAlgUp,\n> {\n  // Immediate subclasses should overwrite this.\n  public traverseUnit(unit: Unit, dataDown: DataDown): DataUnitUp {\n    return dispatch(this, unit, dataDown);\n  }\n\n  public traverseIntoUnit(unit: Unit, dataDown: DataDown): Unit {\n    return assertIsUnit(this.traverseUnit(unit, dataDown) as any);\n  }\n\n  public abstract traverseAlg(alg: Alg, dataDown: DataDown): DataAlgUp;\n\n  public abstract traverseGrouping(\n    grouping: Grouping,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traverseMove(move: Move, dataDown: DataDown): DataUnitUp;\n\n  public abstract traverseCommutator(\n    commutator: Commutator,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traverseConjugate(\n    conjugate: Conjugate,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traversePause(pause: Pause, dataDown: DataDown): DataUnitUp;\n  public abstract traverseNewline(\n    newline: Newline,\n    dataDown: DataDown,\n  ): DataUnitUp;\n\n  public abstract traverseLineComment(\n    comment: LineComment,\n    dataDown: DataDown,\n  ): DataUnitUp;\n}\n\nexport abstract class TraversalUp<\n  DataAlgUp,\n  DataUnitUp = DataAlgUp,\n> extends TraversalDownUp<undefined, DataAlgUp, DataUnitUp> {\n  public traverseUnit(unit: Unit): DataUnitUp {\n    return dispatch<unknown, DataAlgUp, DataUnitUp>(this, unit, undefined);\n  }\n\n  public traverseIntoUnit(unit: Unit): Unit {\n    return assertIsUnit(this.traverseUnit(unit) as any);\n  }\n\n  public abstract traverseAlg(alg: Alg): DataAlgUp;\n  public abstract traverseGrouping(grouping: Grouping): DataUnitUp;\n  public abstract traverseMove(move: Move): DataUnitUp;\n  public abstract traverseCommutator(commutator: Commutator): DataUnitUp;\n  public abstract traverseConjugate(conjugate: Conjugate): DataUnitUp;\n  public abstract traversePause(pause: Pause): DataUnitUp;\n  public abstract traverseNewline(newline: Newline): DataUnitUp;\n  public abstract traverseLineComment(comment: LineComment): DataUnitUp;\n}\n\nexport interface SimplifyOptions {\n  collapseMoves?: boolean;\n  quantumMoveOrder?: (quantumMove: QuantumMove) => number;\n  depth?: number | null; // TODO: test\n}\n\n// TODO: Test that inverses are bijections.\nclass Simplify extends TraversalDownUp<SimplifyOptions, Generator<Unit>> {\n  static #newAmount(\n    move: Move,\n    deltaAmount: number,\n    options: SimplifyOptions,\n  ): number {\n    let newAmount = move.amount + deltaAmount;\n    if (options?.quantumMoveOrder) {\n      const order = options.quantumMoveOrder(move.quantum);\n      // Examples:\n      //  order 4  min -1 (e.g. cube)\n      //  order 5  min -2 (e.g. Megaminx)\n      //  order 3  min -1 (e.g. Pyraminx)\n      const min = Math.floor(order / 2) + 1 - order;\n      newAmount = (((newAmount % order) + order - min) % order) + min; // TODO\n    }\n    return newAmount;\n  }\n\n  // TODO: Handle\n  public *traverseAlg(alg: Alg, options: SimplifyOptions): Generator<Unit> {\n    if (options.depth === 0) {\n      yield* alg.units();\n      return;\n    }\n\n    const newUnits: Unit[] = [];\n    let lastUnit: Unit | null = null;\n    const collapseMoves = options?.collapseMoves ?? true;\n    function appendMoveWithNewAmount(move: Move, deltaAmount: number): boolean {\n      const newAmount = Simplify.#newAmount(move, deltaAmount, options);\n      if (newAmount === 0) {\n        return false;\n      }\n      const newMove = new Move(move.quantum, newAmount);\n      newUnits.push(newMove);\n      lastUnit = newMove;\n      return true;\n    }\n    function appendCollapsed(newUnit: Unit) {\n      if (\n        collapseMoves &&\n        lastUnit?.is(Move) &&\n        newUnit.is(Move) &&\n        (lastUnit as Move).quantum.isIdentical((newUnit as Move).quantum)\n      ) {\n        newUnits.pop();\n        if (\n          !appendMoveWithNewAmount(lastUnit as Move, (newUnit as Move).amount)\n        ) {\n          lastUnit = newUnits.slice(-1)[0];\n        }\n      } else {\n        if (newUnit.is(Move)) {\n          appendMoveWithNewAmount(newUnit as Move, 0);\n        } else {\n          newUnits.push(newUnit);\n          lastUnit = newUnit;\n        }\n      }\n    }\n\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    for (const unit of alg.units()) {\n      for (const ancestorUnit of this.traverseUnit(unit, newOptions)) {\n        appendCollapsed(ancestorUnit);\n      }\n    }\n    for (const unit of newUnits) {\n      yield unit;\n    }\n  }\n\n  public *traverseGrouping(\n    grouping: Grouping,\n    options: SimplifyOptions,\n  ): Generator<Unit> {\n    if (options.depth === 0) {\n      yield grouping;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    yield new Grouping(this.traverseAlg(grouping.alg, newOptions));\n  }\n\n  public *traverseMove(move: Move, _options: SimplifyOptions): Generator<Unit> {\n    yield move;\n  }\n\n  public *traverseCommutator(\n    commutator: Commutator,\n    options: SimplifyOptions,\n  ): Generator<Unit> {\n    if (options.depth === 0) {\n      yield commutator;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    yield new Commutator(\n      this.traverseAlg(commutator.A, newOptions),\n      this.traverseAlg(commutator.B, newOptions),\n    );\n  }\n\n  public *traverseConjugate(\n    conjugate: Conjugate,\n    options: SimplifyOptions,\n  ): Generator<Unit> {\n    if (options.depth === 0) {\n      yield conjugate;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    yield new Conjugate(\n      this.traverseAlg(conjugate.A, newOptions),\n      this.traverseAlg(conjugate.B, newOptions),\n    );\n  }\n\n  public *traversePause(\n    pause: Pause,\n    _options: SimplifyOptions,\n  ): Generator<Unit> {\n    yield pause;\n  }\n\n  public *traverseNewline(\n    newline: Newline,\n    _options: SimplifyOptions,\n  ): Generator<Unit> {\n    yield newline;\n  }\n\n  public *traverseLineComment(\n    comment: LineComment,\n    _options: SimplifyOptions,\n  ): Generator<Unit> {\n    yield comment;\n  }\n}\n\nconst simplifyInstance = new Simplify();\nexport const simplify = simplifyInstance.traverseAlg.bind(simplifyInstance) as (\n  alg: Alg,\n  options: SimplifyOptions,\n) => Generator<Unit>;\n","import { AlgCommon, Comparable } from \"./common\";\nimport { experimentalIs, experimentalIsUnit } from \"./is\";\nimport { direct, IterationDirection, reverse } from \"./iteration\";\nimport { parseAlg } from \"./parse\";\nimport { simplify, SimplifyOptions } from \"./traversal\";\nimport { LineComment } from \"./units/leaves/LineComment\";\nimport { Move } from \"./units/leaves/Move\";\nimport { Newline } from \"./units/leaves/Newline\";\nimport type { LeafUnit, Unit } from \"./units/Unit\";\nimport { warnOnce } from \"./warnOnce\";\n\nexport type FlexibleAlgSource = string | Iterable<Unit> | Alg;\n\n// TODO: validate\nfunction toIterable(input?: FlexibleAlgSource): Iterable<Unit> {\n  if (!input) {\n    return [];\n  }\n\n  if (experimentalIs(input, Alg)) {\n    return (input as Alg).units();\n  }\n\n  if (typeof input === \"string\") {\n    return parseAlg(input).units(); // TODO: something more direct?\n  }\n\n  // const seq = inputUnits as Sequence;\n  // if (seq.type === \"sequence\" && seq.nestedUnits) {\n  //   throw new Error(\"unimplemented\");\n  //   // return seq.nestedUnits;\n  // }\n\n  const iter = input as Iterable<Unit>;\n  if (typeof iter[Symbol.iterator] === \"function\") {\n    return iter; // TODO: avoid allocations\n  }\n\n  throw \"Invalid unit\";\n}\n\n// Preserves the alg if it's already an `Alg`.\nexport function experimentalEnsureAlg(alg: FlexibleAlgSource): Alg {\n  if (experimentalIs(alg, Alg)) {\n    return alg as Alg;\n  }\n  return new Alg(alg);\n}\n\n/**\n * Alg is a class that encapsulated a structured alg. To create an alg from a string, use:\n *\n *     new Alg(\"R U R'\"); // Convenient\n *     Alg.fromString(dynamicString); // Recommended when handling dynamic input.\n *\n * Once you have an Alg, you can call methods to transform it:\n *\n *     new Alg(\"[[R: U], R U R2']\").expand().simplify().invert();\n *\n * To convert an Alg to a string, use .toString():\n *\n *     new Alg(\"R U F\").invert().toString();\n *\n * If you need to debug, you may also find it convenient to use .log():\n *\n *     if (alg.isIdentical(alg.invert())) {\n *       alg.log(\"A self-inverse!\")\n *     }\n *\n * For more information, see: {@link https://js.cubing.net/cubing/alg/}\n *\n */\nexport class Alg extends AlgCommon<Alg> {\n  // #debugString: string;\n  #units: Iterable<Unit>; // TODO: freeze?\n  constructor(alg?: FlexibleAlgSource) {\n    super();\n    this.#units = Array.from(toIterable(alg)); // TODO: can we avoid array-casting?\n    // this.#debugString = this.toString();\n\n    for (const unit of this.#units) {\n      if (!experimentalIsUnit(unit)) {\n        throw new Error(\"An alg can only contain units.\");\n      }\n    }\n  }\n\n  /**\n   * Checks whether this Alg is structurally identical to another Alg. This\n   * essentially means that they are written identically apart from whitespace.\n   *\n   *     const alg1 = new Alg(\"R U L'\");\n   *     const alg2 = new Alg(\"L U' R'\").invert();\n   *     // true\n   *     alg1.isIdentical(alg2);\n   *\n   *     // false\n   *     new Alg(\"[R, U]\").isIdentical(new Alg(\"R U R' U'\"));\n   *     // true\n   *     new Alg(\"[R, U]\").expand().isIdentical(new Alg(\"R U R' U'\"));\n   *\n   * Note that .isIdentical() efficiently compares algorithms, but mainly exists\n   * to help optimize code when the structure of an algorithm hasn't changed.\n   * There are many ways to write the \"same\" alg on most puzzles, but is\n   * *highly* recommended to avoid expanding two Alg instances to compare them,\n   * since that can easily slow your program to a crawl if someone inputs an alg\n   * containing a large repetition. In general, you should use `cubing/kpuzzle`\n   * to compare if two algs have the same effect on a puzzle.\n   *\n   * Also note that parser annotations are not take into account while comparing\n   * algs:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\")]);\n   *     // true, even though one of the algs has parser annotations\n   *     alg.isIdentical(new Alg(\"R U2\"))\n   *\n   */\n  isIdentical(other: Comparable): boolean {\n    const otherAsAlg = other as Alg;\n    if (!other.is(Alg)) {\n      return false;\n    }\n\n    // TODO: avoid converting to array\n    const l1 = Array.from(this.#units);\n    const l2 = Array.from(otherAsAlg.#units);\n    if (l1.length !== l2.length) {\n      return false;\n    }\n    for (let i = 0; i < l1.length; i++) {\n      if (!l1[i].isIdentical(l2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the inverse of the given alg.\n   *\n   * Note that that this does not make any assumptions about what puzzle the alg\n   * is for. For example, U2 is its own inverse on a cube, but U2' has the same\n   * effect U3 (and not U2) on Megaminx:\n   *\n   *     // Outputs: R U2' L'\n   *     new Alg(\"L U2 R'\").invert().log();\n   */\n  invert(): Alg {\n    // TODO: Handle newLines and comments correctly\n    // TODO: Make more efficient.\n    return new Alg(reverse(Array.from(this.#units).map((u) => u.invert())));\n  }\n\n  /** @deprecated Use {@link Alg.expand} instead. */\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<LeafUnit> {\n    depth ??= Infinity;\n    for (const unit of direct(this.#units, iterDir)) {\n      yield* unit.experimentalExpand(iterDir, depth);\n    }\n  }\n\n  /**\n   * Expands all Grouping, Commutator, and Conjugate parts nested inside the\n   * alg.\n   *\n   *     // F R U R' U' F'\n   *     new Alg(\"[F: [R, U]]\").expand().log();\n   *\n   *     // F [R, U] F'\n   *     new Alg(\"[F: [R, U]]\").expand(({ depth: 1 }).log();\n   *\n   * Avoid calling this on a user-provided alg unless the user explicitly asks\n   * to see the expanded alg. Otherwise, it's easy to make your program freeze\n   * when someone passes in an alg like: (R U)10000000\n   *\n   * Generally, if you want to perform an operation on an entire alg, you'll\n   * want to use something based on the `Traversal` mechanism, like countMoves()\n   * from `cubing/notation`.\n   */\n  expand(options?: { depth?: number }): Alg {\n    return new Alg(\n      this.experimentalExpand(\n        IterationDirection.Forwards,\n        options?.depth ?? Infinity,\n      ),\n    );\n  }\n\n  /** @deprecated */\n  *experimentalLeafMoves(): Generator<Move> {\n    for (const leaf of this.experimentalExpand()) {\n      if (leaf.is(Move)) {\n        yield leaf as Move;\n      }\n    }\n  }\n\n  concat(input: FlexibleAlgSource): Alg {\n    return new Alg(\n      Array.from(this.#units).concat(Array.from(toIterable(input))),\n    );\n  }\n\n  /** @deprecated */\n  experimentalIsEmpty(): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const _ of this.#units) {\n      return false;\n    }\n    return true;\n  }\n\n  static fromString(s: string): Alg {\n    return parseAlg(s);\n  }\n\n  *units(): Generator<Unit> {\n    for (const unit of this.#units) {\n      yield unit;\n    }\n  }\n\n  experimentalNumUnits(): number {\n    return Array.from(this.#units).length;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"sequence\";\n  }\n\n  // toJSON(): AlgJSON {\n  //   return {\n  //     type: \"alg\",\n  //     units: Array.from(this.#units) as UnitJSON[],\n  //   };\n  // }\n\n  /**\n   * Converts the Alg to a string:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\"), new Move(\"L\")])\n   *     // R U2 L\n   *     console.log(alg.toString())\n   */\n  toString(): string {\n    let output = \"\";\n    let previousUnit: Unit | null = null;\n    for (const unit of this.#units) {\n      if (previousUnit) {\n        output += spaceBetween(previousUnit, unit);\n        // console.log(\"l\", previousUnit.toString(), unit.toString(), output);\n      }\n      output += unit.toString();\n      previousUnit = unit;\n    }\n    return output;\n  }\n\n  // *experimentalExpand(options: ExperimentalExpandOptions): Generator<Unit> {\n  //   // if (options.depth === 0) {\n  //   //   yield* this.units();\n  //   //   return;\n  //   // }\n  //   // const newOptions = {\n  //   //   depth: options.depth ? options.depth - 1 : null,\n  //   // }; // TODO: avoid allocations?\n  //   // for (const unit of this.#units) {\n  //   //   yield* unit.experimentalExpandIntoAlg(newOptions);\n  //   // }\n  // }\n\n  simplify(options?: SimplifyOptions): Alg {\n    return new Alg(simplify(this, options ?? {}));\n  }\n}\n\nfunction spaceBetween(u1: Unit, u2: Unit): string {\n  if (u1.is(Newline) || u2.is(Newline)) {\n    return \"\";\n  }\n  if (u1.is(LineComment) && !u2.is(Newline)) {\n    return \"\\n\"; /// TODO\n  }\n  return \" \";\n}\n","// tslint:disable-next-line no-namespace // TODO: nested module\n\nimport { Alg } from \"./Alg\";\nimport { Grouping } from \"./units\";\nimport { Commutator } from \"./units/containers/Commutator\";\nimport { Conjugate } from \"./units/containers/Conjugate\";\nimport { Move } from \"./units/leaves/Move\";\nimport { Pause } from \"./units/leaves/Pause\";\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport const Example = {\n  Sune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -2),\n    new Move(\"R\", -1),\n  ]),\n\n  AntiSune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 2),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n  ]),\n\n  SuneCommutator: new Alg([\n    new Commutator(\n      new Alg([new Move(\"R\", 1), new Move(\"U\", 1), new Move(\"R\", -2)]),\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n    ),\n  ]),\n\n  Niklas: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"L\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"L\", 1),\n    new Move(\"U\", 1),\n  ]),\n\n  EPerm: new Alg([\n    new Move(\"x\", -1),\n    new Commutator(\n      new Alg([\n        new Conjugate(\n          new Alg([new Move(\"R\", 1)]),\n          new Alg([new Move(\"U\", -1)]),\n        ),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Commutator(\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Move(\"x\", 1),\n  ]),\n\n  FURURFCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"U\", 1)]),\n          new Alg([new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  APermCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"R\", 2)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"F\", 2)]),\n          new Alg([new Move(\"R\", -1), new Move(\"B\", -1), new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  FURURFMoves: new Alg([\n    new Move(\"F\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  TPerm: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", 1),\n    new Move(\"R\", 2),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  HeadlightSwaps: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Grouping(\n          new Alg([\n            new Commutator(\n              new Alg([new Move(\"R\", 1)]),\n              new Alg([new Move(\"U\", 1)]),\n            ),\n          ]),\n          3,\n        ),\n      ]),\n    ),\n  ]),\n\n  TriplePause: new Alg([new Pause(), new Pause(), new Pause()]),\n\n  // AllAlgParts: [\n  //   new Alg([new Move(\"R\", 1), new Move(\"U\", -1)]),\n  //   new Grouping(new Alg([new Move(\"F\", 1)]), 2),\n  //   // new Rotation(\"y\", -1),\n  //   new Move(\"R\", 2),\n  //   new Commutator(new Alg([new Move(\"R\", 2)]), new Alg([new Move(\"U\", 2)]), 2),\n  //   new Conjugate(new Alg([new Move(\"L\", 2)]), new Alg([new Move(\"D\", -1)]), 2),\n  //   new Pause(),\n  //   new Newline(),\n  //   new LineComment(\"line comment\"),\n  // ],\n};\n","import { Move } from \"./units/leaves/Move\";\n\nconst cubeKeyMapping: { [key: number]: Move } = {\n  73: new Move(\"R\"),\n  75: new Move(\"R'\"),\n  87: new Move(\"B\"),\n  79: new Move(\"B'\"),\n  83: new Move(\"D\"),\n  76: new Move(\"D'\"),\n  68: new Move(\"L\"),\n  69: new Move(\"L'\"),\n  74: new Move(\"U\"),\n  70: new Move(\"U'\"),\n  72: new Move(\"F\"),\n  71: new Move(\"F'\"),\n\n  78: new Move(\"x'\"),\n  67: new Move(\"l\"),\n  82: new Move(\"l'\"),\n  85: new Move(\"r\"),\n  77: new Move(\"r'\"),\n\n  88: new Move(\"d\"),\n  188: new Move(\"d'\"),\n\n  84: new Move(\"x\"),\n  89: new Move(\"x\"),\n  66: new Move(\"x'\"),\n  186: new Move(\"y\"),\n  59: new Move(\"y\"),\n  65: new Move(\"y'\"), // 186 is WebKit, 59 is Mozilla; see http://unixpapa.com/js/key.html\n  80: new Move(\"z\"),\n  81: new Move(\"z'\"),\n\n  90: new Move(\"M'\"),\n  190: new Move(\"M'\"),\n};\n\n// TODO: options about whether to ignore modifier keys (e.g. alt, ctrl).\n// TODO: Support different mappings.\n// TODO: Return BaseMove instead?\nexport function keyToMove(e: KeyboardEvent): Move | null {\n  if (e.altKey || e.ctrlKey) {\n    return null;\n  }\n\n  return cubeKeyMapping[e.keyCode] || null;\n}\n","import { Alg } from \"./Alg\";\nimport type { Move } from \"./units/leaves/Move\";\n\nexport function experimentalAppendMove(\n  alg: Alg,\n  newMove: Move,\n  options?: {\n    coalesce?: boolean; // defaults to false\n    mod?: number;\n  },\n): Alg {\n  const oldUnits = Array.from(alg.units());\n  const oldLastMove = oldUnits[oldUnits.length - 1] as Move | undefined;\n  if (\n    options?.coalesce &&\n    oldLastMove &&\n    oldLastMove.quantum &&\n    oldLastMove.quantum.isIdentical(newMove.quantum)\n  ) {\n    const newUnits = oldUnits.slice(0, oldUnits.length - 1);\n    let newAmount = oldLastMove.amount + newMove.amount;\n    const mod = options?.mod;\n    if (mod) {\n      newAmount = ((newAmount % mod) + mod) % mod;\n      if (newAmount * 2 > mod) {\n        newAmount -= mod;\n      }\n    }\n    if (newAmount !== 0) {\n      newUnits.push(oldLastMove.modified({ amount: newAmount }));\n    }\n    return new Alg(newUnits);\n  } else {\n    return new Alg([...oldUnits, newMove]);\n  }\n}\n","module.exports = Promise.all([__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"hPxUV\")), __parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"gW5g5\"))]).then(() => parcelRequire('ikk6p'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"iak3L\"))).then(() => parcelRequire('5EXOu'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"3tHIy\"))).then(() => parcelRequire('9RkB3'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"lfz5Q\"))).then(() => parcelRequire('9GPYv'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"4UNjE\"))).then(() => parcelRequire('oGs7p'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"91rD7\"))).then(() => parcelRequire('kMaxg'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"lMvhS\"))).then(() => parcelRequire('l8vvO'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"dRtyN\"))).then(() => parcelRequire('jWUwg'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"kziDj\"))).then(() => parcelRequire('Qa0PX'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"1uf7V\"))).then(() => parcelRequire('5aOeo'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"aGyuS\"))).then(() => parcelRequire('71hVm'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"2tl92\"))).then(() => parcelRequire('exL2t'));","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"gyTEh\"))).then(() => parcelRequire('6PzdC'));"],"names":["parcelRequire","register","JSON","parse","$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","pairs","keys","Object","i","length","id","resolved","Error","$51e649f260337ac6$var$descAsyncGetPuzzleGeometry","desc","getPuzzleGeometryByDesc","allMoves","orientCenters","addRotations","$51e649f260337ac6$var$nextCustomID","$51e649f260337ac6$export$edc4dd73f2bc7c3f","info","customID","cachedKPuzzle","puzzleLoader","fullName","kpuzzle","async","pg","kpuzzleDefinition","getKPuzzleDefinition","name","pgNotation","ExperimentalPGNotation","getOrbitsDef","$dKxIg","KPuzzle","experimentalPGNotation","$51e649f260337ac6$var$asyncGetKPuzzle","svg","generatesvg","inventedBy","inventionYear","$51e649f260337ac6$var$wcaEvents","puzzleID","eventName","clock","minx","pyram","skewb","sq1","$51e649f260337ac6$var$PieceStickering","PieceStickering2","$51e649f260337ac6$export$a5563e03823fac75","appearance","orbitName","pieceIdx","faceletIdx","hint","pieceAppearance","orbits","pieces","$51e649f260337ac6$var$regular","faceletAppearance","facelets","hintAppearance","$51e649f260337ac6$var$PieceAnnotation","defaultValue","this","stickerings","Map","orbitDef","entries","definition","set","Array","numPieces","fill","$51e649f260337ac6$var$ignored","$51e649f260337ac6$var$oriented","$51e649f260337ac6$var$invisible","$51e649f260337ac6$var$dim","$51e649f260337ac6$var$r","$51e649f260337ac6$var$i","$51e649f260337ac6$var$o","$51e649f260337ac6$var$invisiblePiece","$51e649f260337ac6$var$riiii","$51e649f260337ac6$var$drrrr","$51e649f260337ac6$var$d","$51e649f260337ac6$var$diiii","$51e649f260337ac6$var$oiiii","$51e649f260337ac6$var$getPieceAppearance","pieceStickering","Regular","Dim","Ignored","OrientationStickers","Invisible","IgnoreNonPrimary","PermuteNonPrimary","Ignoriented","OrientationWithoutPermutation","$51e649f260337ac6$var$_cachedPG","$51e649f260337ac6$var$_cachedKPuzzle","$51e649f260337ac6$var$_cachedSVG","$51e649f260337ac6$var$PuzzleStickering","super","pieceSet","i2","get","toAppearance","pieceStickerings","orbitAppearance","push","$51e649f260337ac6$var$StickeringManager","and","pieceSets","newPieceSet","pieceLoop","or","not","all","moves","move","moveSource","transformation","moveToTransformation","transformationData","permutation","orientation","moveSources","map","$51e649f260337ac6$var$globalCustomStickerer","$51e649f260337ac6$export$35b727ea49e69201","stickering","puzzleStickering","m","LL","orUD","E","orLR","M","orFB","S","F2L","centerU","edgeFR","cornerDFR","slotFR","CENTERS","EDGES","CORNERS","L6E","dimF2L","setPLL","setOLL","$51e649f260337ac6$var$useGlobalCustomStickerer","console","warn","$51e649f260337ac6$var$cubeStickerings","$51e649f260337ac6$var$getCached","getValue","cachedPromise","$51e649f260337ac6$var$asyncGetPuzzleGeometry","puzzleName","getPuzzleGeometryByName","globalThis","location","URL","href","searchParams","window","setGlobalCustomStickerer","stickerer","players","from","document","body","querySelectorAll","log","successPromises","player","experimentalModel","experimentalStickering","Promise","PieceStickering","$51e649f260337ac6$var$PGPuzzleLoader","$cks0r","__privateAdd","pgId","pgID","__privateGet","__privateSet","pgPromise","$51e649f260337ac6$var$asyncGetKPuzzle2","WeakMap","$51e649f260337ac6$var$CubePGPuzzleLoader","arguments","$51e649f260337ac6$export$75b089e783ade19b","cube2x2x2KPuzzleDefinition","default","$51e649f260337ac6$export$c52e9d2f3741ae58","experimental3x3x3KPuzzle","llSVG","$51e649f260337ac6$var$clock","clockKPuzzleDefinition","$51e649f260337ac6$var$ftoStickerings","$51e649f260337ac6$var$fto","experimentalFTO_FC","experimentalFTO_F2T","experimentalFTO_SC","experimentalFTO_L2C","experimentalFTO_LBT","$51e649f260337ac6$var$ftoStickering","$51e649f260337ac6$var$megaminxStickerings","$51e649f260337ac6$var$megaminx","$51e649f260337ac6$var$megaminxAppearance","$51e649f260337ac6$var$pyraminx","$51e649f260337ac6$var$square1","sq1HyperOrbitKPuzzleDefinition","$51e649f260337ac6$var$kilominx","stringify","CENTERS2","startStateData","moveDefinition","values","experimentalPuzzleDescription","lookupMove","toString","x2Transformation","algToTransformation","kilominxSVG","$51e649f260337ac6$var$rediCube","rediCubeKPuzzleDefinition","rediCubeSVG","$51e649f260337ac6$export$d0e8cc4bac949be1","megaminx","fto","gigaminx","master_tetraminx","redi_cube","$a029b8f38502989b$var$combineTransformationData","transformationData1","transformationData2","newTransformationData","orbitDefinition","orbit1","orbit2","$a029b8f38502989b$var$isOrbitTransformationDataIdentityUncached","numOrientations","newPerm","idx","newOri","$a029b8f38502989b$var$applyTransformationDataToStateData","stateData","newStateData","newPieces","$a029b8f38502989b$var$identityOrbitCache","$a029b8f38502989b$var$constructIdentityOrbitTransformation","cached","newPermutation","newOrientation","orbitTransformation","$a029b8f38502989b$var$_cachedIsIdentity","$a029b8f38502989b$export$ad3cd44c975e2fe3","apply","source","applyTransformation","toTransformation","isIdentityTransformation","applyMove","applyAlg","alg","experimentalToTransformation","canConvertStateToUniqueTransformation","stateOrbitData","transformationOrbit","$a029b8f38502989b$export$c97306ff17e651e8","$a029b8f38502989b$var$_KTransformation","invert","$a029b8f38502989b$var$invertTransformation","isIdentical","identityTransformation","$a029b8f38502989b$var$constructIdentityTransformationDataUncached","t2","$a029b8f38502989b$var$isOrbitTransformationDataIdentical","$a029b8f38502989b$var$isTransformationDataIdentical","toKState","fromTransformation","repetitionOrder","order","orbitPieces","startIdx","currentIdx","orientationSum","cycleLength","$a029b8f38502989b$var$gcd","$a029b8f38502989b$var$transformationRepetitionOrder","selfMultiply","amount","$a029b8f38502989b$var$repeatTransformationUncached","orbitTransformationData","orbitTransformationData1","orbitTransformationData2","options","ignoreOrientation","ignorePermutation","fromIdx","halfish","Math","floor","twiceHalfish","$a029b8f38502989b$var$_moveToTransformationDataCache","$a029b8f38502989b$var$_cachedCanConvertStateToUniqueTransformation","$a029b8f38502989b$var$algToTransformationInstance","$98KNc","TraversalDownUp","traverseAlg","unit","units","traverseUnit","traverseGrouping","grouping","algTransformation","traverseMove","traverseCommutator","commutator","aTransformation","A","bTransformation","B","traverseConjugate","conjugate","traversePause","_","traverseNewline","traverseLineComment","$a029b8f38502989b$var$algToTransformation","bind","a","b","$a029b8f38502989b$export$5d975d639f9eb1a3","experimentalConstructIdentity","Move","cacheKey","cachedTransformationData","quantumKey","quantum","quantumMoveDefinition","derivedFrom","experimentalDerivedMoves","inverseMoveDefinition","$a029b8f38502989b$var$moveToTransformationUncached","Alg","is","startState","piece","piece1","state","reset","_move","_alg","$a029b8f38502989b$var$cube3x3x3KPuzzleDefinition","U","y","x","L","F","R","D","z","u","l","f","r","d","$a029b8f38502989b$export$1fbb93a14e55e846","$6a79286bccd321dd$export$ec810cf44eb98f56","IterationDirection3","$6a79286bccd321dd$var$Comparable","c","as","$6a79286bccd321dd$var$AlgCommon","$6a79286bccd321dd$export$d32346616aa538f3","g","iterDir","reverse","$6a79286bccd321dd$export$845111c728f7985d","direction","t","$6a79286bccd321dd$var$reverseGenerator","$6a79286bccd321dd$var$_units","$6a79286bccd321dd$var$_A","$6a79286bccd321dd$var$_B","$6a79286bccd321dd$var$MAX_INT","$6a79286bccd321dd$export$d5b45e94760ffddd","experimentalPushAlg","experimentalNumUnits","toAlg","$6a79286bccd321dd$export$e5a7308a1ffbe909","$6a79286bccd321dd$var$_A2","$6a79286bccd321dd$var$_B2","$6a79286bccd321dd$var$_Commutator","aSource","bSource","$6a79286bccd321dd$var$experimentalEnsureAlg","other","otherAsCommutator","Forwards","depth","Infinity","experimentalExpand","Backwards","$6a79286bccd321dd$export$13a2aeb669e49c0","$6a79286bccd321dd$var$_text","$6a79286bccd321dd$var$_Conjugate","otherAsConjugate","$6a79286bccd321dd$export$21829b047cfb53df","$6a79286bccd321dd$var$_LineComment","commentText","includes","text","otherAsLineComment","_iterDir","_depth","$6a79286bccd321dd$export$e6476262d0d4122e","$6a79286bccd321dd$export$5e2e13009fd73086","$6a79286bccd321dd$export$59704c468e1a1527","$6a79286bccd321dd$var$parseIntWithEmptyFallback","n","emptyFallback","parseInt","$6a79286bccd321dd$var$_input","$6a79286bccd321dd$var$_idx","$6a79286bccd321dd$var$amountRegex","$6a79286bccd321dd$var$moveStartRegex","$6a79286bccd321dd$var$quantumMoveRegex","$6a79286bccd321dd$var$commentTextRegex","$6a79286bccd321dd$var$square1PairStart","$6a79286bccd321dd$var$square1PairEnd","$6a79286bccd321dd$var$parseAlg","s","$6a79286bccd321dd$var$AlgParser","parseAlg","$6a79286bccd321dd$var$addCharIndices","startCharIndex","endCharIndex","parsedT","input","parseAlgWithStopping","mustBeAtEndOfInput","parseMove","parseMoveImpl","parseQuantumMove","quantumMove","parseQuantumMoveImpl","stopBefore","algStartIdx","algEndIdx","algBuilder","crowded","mustNotBeCrowded","mainLoop","savedCharIndex","tryConsumeNext","test","sq1PairStartMatch","tryRegex","topAmountString","savedCharIndexD","sq1PairEndMatch","parseRegex","uMove","$6a79286bccd321dd$export$e49a5ad3dd6df925","$6a79286bccd321dd$export$9bfa9ee45a81759e","dMove","$6a79286bccd321dd$export$3885c0af90651e94","mustConsumeNext","parseAmount","popNext","separator","outerLayerStr","innerLayerStr","family","hadEmptyAbsAmount","parseAmountAndTrackEmptyAbsAmount","suffix","parseMoveSuffix","startsWith","modified","savedIdx","absAmountStr","primeStr","regex","arr","exec","remaining","slice","next","__privateWrapper","expected","$6a79286bccd321dd$var$warned","Set","$6a79286bccd321dd$var$warnOnce","has","add","$6a79286bccd321dd$var$_family","$6a79286bccd321dd$var$_innerLayer","$6a79286bccd321dd$var$_outerLayer","$6a79286bccd321dd$var$_quantumWithAmount","$6a79286bccd321dd$var$QuantumWithAmount","Number","isInteger","absAmount","abs","newIterDir","iterationDirection","flip","$6a79286bccd321dd$var$toggleDirection","$6a79286bccd321dd$var$_QuantumMove","innerLayer","outerLayer","freeze","$6a79286bccd321dd$var$parseQuantumMove","modifications","otherAsQuantumMove","String","$6a79286bccd321dd$var$_Move","args","fromString","otherAsMove","to","$6a79286bccd321dd$var$parseMove","type","endsWith","$6a79286bccd321dd$var$_quantumWithAmount2","$6a79286bccd321dd$var$square1TupleFormatterInstance","quantumU_SQ_","quantumD_SQ_","format","amounts","tuple","join","quantumAlg","$6a79286bccd321dd$var$_Grouping","algSource","otherAsGrouping","experimentalRepetitionSuffix","experimentalAsSquare1Tuple","$6a79286bccd321dd$export$8f2093504a51c1a5","v","$6a79286bccd321dd$var$dispatch","dataDown","$6a79286bccd321dd$var$assertIsUnit","$6a79286bccd321dd$var$_newAmount","$6a79286bccd321dd$var$newAmount_fn","$6a79286bccd321dd$export$5b23793b60fb4cfe","traverseIntoUnit","$6a79286bccd321dd$export$78fadb44b4228be0","$6a79286bccd321dd$var$_Simplify","newUnits","lastUnit","collapseMoves","appendMoveWithNewAmount","deltaAmount","_a","newAmount","__privateMethod","call","newMove","newOptions","ancestorUnit","newUnit","pop","unit1","_options","pause","newline","comment","$6a79286bccd321dd$var$Simplify","WeakSet","quantumMoveOrder","min","$6a79286bccd321dd$var$_units2","$6a79286bccd321dd$var$simplifyInstance","$6a79286bccd321dd$var$simplify","$6a79286bccd321dd$var$toIterable","iter","Symbol","iterator","$6a79286bccd321dd$var$_Alg","otherAsAlg","l1","l2","expand","leaf","concat","experimentalIsEmpty","output","previousUnit","$6a79286bccd321dd$var$spaceBetween","simplify","u1","u2","$6a79286bccd321dd$export$730b7873cfa7a92","oldUnits","oldLastMove","coalesce","mod","module","exports","resolve","then","import"],"version":3,"file":"index.b9099a78.js.map"}